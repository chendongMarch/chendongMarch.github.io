<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2Farticle%2F0%2F</url>
    <content type="text"><![CDATA[ElementTable hover 时高亮.table-content 是给 el-table 加的 class 123456789.table-content.el-table .el-table__row:hover &#123; background: transparent;&#125;.table-content.el-table tr:hover &#123; background: transparent;&#125;.el-table tbody tr:hover &gt; td &#123; background-color: transparent !important&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Farticle%2F0%2F</url>
    <content type="text"><![CDATA[依赖说明1234567891011121314// JSPimplementation 'javax.servlet:jstl'implementation 'org.apache.tomcat.embed:tomcat-embed-jasper'// 数据库implementation 'org.springframework.boot:spring-boot-starter-jdbc'implementation 'org.mybatis.spring.boot:mybatis-spring-boot-starter:2.1.1'runtimeOnly 'mysql:mysql-connector-java'// webimplementation 'org.springframework.boot:spring-boot-starter-web'// 热部署developmentOnly 'org.springframework.boot:spring-boot-devtools' 热部署 依赖 developmentOnly &#39;org.springframework.boot:spring-boot-devtools&#39; Setting -&gt; Compiler -&gt; build auto 勾选 Ctrl + Shfit + A 搜索 Registry 勾选 compiler.automake.allow.when.app.running 配置application.yaml 123456789101112131415161718192021222324server: port: 8089 servlet: context-path: /zfyspring: mvc: view: suffix: .jsp prefix: /WEB-INF/views/ datasource: url: jdbc:mysql://127.0.0.1:3306/db_blog?characterEncoding=UTF-8 username: root password: chendong911091 driver-class-name: com.mysql.cj.jdbc.Driverauthor: name: chendong description: Welcome To My Server, My Name Is $&#123;author.name&#125;mybatis: configuration: # 下划线命名转驼峰 map-underscore-to-camel-case: true Swagger12345@Api@ApiOperation@ApiModel@ApiModelProperties@ApiParam RabbitMQ12345678910111213141516171819202122232425brew install rabbitmqerl -version路径 /usr/local/Cellar/rabbitmq/3.8.0/sbin启动服务sudo ./rabbitmq-server start停止服务sudo ./rabbitmq-server stop安装WebUIsudo ./rabbitmq-plugins enable rabbitmq_management// 添加用户sudo ./rabbitmqctl add_user chen chen// 为用户设置 tagsudo ./rabbitmqctl set_user_tags chen administrator// 设置权限sudo ./rabbitmqctl ser_permissions chen -p &quot;/&quot; chen &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;// 查看用户sudo ./rabbitmqctl list_users 同步变异步解耦流量削峰 发布订阅模式 direct主题订阅模式 topic docker物理机 -》 虚拟机 ——〉 123456789101112131415161718192021222324252627282930// 安装 ngdocker run -p 80:80 -d nginx// 查看本地镜像docker images// 查找镜像docker search mysql// 获取镜像docker pull mysql:5.7// 删除镜像docker rmi [IMAGE ID]// 构建docker build -t registy-chen/appimg:1.0.0 .docker run -d -p 8089:8089 --name=chenapp3 registy-chen/appimg:1.0.0// 登录docker login// 命名docker tag registy-chen/appimg:1.0.0 chendongmarch/zfy-repo:1.0.0// 推送镜像docker push chendongmarch/zfy-repo:1.0.0// 拉取镜像docker pull chendongmarch/zfy-repo:1.0.0// 启动容器sudo docker run -d -p 5000:5000 --restart=always --privileged=true --name=registry-zfy -v /Users/march/Downloads/test_code/docker-build/registry:/var/lib/registry registrycurl -X GET http://127.0.0.1:5000/v2/_catalogcurl -X GET http://127.0.0.1:5000/v2/zfy-repo-local/tags/list]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Farticle%2F0%2F</url>
    <content type="text"><![CDATA[JavaScript 常用方法文件导出1234567891011121314function saveFile (content, fileName) &#123; const blob = new Blob([content]); if (window.navigator.msSaveOrOpenBlob) &#123; navigator.msSaveBlob(blob, fileName); &#125; else &#123; const elink = document.createElement('a'); elink.download = fileName; elink.style.display = 'none'; elink.href = URL.createObjectURL(blob); document.body.appendChild(elink); elink.click(); document.body.removeChild(elink); &#125;&#125;,]]></content>
  </entry>
  <entry>
    <title><![CDATA[Flutter开发-1-入门篇]]></title>
    <url>%2Farticle%2F1e731081%2F</url>
    <content type="text"><![CDATA[推荐阅读 在macOS上搭建Flutter开发环境 Q&amp;A 出现问题，iOS 模拟器和 Android 设备可以运行，但是 iOS 真机没有办法运行? 1234567brew updatebrew uninstall --ignore-dependencies libimobiledevicebrew uninstall --ignore-dependencies usbmuxdbrew install --HEAD usbmuxdbrew unlink usbmuxdbrew link usbmuxdbrew install --HEAD libimobiledevice]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apt 开发语法]]></title>
    <url>%2Farticle%2Faf68580c%2F</url>
    <content type="text"><![CDATA[APT 语法 public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) Element 表示元素 TypeElement 类 VariableElement 成员 从成员变量中获取类型, 转变为参数类型 123TypeName typeName = TypeName.get(variableElement.asType());builder.addParameter(typeName, "name"); 获取包名，用于在同包下生成代码 1processingEnv.getElementUtils().getPackageOf(typeElement).getQualifiedName().toString();]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次使用 Gradle 插件重构项目的经历]]></title>
    <url>%2Farticle%2F882f967a%2F</url>
    <content type="text"><![CDATA[背景先打个广告，在维护的一个三方登录分享的项目(求 🌟)，以更简单、更轻量、更加面向业务需求为设计目标，提供 微博、微信、QQ、Tim、QQ 轻聊版、钉钉 的登陆分享功能支持； 刚开始的时候，所有代码实现都写在一个 module 里面，虽然按照平台在代码结构上进行分离了，但是如果遇到只需要其中几个平台的情况使用起来非常不灵活，所以就萌生了写一个 gradle 插件来统一管理几个平台的实现和依赖的想法。 最后开发完成以后发现和 ShareSdk 有点像（就接入方式而言），可能这是公认的一个比较好的实现方式，所以类似需要动态的接入不同的依赖、并且配置项比较繁多的业务场景，是非常适合用插件来管理和配置的，本文主要记录使用 gradle 插件该项目的重构过程。 项目地址 : GitHub - SocialSdkLibrary 博客地址 ：快速接入微信微博QQ钉钉原生登录分享 基本设计因为本文主要是针对 Gradle 插件开发来整理的，所以在此之前我已经将原来的项目进行了拆分，划分为了核心库、微信平台库、QQ 平台库、微博平台库、钉钉平台库 5 个部分，并将他们发布到了 Bintray 获得依赖坐标。 12345implementation "com.zfy:social-sdk-core:0.0.7"implementation "com.zfy:social-sdk-wx:0.0.7"implementation "com.zfy:social-sdk-dd:0.0.7"implementation "com.zfy:social-sdk-qq:0.0.7"implementation "com.zfy:social-sdk-weibo:0.0.7" 整个 gradle 插件的开发过程大致分为了如下几步： 创建插件项目 - 搭建 HelloWorld 项目，并在本地完成编译依赖； 自定义参数的配置和解析 - 在插件中解析 gradle 文件中配置的参数； 动态生成 java 配置文件 - 根据配置的参数动态生成 SocialSdkConifg.java 文件；==~~== 动态增加依赖 - 根据参数动态为项目添加不同的依赖，取决于需要哪个平台； 动态更改 Android 配置- 操作主项目的 manifestPlaceholders，增加 qq_id 字段。 将插件发布到本地目录，并依赖到项目中； 将插件发布到 bintray，并依赖到项目中；]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「开源」SocialSdk]]></title>
    <url>%2Farticle%2F3067853428%2F</url>
    <content type="text"><![CDATA[最新版本(0.0.7) Easier 、Lighter 、 More Business-Oriented 以更简单、更轻量、更加面向业务需求为设计目标，提供 微博、微信、QQ、Tim、QQ 轻聊版、钉钉 的登陆分享功能支持； 项目地址 : GitHub - SocialSdkLibrary 博客地址 ：快速接入微信微博QQ钉钉原生登录分享 🎉 2018.12.27 完成 gradle 插件，拆分平台，自动化依赖，一个新台阶 🐶 🎉 2018.12.21 已经225颗 🌟，着手准备拆分成不同平台库，方便灵活接入 ⛽️ 🎉 2018.9.26 项目获得了第202颗 🌟，感谢新同事补星 2 个 😄 🎉 2018.6.7 项目获得了第100颗 🌟，最后一颗是我问同事要的 🤦‍ 🎉 2018.5.12 修复内存问题、功能扩展 稳定版本 1.1.0 ❤️ 🎉 2018.2.12 支持钉钉分享 🆕 🎉 2017.12.12 对代码进行简单重构并测试 稳定版本 1.0.0 ❤️ 优势🔥 开源：没有彩蛋，没有彩蛋，没有彩蛋； 🔥 简单：只需要关注登录、分享管理类和一个数据结构对象即可，不需要再关注平台之间的差异； 🔥 轻量：仅包含三方 SDK 和一个简单的异步框架(38k)，网络请求、JSON 解析从外部注入，减少多余的依赖，保证与宿主项目高度统一； 🔥 面向需求设计： 良好的扩展性，容易增加新平台实现，例如华为联运登录接入等； 一致的外观，封装各平台内部实现，对外暴露统一的接口，若不支持，使用 web 分享兼容； 无法支持的数据类型，使用 Intent 唤醒分享，如支持本地视频分享，qq 的纯文字分享等等； 支持直接使用网络图片分享，内置自动下载和图片缓存功能； 图片 下载/加载 失败时降级使用资源图，避免分享被中断； 在分享前可统一重写数据对象，用来做分享的切面，支持图片加水印等类似需求； 支持短信、邮件、粘贴板等系统分享平台； 持久化存储 token 避免多次授权，可选择有效时长； 针对选择留在三方应用的业务场景，可将其回调为成功或失败。 开始接入STEP1: 添加插件依赖路径 project / build.gradle 123456789101112131415buildscript &#123; repositories &#123; maven &#123; url "https://dl.bintray.com/zfy/maven" &#125; &#125; dependencies &#123; // 请查看文初最新版本，这边可能忘记更新！！！ classpath 'com.zfy.social:social-sdk-plugin:0.0.7' &#125;&#125;allprojects &#123; repositories &#123; maven &#123; url "https://dl.bintray.com/zfy/maven" &#125; &#125;&#125; STEP2: 配置参数，注意与 android 同级 app / build.gralde 12345678910111213141516171819202122232425262728// 引用插件apply plugin: 'socialsdk'// android 配置模块android &#123; ...&#125;// socialsdk 配置模块socialsdk &#123; wx &#123; appId = 'wx4b8db***5b195c3' appSecret = '0a3cb007291d0e5***3654f499171' onlyAuthCode = false // 微信授权仅返回 code &#125; qq &#123; appId = '1104***200' appSecret = 'A6AqtY***g59yQ4N' &#125; wb &#123; appId = '218***998' url = 'http://open.manfenmm.com/***/***' &#125; dd &#123; appId = 'dingo***wrefwjeumuof' &#125; local false // 使用本地依赖&#125; STEP3：初始化 1234567891011121314151617SocialOptions options = new SocialOptions.Builder(this) // 调试模式，开启 log 输出 .debug(true) // 加载缩略图失败时，降级使用资源图 .failImgRes(R.mipmap.ic_launcher_new) // token 保留时间，单位小时，默认不保留 .tokenExpiresHours(24) // 分享如果停留在第三放将会返回成功，默认返回失败 .shareSuccessIfStay(true) // 微博 loading 窗颜色 .wbProgressColor(Color.YELLOW) // 添加自定义的 json 解析 .jsonAdapter(new GsonJsonAdapter()) // 请求处理类，如果使用了微博的 openApi 分享，这个是必须的 .requestAdapter(new OkHttpRequestAdapter()) // 构建 .build(); 说一下 Adapter，项目内使用了 JSON 解析，网络请求等功能，但是又不想引入多余的框架，所以才用了宿主项目注入的方式，保证和宿主项目统一。 IJsonAdapter，必须 ！负责完成 Json 解析和序列化，提供一个 Gson 下的实现仅供参考 - GsonJsonAdapter.java； IRequestAdapter，非必须！内部使用 UrlConnection 做了一个默认的实现，负责完成网络请求，也可以使用 OkHttp 重新实现，可以参考 - OkHttpRequestAdapter.java，目前微信的 OAuth2 授权和图片下载的相关请求都是使用 IRequestAdapter 代理； 登录功能登陆功能支持三个平台，qq，微信，微博； 1234// 3个平台Target.LOGIN_QQ;Target.LOGIN_WX;Target.LOGIN_WB; 登录将会返回 LoginResult， 其中主要包括登录类型，基本用户信息，令牌信息 3 部分； 1234567891011public class LoginResult &#123; // 登陆的类型，对应 Target.LOGIN_QQ 等。。。 private int target; // 返回的基本用户信息 // 针对登录类型可强转为 WbUser,WxUser,QQUser 来获取更加丰富的信息 private SocialUser socialUser; // 本次登陆的 token 信息，openId, unionId,token,expires_in private AccessToken accessToken; // 授权码，如果 onlyAuthCode 为 true, 将会返回它 private String wxAuthCode;&#125; 登录时需要设置登录回调： 12345678910111213141516171819OnLoginListener listener = new OnLoginListener() &#123; @Override public void onStart() &#123; // 当登录开始时触发 &#125; @Override public void onSuccess(LoginResult result) &#123; // 登录成功，获取用户信息 SocialUser socialUser = result.getSocialUser(); &#125; @Override public void onCancel() &#123; // 登录取消 &#125; @Override public void onFailure(SocialError e) &#123; // 登录失败 &#125;&#125;; 获取更多用户信息： 12345678910111213141516171819202122SocialUser socialUser = loginResult.getSocialUser();// 基本信息可以从 SocialUser 在获取到String userNickName = socialUser.getUserNickName();// 获取 openIdString openId = socialUser.getOpenId();// 微信获取 unionId，其他平台仍旧返回 openIdString unionId = socialUser.getUnionId();// 获取 userId，微信返回 unionId, 其他平台返回 openIdString userId = socialUser.getUserId();// 强转为平台用户，可以拿到更多信息int target = result.getTarget();switch (target) &#123; case Target.LOGIN_QQ: QQUser qqUser = (QQUser) socialUser; break; case Target.LOGIN_WB: WbUser wbUser = (WbUser) socialUser; break; case Target.LOGIN_WX: WxUser wxUser = (WxUser) socialUser; break;&#125; 发起登录： 1LoginManager.login(mActivity, Target.LOGIN_QQ, listener); 关于 token 时效，可以在初始化时设置 tokenExpiresHours 来控制，也同样提供清除授权 token 的方法。 1234// 清除全部平台的 tokenLoginManager.clearAllToken(context);// 清除指定平台的 tokenLoginManager.clearToken(context, Target.LOGIN_QQ); 分享功能重要：请仔细查看平台和数据类型中间的支持能力 当 微博 使用 openApi 形式去分享时，可能有较长的延时，建议在生命周期中增加进度条显示，避免用户等待很久没有响应。 划分分享数据类型针对业务逻辑和 SDK 设计，将分享数据类型划分为 7 种类型，他们能涵盖大多数业务场景，分别是： 1234567开启 App 类型，打开渠道应用；文字类型，纯文本分享；图片类型(jpg, png, gif(要求能动))；App 推广类型；网页链接类型；音频分享类型；视频分享类型； 为了保证每个平台都有封闭且统一的外观，如果某个平台不兼容某种类型的分享，将会使用 web 分享的方式代替；比如微信不支持 app 分享，分享出去之后时 web 分享的模式。 划分分享渠道1234567891011// 支持的分享渠道Target.SHARE_DD; // 钉钉好友Target.SHARE_QQ_FRIENDS; // qq好友Target.SHARE_QQ_ZONE; // qq空间Target.SHARE_WX_FRIENDS; // 微信好友Target.SHARE_WX_ZONE; // 微信朋友圈Target.SHARE_WX_FAVORITE; // 微信收藏Target.SHARE_WB; // 新浪微博Target.SHARE_SMS; // 短信分享Target.SHARE_EMAIL; // 邮件分享Target.SHARE_CLIPBOARD; // 粘贴板分享 创建分享数据分享时，我们首先要构造分享用的数据，ShareObj 对象提供了多种静态方法用来快速创建对应分享的类型的对象; 1234567891011121314151617181920212223242526272829// 测试用的路径localImagePath = new File(Environment.getExternalStorageDirectory(), "1.jpg").getAbsolutePath();localVideoPath = new File(Environment.getExternalStorageDirectory(), "video.mp4").getAbsolutePath();localGifPath = new File(Environment.getExternalStorageDirectory(), "3.gif").getAbsolutePath();netVideoPath = "http://7xtjec.com1.z0.glb.clouddn.com/export.mp4";netImagePath = "http://7xtjec.com1.z0.glb.clouddn.com/token.png";netMusicPath = "http://7xtjec.com1.z0.glb.clouddn.com/test_music.mp3";netMusicPath = "http://mp3.haoduoge.com/test/2017-05-19/1495207225.mp3";targetUrl = "http://bbs.csdn.net/topics/391545021";// 打开渠道对应appShareObj shareMediaObj = ShareObj.buildOpenAppObj();// 分享文字ShareObj textObj = ShareObj.buildTextObj("分享文字", "summary");// 分享图片ShareObj imageObj = ShareObj.buildImageObj("分享图片", "summary", localImagePath);// 分享gifShareObj imageGifObj = ShareObj.buildImageObj("分享图片", "summary", localGifPath);// 分享appShareObj appObj = ShareObj.buildAppObj("分享app", "summary", localImagePath, targetUrl);// 分享webShareObj webObj = ShareObj.buildWebObj("分享web", "summary", localImagePath, targetUrl);// 分享视频ShareObj videoObj = ShareObj.buildVideoObj("分享视频", "summary", localImagePath, targetUrl, localVideoPath, 10);// 本地视频分享、部分平台支持ShareObj videoLocalObj = ShareObj.buildVideoObj("分享本地视频", "summary", localImagePath, targetUrl, localVideoPath, 0);// 分享音乐ShareObj musicObj = ShareObj.buildMusicObj("分享音乐", "summary", localImagePath, targetUrl, netMusicPath, 10); 针对一些不能被统一的参数使用扩展的参数支持： 12345678// 使 ShareObj 支持短信分享webObj.setSmsParams("13611301719", "说啥呢");// 使 ShareObj 支持粘贴板分享webObj.setClipboardParams("复制的内容");// 使 ShareObj 支持邮件分享webObj.setEMailParams("1101873740@qq.com", "主题", "内容");// 使 ShareObj 在微信平台优先使用小程序分享webObj.setWxMiniParams("51299u9**q31",SocialValues.WX_MINI_TYPE_RELEASE,"/page/path"); 分享监听使用 OnShareListener 作为监听分享回调； 1234567891011121314151617181920212223OnShareListener listener = new OnShareListener() &#123; @Override public void onStart(int shareTarget, ShareObj obj) &#123; // 分享开始 &#125; @Override public ShareObj onPrepareInBackground(int shareTarget, ShareObj obj) throws Except // 重写分享对象，例如给分享出去的图片加水印等 return null; &#125; @Override public void onSuccess(int target) &#123; // 分享成功 &#125; @Override public void onFailure(SocialError e) &#123; // 分享失败 &#125; @Override public void onCancel() &#123; // 分享被取消 &#125;&#125;; 发起分享12// 唤醒分享ShareManager.share(mActivity, Target.SHARE_QQ_FRIENDS, imageObj, mOnShareListener); 重写分享对象关于重写分享对象，其实提供一种能在分享之前对需要分享的 ShareObj 进行统一处理的机会，类似分享功能的一个切面，比如可以用来解决网络图片无法分享，我们需要将它下载到本地，在进行分享，又比如图片分享出去之前加上 app 水印等操作。 主要是重写 OnShareListener 的 onPrepareInBackground 方法，这个方法会在分享之前首先执行，如果返回不是 null，将会使用新创建的 ShareObj 进行分享，另外由于考虑到可能进行耗时操作，这个方法是在子线程执行的。 123456@Overridepublic ShareObj onPrepareInBackground(int shareTarget,ShareObj obj) &#123; // 重构分享对象，不需要时返回 null 即可 obj.setTitle(obj.getTitle() + "/哈哈哈"); return obj;&#125; 错误码为了更好的统一分享失败时返回的异常，返回的所有异常都会有一个 code，可以根据不同的 code 定位问题和给出更友好的提示。 12345678910111213141516int CODE_COMMON_ERROR = 101; // 通用错误，未归类int CODE_NOT_INSTALL = 102; // 没有安装应用int CODE_VERSION_LOW = 103; // 版本过低，不支持int CODE_SHARE_BY_INTENT_FAIL = 105; // 使用 Intent 分享失败int CODE_STORAGE_READ_ERROR = 106; // 没有读存储的权限，获取分享缩略图将会失败int CODE_STORAGE_WRITE_ERROR = 107; // 没有写存储的权限，微博分享视频copy操作将会失败int CODE_FILE_NOT_FOUND = 108; // 文件不存在int CODE_SDK_ERROR = 109; // sdk 返回错误int CODE_REQUEST_ERROR = 110; // 网络请求发生错误int CODE_CANNOT_OPEN_ERROR = 111; // 无法启动 appint CODE_PARSE_ERROR = 112; // 数据解析错误int CODE_IMAGE_COMPRESS_ERROR = 113; // 图片压缩失败int CODE_PARAM_ERROR = 114; // 参数错误int CODE_SDK_INIT_ERROR = 115; // SocialSdk 初始化错误int CODE_PREPARE_BG_ERROR = 116; // 执行 prepareOnBackground 时错误int CODE_NOT_SUPPORT = 117; // 不支持 例如你可以这么做： 1234567891011121314listener = new OnShareListener() &#123; ... @Override public void onFailure(SocialError e) &#123; showMsg("分享失败 " + e.toString()); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; if (e.getCode() == SocialError.CODE_STORAGE_READ_ERROR) &#123; requestPermissions(new String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;, 100); &#125; else if (e.getCode() == SocialError.CODE_STORAGE_WRITE_ERROR) &#123; requestPermissions(new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 100); &#125; &#125; &#125;&#125;; 扩展新的平台？参考这里 HuaweiPlatform.java 向 SocialSdk 注册构建工厂： 1SocialSdk.addPlatform(new HuaweiPlatform.Factory());]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「View」ProgressBar]]></title>
    <url>%2Farticle%2Fedb40764%2F</url>
    <content type="text"><![CDATA[ProgressBar 是比较常见的用来显示进度的的控件，支持圆形和水平进度显示，通过扩展它可以实现大多数情况下的需求，不需要自己自定义控件，特此记录一下，本文主要介绍： 圆形、无进度、自定义颜色； 水平、带进度、自定义背景/进度颜色； 圆形、带进度、自定义背景/进度颜色； 知识准备用到了几个不常用的 shape 属性，当我们使用 ring 类型时： 12345android:innerRadius 尺寸，内环的半径，单位 dp。android:innerRadiusRatio 大于1浮点型，以环的宽度比率来表示内环的半径。android:thickness 尺寸，环的厚度android:thicknessRatio 大于1浮点型，以环的宽度比率来表示环的厚度 android:useLevel boolean 值，如果当做是LevelListDrawable使用时值为true，否则为false. 举个例子，假设我们有个 ProgressBar 宽度和高度都是 100dp，想给他一个宽度为 2dp 的环形进度，那么： 123456789101112131415先设置环半径如果使用 innerRadius，因为宽度是 100dp，去掉两边 2dp 的环，还有 96dp，半径为 96/2 = 48dp android:innerRadius=&quot;48dp&quot;如果使用 innerRadiusRatio，半径为 48dp 比例就应该是 100/48 = 2.08 android:innerRadiusRatio=&quot;2.08&quot; 再设置环的宽度如果使用 thickness，很简单，他应该是 2dp android:thickness=&quot;2dp&quot;如果使用 thicknessRatio，那么就应该是 105/2 = 50 android:thicknessRatio=&quot;50&quot; 使用 Ratio 时，填写是一个大于 0 的比例数字。 圆形、无进度、自定义颜色圆形 ProgressBar 无进度，并自带了旋转效果，那怎么更改圆形进度的颜色，下面使用了一个渐变色作为进度条颜色，同样也可以使用更简单的纯色表示。 progress_circle.xml 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;rotate xmlns:android="http://schemas.android.com/apk/res/android" android:fromDegrees="0" android:pivotX="50%" android:pivotY="50%" android:toDegrees="360"&gt; &lt;shape android:innerRadius="48dp" android:shape="ring" android:thickness="2dp" android:useLevel="false"&gt; &lt;gradient android:centerX="0.5" android:centerY="0.5" android:endColor="#FF696969" android:startColor="#FFFFFFFF" android:type="sweep" /&gt; &lt;/shape&gt;&lt;/rotate&gt; 在 xml 中使用它： 1234&lt;ProgressBar android:layout_width="100dp" android:layout_height="100dp" android:indeterminateDrawable="@drawable/progress_circle" /&gt; 效果展示： 水平、带进度、自定义背景/进度颜色水平进度条，可以设置背景、一级进度、二级进度的颜色，需要借助 layer-list 来实现； progress_horizontal.xml 12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;!--背景颜色--&gt; &lt;item android:id="@android:id/background"&gt; &lt;shape&gt; &lt;solid android:color="@color/color999" /&gt; &lt;size android:height="1dp" /&gt; &lt;corners android:radius="10dp" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;!--二级进度颜色--&gt; &lt;item android:id="@android:id/secondaryProgress"&gt; &lt;clip&gt; &lt;shape&gt; &lt;solid android:color="@color/redPrimary" /&gt; &lt;size android:height="1dp" /&gt; &lt;corners android:radius="10dp" /&gt; &lt;/shape&gt; &lt;/clip&gt; &lt;/item&gt; &lt;!--一级进度颜色--&gt; &lt;item android:id="@android:id/progress"&gt; &lt;clip&gt; &lt;shape&gt; &lt;solid android:color="@color/colorPrimary" /&gt; &lt;size android:height="1dp" /&gt; &lt;corners android:radius="10dp" /&gt; &lt;/shape&gt; &lt;/clip&gt; &lt;/item&gt;&lt;/layer-list&gt; 在 xml 文件中使用它： 12345678&lt;ProgressBar style="?android:attr/progressBarStyleHorizontal" android:layout_width="100dp" android:layout_height="5dp" android:progressDrawable="@drawable/progress_horizontal" android:max="100" android:progress="30" android:secondaryProgress="60" /&gt; 效果展示： 圆形、带进度、自定义背景/进度颜色首先定义进度颜色的的 xml 文件 progress_circle.xml 1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;rotate xmlns:android="http://schemas.android.com/apk/res/android" android:fromDegrees="270" android:toDegrees="270"&gt; &lt;shape android:innerRadius="48dp" android:thickness="2dp" android:shape="ring" android:useLevel="true"&gt; &lt;solid android:color="@color/colorPrimary" /&gt; &lt;corners android:radius="10dp"/&gt; &lt;/shape&gt;&lt;/rotate&gt; 仅仅这样没有背景效果，我们单独做一个背景 progress_bg.xml 1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:innerRadius="48dp" android:shape="oval" android:thickness="2dp" android:useLevel="true"&gt; &lt;stroke android:width="2dp" android:color="@color/color999" /&gt;&lt;/shape&gt; 在 xml 中使用它： 12345678&lt;ProgressBar style="?android:attr/progressBarStyleHorizontal" android:layout_width="100dp" android:layout_height="100dp" android:background="@drawable/progress_bg" android:max="100" android:progress="60" android:progressDrawable="@drawable/progress_horizontal" /&gt; 效果展示： 圆形、带进度、自定义背景/进度颜色2使用上面的方法比较好理解，但是写起来麻烦，需要写两个 xml 文件，而且不支持二级进度，我们理解了他的工作原理，可以使用 layer-list 来组合改写它； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;!--背景颜色,一个简单的 shape--&gt; &lt;item android:id="@android:id/background"&gt; &lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:innerRadius="48dp" android:shape="oval" android:thickness="2dp" android:useLevel="true"&gt; &lt;stroke android:width="2dp" android:color="@color/color999" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;!--二级进度颜色--&gt; &lt;item android:id="@android:id/secondaryProgress"&gt; &lt;rotate xmlns:android="http://schemas.android.com/apk/res/android" android:fromDegrees="270" android:toDegrees="270"&gt; &lt;shape android:innerRadius="48dp" android:thickness="2dp" android:shape="ring" android:useLevel="true"&gt; &lt;solid android:color="@color/redPrimary" /&gt; &lt;corners android:radius="10dp"/&gt; &lt;/shape&gt; &lt;/rotate&gt; &lt;/item&gt; &lt;!--一级进度颜色--&gt; &lt;item android:id="@android:id/progress"&gt; &lt;rotate xmlns:android="http://schemas.android.com/apk/res/android" android:fromDegrees="270" android:toDegrees="270"&gt; &lt;shape android:innerRadius="48dp" android:thickness="2dp" android:shape="ring" android:useLevel="true"&gt; &lt;solid android:color="@color/colorPrimary" /&gt; &lt;corners android:radius="10dp"/&gt; &lt;/shape&gt; &lt;/rotate&gt; &lt;/item&gt;&lt;/layer-list&gt; 在 xml 中使用它： 12345678&lt;ProgressBar style="?android:attr/progressBarStyleHorizontal" android:layout_width="100dp" android:layout_height="100dp" android:max="100" android:progress="30" android:progressDrawable="@drawable/progress_horizontal" android:secondaryProgress="60"/&gt; 效果展示：]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「前端&微信」微信前端开发指坑]]></title>
    <url>%2Farticle%2F16bbea2c%2F</url>
    <content type="text"><![CDATA[本文主要解决微信前端开发中遇到的奇葩问题和解决方案； iOS 键盘问题被顶起 键盘将页面顶起来，但是无法收回的问题。 123onBlur() &#123; window.scroll(0, 0);&#125; 微信页面设置标题不生效网上有添加一个 iframe 的方案； 一样的原理在 vue 下写好的库，vue-wechat-title； 12345678910111213141516document.setTitle = function(t) &#123; document.title = t; var i = document.createElement('iframe'); i.src = '//m.baidu.com/favicon.ico'; i.style.display = 'none'; i.onload = function() &#123; setTimeout(function()&#123; i.remove(); &#125;, 9) &#125; document.body.appendChild(i);&#125; setTimeout(function()&#123; document.setTitle('hello')&#125;, 1000) 不过我发现，我遇到的不是这个问题，我的问题是类似是设置了标题又被刷没了，所以设置标题时延时一下就好了[滑稽]； 123setTimeout(() =&gt; &#123; window.document.title = '标题';&#125;, 500); 微信长按复制默认不允许长按复制文本，使用下面的属性支持。 1234.copy-contnet &#123; -webkit-user-select: text; user-select: text;&#125; 长按保存图片canvas 转 base64 图片无法长按保存，使用下面的属性支持； 1234.press-img &#123; -webkit-touch-callout: none; user-select: none;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试准备]]></title>
    <url>%2Farticle%2Fc5576490%2F</url>
    <content type="text"><![CDATA[面试 源码： HashMap / ConcurrentHashMap ThreadLocal Handler Intent/Bundle AsyncTask ActivityThread HandlerThread 技能： 并发、锁、同步 JVM 结构 GC 原理 Android： 事件传递机制，MotionEvent View 绘制流程，measure/layout/draw 进程间通信 生命周期，activity/fragment/ 屏幕旋转 算法： 正负数数组，顺序不变，左右分治。{-1,2,-3,4,-5,6} =&gt; {-1,-3,-5,2,4,6} 框架： 图片加载框架 UIL/Picasso/Fresco/Glide EventBus ButterKnife Retrofit OkHttp RxJava 问题： 主线程中的 Looper.loop()一直无限循环为什么不会造成ANR？ App 启动流程分析]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView Adapter [开源]]]></title>
    <url>%2Farticle%2F1632666977%2F</url>
    <content type="text"><![CDATA[LxAdapterLxAdapter 轻量 、 面向业务 为主要目的，一方面希望可以快速、简单的的完成数据的适配工作，另一方面针对业务中经常出现的场景能提供统一、简单的解决方案。 LxAdapter 是我做通用适配器的第三次重构版本，尝试了很多种方案，这次摒弃了很多复杂的东西，回归简单，希望会越来越好； GitHub - LxAdapter com.zfy:lxadapter:2.0.11 LxDragSwipeComponent LxSnapComponent LxPicker LxSpaceComponent LxSelectComponent 拖拽，侧滑 SnapHelper效果 滚轮选择器 多类型等距间隔 选择器效果 LxAnimComponent LxExpandable LxFixedComponent LxLoadMoreComponent LxNesting 动画 分组 悬停 加载更多 垂直嵌套水平滑动，记录位置 目录 联系我 特性 设计分析 内置的数据类型 TypeOpts ～ 配置化类型 LxModel ～ 数据包装 LxContext ～ 上下文对象 基础 基础：LxGlobal ～ 全局配置 基础：LxAdapter ～ 适配器 基础：数据源 ～ 适配器的数据来源 基础：LxQuery～ 针对类型的数据更新 基础：LxItemBind ～ 类型绑定 基础：LxList ～ 数据源，自动更新，告别 notify 基础：LxViewHolder ～ 扩展 ViewHolder 基础：点击事件 ～ 单击、双击、长按、焦点 基础：扩展自定义类型 ～ 灵活扩展 功能 功能：事件发布 ～ 将数据更新抽象成事件 功能：跨越多列（Span）～ 灵活布局 功能：间隔（Space）～ 多类型布局等距间隔 功能：加载更多（LoadMore）～ 赋能分页加载 功能：选择器（Selector）～ 面向选择器业务场景 功能：列表动画（Animator） 功能：悬挂效果（Fixed） 功能：拖拽和侧滑（Drag/Swipe） 功能：实现 ViewPager (Snap) 功能：实现分组列表 (Expandable) ～ 按组划分，展开收起 功能：实现 RecyclerView 嵌套 (Nesting) ～ 嵌套滑动，恢复滑动位置 功能：实现滚轮选择器效果 (Picker) ～ 多级级联滚动，数据异步获取 进阶 进阶：使用缓存优化绑定性能 进阶：使用 Extra 扩展数据 进阶：使用条件更新 进阶：使用 Idable 优化 change 进阶：使用 Typeable 内置类型 进阶：使用有效载荷（payloads）更新 特性 使用 LxAdapter 构建单类型、多类型数据适配器； 使用 LxItemBinder 完成每种类型的数据绑定和事件处理，支持自定义类型，可灵活扩展实现 Header/Footer/Loading/Empty 等场景效果，支持单击事件、双击事件、长按事件；； 使用 LxViewHolder 作为 ViewHolder 进行数据绑定； 使用 LxList 作为数据源，基于 DiffUtil 并自动完成数据比对和更新； 使用 LxSource 和 LxQuery 搭配 LxList，简化数据列表增删改查； 使用 LxComponent 完成分离、易于扩展的扩展功能，如果加载更多等； 使用 TypeOpts 针对每种数据类型，进行细粒度的配置侧滑、拖拽、顶部悬停、跨越多列、动画等效果； 使用 LxSpaceComponent 实现多类型数据等距间隔； 使用 LxLoadMoreComponent 支持列表顶部、列表底部，预加载更多数据； 使用 LxSelectorComponent 支持快速实现选择器效果，单选、多选、滑动选中等。 使用 LxFixedComponent 实现顶部悬停效果； 使用 LxDragSwipeComponent 实现拖拽排序，侧滑删除效果； 使用 LxAnimatorComponent 支持 ItemAnimator / BindAnimator 两种方式实现添加布局动画。 使用 LxSnapComponent 支持借助 SnapHelper 快速实现 ViewPager 效果； 使用 LxExpandable 快速实现分组列表； 使用 LxNesting 快速实现 RecyclerView 的嵌套滑动，返回时自动复位； 使用 LxPicker 快速实现滚轮选择器效果； 使用 LxCache 实现缓存，优化绑定耗时问题； 支持自动检测数据更新的线程，避免出现在子线程更新数据的情况； 支持发布订阅模式的事件抽离，更容易分离公共逻辑； 支持使用 payloads 实现有效更新； 支持使用 condition 实现条件更新，按照指定条件更新数据，拒绝无脑刷新； 设计分析 数据源统一使用 LxList，内部借助 DiffUtil 实现数据的自动更新，当需要更改数据时，只需要使用它的内部方法即可； 每种类型是完全分离的，LxAdapter 作为一个适配器的容器，实际上使用 LxItemBinder 来描述如何对该类型进行数据的绑定，事件的响应，以此来保证每种类型数据绑定的可复用性，以及类型之间的独立性； 拖拽、侧滑、Snap 使用、动画、选择器、加载更多，这些功能都分离出来，每个功能由单独的 component 负责，这样职责更加分离，需要时注入指定的 component 即可，也保证了良好的扩展性； 将类型分为了 内容类型 和 扩展类型 两种，内容类型一般指的是业务数据类型，扩展类型一般是其他的类型，比如 Header/Footer 这种，需要注意的是每种类型、内容类型都需要是连续的。 区块的概念，整个列表被分为多个区块，可以按照区块去更新数据，这样在多种类型的列表中可以灵活的更新某种类型的数据，注意，内容类型归属于一个区块，成为内容区块，扩展类型，每种类型属于一个区块，区块里面的数据必须是连续的； 内置的数据类型 TypeOpts他用来标记一种类型及其附加的相关属性，具体可以看下面的注释说明； 1234567891011121314151617public class TypeOpts &#123; public int viewType = Lx.ViewType.DEFAULT; // 数据类型 @LayoutRes public int layoutId; // 布局资源 public int spanSize = Lx.SpanSize.NONE; // 跨越行数 public boolean enableClick = true; // 是否允许点击事件 public boolean enableLongPress = false; // 是否允许长按事件 public boolean enableDbClick = false; // 是否允许双击事件 public boolean enableFocusChange = false; // 是否焦点变化事件 public boolean enableDrag = false; // 是否允许拖动 public boolean enableSwipe = false; // 是否允许滑动 public boolean enableFixed = false; // 钉住，支持悬停效果 public BindAnimator bindAnimator; // 每种类型可以支持不同的动画效果&#125; LxModelLxAdapter 的数据类型是 LxModel，业务类型需要被包装成 LxModel 才能被 LxAdapter 使用，获取其中真正的业务数据可以使用 model.unpack() 方法； 123456789101112131415161718public class LxModel implements Diffable&lt;LxModel&gt;, Typeable, Selectable, Idable, Copyable&lt;LxModel&gt; &#123; private int incrementId; // 自增ID private Object data; // 内置数据 private int type = Lx.ViewType.DEFAULT; // 类型 private int moduleId; // 模块ID private boolean selected; // 选中 private Bundle extra; // 数据扩展 @NonNull public Bundle getExtra() &#123; if (extra == null) &#123; extra = new Bundle(); &#125; return extra; &#125;&#125; LxContextLxContext 是数据绑定过程中的上下文对象，承载了一些附加的数据，易于扩展； 123456789101112public class LxContext &#123; public int layoutPosition; // 布局中的位置 public int dataPosition; // 数据位置 public int viewType; // 类型 public int bindMode; // 绑定类型 @NonNull public List&lt;String&gt; payloads; // payloads 更新数据 public String conditionKey; // 条件更新的 key @NonNull public Bundle conditionValue; // 条件更新的数据&#125; 基础：LxGlobal设置图片加载全局控制： 123LxGlobal.setImgUrlLoader((view, url, extra) -&gt; &#123; Glide.with(view).load(url).into(view);&#125;); 设置全局事件处理，这部份详细的会在下面 事件发布 一节说明： 12345public static final String CLEAR_ALL_DATA = "CLEAR_ALL_DATA";LxGlobal.subscribe(CLEAR_ALL_DATA, (event, adapter, extra) -&gt; &#123; adapter.getData().updateClear();&#125;); 基础：LxAdapter一般适配器的使用会有单类型和多类型的区分，不过单类型也是多类型的一种，数据的绑定使用 LxItemBinder 来做，所以 LxAdapter 就只作为一个容器， 不再考虑单类型和多类型的问题； 123456789101112131415// 构造数据源LxList list = new LxTypedList();// Builder 模式LxAdapter.of(list) // 这里指定了两个类型的数据绑定 .bindItem(new StudentItemBind(), new TeacherItemBind()) .attachTo(mRecyclerView, LxManager.grid(getContext(), 3));// 为 Adapter 更新数据List&lt;Student&gt; students = ListX.range(count, index -&gt; new Student());// 数据打包成 LxModel 类型LxSource source = LxSource.just(TYPE_STUDENT, students);// 发布更新list.update(source); 基础：数据源 数据类型分为两种，内容类型 和 扩展类型； 数据源被分为多个区块，内容类型同属于一个区块，扩展类型每种类型属于一个区块； 每个区块需要是连续的不能被分隔开； 如下用来理解，区块、类型之间的对应差别： 12345678910111213141516171819202122232425列表流开始------------------ A-HEADER 区块 开始- TYPE: A-HEADER- TYPE: A-HEADER------------------ A-HEADER 区块 结束------------------ B-HEADER 区块 开始- TYPE: B-HEADER- TYPE: B-HEADER------------------ B-HEADER 区块 结束------------------ 内容区块 开始- 学生（内容类型1）- 老师（内容类型2）- 时间隔断（内容类型3）- 学生（内容类型1）- 老师（内容类型2）------------------ 内容区块 结束------------------ FOOTER 区块 开始- TYPE: FOOTER- TYPE: FOOTER------------------ FOOTER 区块 结束------------------ LOADING 区块 开始- TYPE: LOADING- TYPE: LOADING------------------ LOADING 区块 结束列表流结束 当声明类型时，同时也决定了两件事情： 这个类型是内容类型还是扩展类型 类型在列表中相对的排列顺序 1234567891011121314// 内容类型1，属于内容区块public static final int TYPE_TEACHER = Lx.contentTypeOf();// 内容类型2，属于内容区块public static final int TYPE_STUDENT = Lx.contentTypeOf();// 扩展类型，属于单独的区块，这个类型位置在内容类型后面public static final int FOOTER = Lx.extTypeAfterContentOf();// 扩展类型，属于单独的区块，这个类型位置在内容类型后面// LOADING 在列表中的位置要比 FOOTER 更靠后// 声明的顺序决定了他们的排序public static final int LOADING = Lx.extTypeAfterContentOf();// 扩展类型，属于单独的区块，这个类型位置在内容类型前面public static final int HEADER = Lx.extTypeBeforeContentOf(); 如果只有一种类型，我们建议使用 LxList，如果是多类型的需要使用 LxTypedList，区别就在于在扩展类型的单独更新上； 1234567891011// 单类型建议使用 LxList// 可以直接发布更新，效率也相对更高LxList list = new LxList();// 多类型建议使用 LxTypedList// 数据的更新需要获取指定区块后才能发布更新LxList list = new LxTypedList();// 获取扩展类型的数据区块LxList l1 = list.getExtTypeData(HEADER);// 获取内容类型的数据区块LxList l2 = list.getContentTypeData(); 如何更新数据？ 12345LxList list = new LxTypedList();// 获取扩展类型的数据区块LxList l = list.getExtTypeData(HEADER);// 清空数据l.updateClear(); 基础：LxItemBinderLxAdapter 是完全面向类型的，每种类型的数据绑定会单独处理，这些由 LxItemBinder 负责，这样可以使所有类型绑定更容易复用： 123456789101112131415161718192021// 自增的数据类型，不需要自己去定义 1、2、3public static final int TYPE_STUDENT = Lx.contentTypeOf();// 实现类型绑定static class StudentItemBind extends LxItemBinder&lt;Student&gt; &#123; @Override protected TypeOpts newTypeOpts() &#123; return TypeOpts.make(TYPE_STUDENT, R.layout.item_squire1); &#125; @Override public void onBindView(LxContext context, LxViewHolder holder, Student data) &#123; &#125; @Override public void onBindEvent(LxContext context, Student listItem, int eventType) &#123; &#125;&#125; 也支持使用构建者模式快速创建新的类型绑定： 123456789TypeOpts opts = TypeOpts.make(R.layout.order_item);LxItemBinder&lt;PayMethod&gt; binder = LxItemBinder.of(PayMethod.class, opts) .onViewBind((itemBinder, context, holder, data) -&gt; &#123; &#125;) .onEventBind((itemBinder, context, data, eventType) -&gt; &#123; &#125;) .build(); 基础：LxListLxList 作为 LxAdapter 的数据来源，内部基于 DiffUtil 实现，辅助完成数据的自动比对和更新，彻底告别 notify 更新数据的方式，继承关系如下： 1AbstractList -&gt; DiffableList -&gt; LxList -&gt; LxTypedList 获取区块数据，可以对指定区块发布更新： 1234567LxList list = new LxTypedList();// 获取内容类型的数据LxList list1 = list.getContentTypeData();// 获取指定类型的数据LxList list2 = list.getExtTypeData(TYPE_HEADER); 以下是 LxList 内置 增删改查 方法，基本能满足开发需求，另外也可以使用 snapshot 获取快照，然后自定义扩展操作： 123456789// 内部使用 DiffUtil 实现，同步更新LxList list = new LxList();// 内部使用 DiffUtil + 异步 实现，避免阻塞主线程LxList list = new LxList(true);// 用来测试的数据List&lt;LxModel&gt; newList = new ArrayList&lt;&gt;();LxModel item = new LxModel(new Student("name")); 增： 12345678910// 添加元素list.updateAdd(item);list.updateAdd(0, item);// 在末尾添加list.updateAddLast(item);// 添加列表list.updateAddAll(newList);list.updateAddAll(0, newList); 删： 1234567891011121314151617181920212223242526// 清空列表list.updateClear();// 删除元素list.updateRemove(item);list.updateRemove(0);// 删除符合条件的元素list.updateRemove(model -&gt; model.getItemType() == TYPE_STUDENT);// 使用增强循环，删除符合条件的元素list.updateRemoveX(model -&gt; &#123; if (model.getItemType() == TYPE_STUDENT) &#123; return Lx.Loop.TRUE_BREAK; &#125; return Lx.Loop.FALSE_NOT_BREAK;&#125;);// 从末尾开始，删除符合条件的元素list.updateRemoveLast(model -&gt; model.getItemType() == TYPE_STUDENT);// 从末尾开始，使用增强循环，删除符合条件的元素list.updateRemoveLastX(model -&gt; &#123; if (model.getItemType() == TYPE_STUDENT) &#123; return Lx.Loop.TRUE_BREAK; &#125; return Lx.Loop.FALSE_NOT_BREAK;&#125;); 改： 12345678910111213141516171819202122232425262728293031323334353637383940// 使用索引更新某一项list.updateSet(0, data -&gt; &#123; Student stu = data.unpack(); stu.name = "new name";&#125;);// 指定更改某一项list.updateSet(model, data -&gt; &#123; Student stu = data.unpack(); stu.name = "new name";&#125;);// 遍历列表，找到符合规则的元素，并做更改操作list.updateSet(data -&gt; &#123; Student stu = data.unpack(); return stu.id &gt; 10;&#125;, data -&gt; &#123; Student stu = data.unpack(); stu.name = "new name";&#125;);// 遍历列表，无差别做更改操作list.updateSet(data -&gt; &#123; Student stu = data.unpack(); stu.name = "new name";&#125;);// 使用增强循环，更改指定的元素list.updateSetX(data -&gt; &#123; Student stu = data.unpack(); // id &gt; 10 就更改，发现一个后停止循环 if (stu.id &gt; 10) &#123; return Lx.Loop.TRUE_BREAK; &#125; // 其他情况，不更改，继续循环 return Lx.Loop.FALSE_NOT_BREAK;&#125;, data -&gt; &#123; Student stu = data.unpack(); stu.name = "new name";&#125;); 查： 1List&lt;Student&gt; students = list.find(data -&gt; data.getItemType() == TYPE_STUDENT, LxModel::unpack); 快照更新： 1234// 获取列表快照, 删除第一个元素, 发布更新List&lt;LxModel&gt; snapshot = list.snapshot();snapshot.remove(0);list.update(newList); 数据更新由于 LxList 列表是基于 LxModel 的，在实际使用过程中，会有些不方便，为了解决这个问题，引入 LxSource 和 LxQuery 来对数据做自动的包装和解包装： 1234// 初始化测试数据Student student = new Student("Job");List&lt;Student&gt; studentList = new ArrayList&lt;&gt;();studentList.add(student); 使用 LxSource 构建数据源: 1234567891011121314151617181920212223242526272829303132333435363738LxSource source = null;// 多种方式创建 LxSourcesource = LxSource.just(student);source = LxSource.just(TYPE_STUDENT, student);source = LxSource.just(studentList);source = LxSource.just(TYPE_STUDENT, studentList);source = LxSource.empty();source = LxSource.snapshot(list);// 添加一个source.add(student);// 添加一个，指定类型source.add(TYPE_STUDENT, student);// 添加一个，指定类型，并可以重写相关属性source.add(TYPE_STUDENT, student, model -&gt; model.setModuleId(100));// 指定下标，添加一个source.addOnIndex(10, student);// 指定下标，添加一个，指定类型source.addOnIndex(10, TYPE_STUDENT, student);// 指定下标，添加一个，并可以重写相关属性source.addOnIndex(10, TYPE_STUDENT, student, model -&gt; model.setModuleId(100));// 添加多个source.addAll(studentList);// 添加多个，指定类型source.addAll(TYPE_STUDENT, studentList);// 添加多个，指定类型，并可以重写相关属性source.addAll(TYPE_STUDENT, studentList, model -&gt; model.setModuleId(100));// 指定下标，添加多个source.addAllOnIndex(10, studentList);// 指定下标，添加多个，指定类型source.addAllOnIndex(10, TYPE_STUDENT, studentList);// 指定下标，添加多个，指定类型，并可以重写相关属性source.addAllOnIndex(10, TYPE_STUDENT, studentList, model -&gt; model.setModuleId(100));// 使用 source 更新数据list.update(source); 使用 LxQuery 更方便的完成数据的更新： 12// 数据更新辅助类LxQuery query = list.query(); 增: 12// 增加元素基于 LxSource 实现query.add(LxSource.just(student)); 删： 1234567891011// 按条件删除元素query.remove(Student.class, TYPE_STUDENT, stu -&gt; stu.id &gt; 10);// 删除类型为 TYPE_STUDENT 所有元素query.remove(TYPE_STUDENT);// 按条件删除，增强循环删除query.removeX(Student.class, stu -&gt; &#123; if (stu.id == 10) &#123; return Lx.Loop.TRUE_BREAK; &#125; return Lx.Loop.FALSE_NOT_BREAK;&#125;); 改： 1234567891011121314151617181920int index = 10;// 按条件更改元素query.set(Student.class, TYPE_STUDENT, stu -&gt; stu.id == 10, stu -&gt; stu.name = "NEW_NAME");// 更改指定下标的元素query.set(Student.class, TYPE_STUDENT, index, stu -&gt; stu.name = "NEW_NAME");// 更改指定类型的元素query.set(Student.class, TYPE_STUDENT, stu -&gt; &#123; stu.name = "NEW_NAME";&#125;);// 增强循环指定条件更新query.setX(Student.class, TYPE_STUDENT, stu -&gt; &#123; if (stu.id == 10) &#123; // 返回 true，停止循环 return Lx.Loop.TRUE_BREAK; &#125; return Lx.Loop.FALSE_NOT_BREAK;&#125;, data -&gt; data.name = "NEW_NAME"); 查： 12345678910// 按条件查找元素List&lt;Student&gt; students1 = query.find(Student.class, TYPE_STUDENT, stu -&gt; stu.id &gt; 10);// 按类型查找元素List&lt;Student&gt; students2 = query.find(Student.class, TYPE_STUDENT);// 按条件查找元素 一个Student one = query.findOne(Student.class, TYPE_STUDENT, stu -&gt; stu.id &gt; 10);// 使用 ID 查找，类需实现 Idable 接口返回 IDStudent oneById = query.findOneById(Student.class, 100); 基础：LxViewHolder为了支持同时对多个控件进行一样的绑定操作，可以使用 Ids 来包含多个 id: 12// 为多个 TextView 设置相同的文字holder.setText(Ids.all(R.id.test_tv, R.id.tv_count), "new text"); 使用 ID R.id.item_view 来标记 holder 的 itemView: 123holder.setClick(R.id.item_view, v -&gt; &#123;&#125;); 为了更优雅的绑定数据显示，扩展了 ViewHolder 的功能，现在支持如下绑定方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768holder // 设置 visibility .setVisibility(R.id.tv, View.VISIBLE) // 同时对多个控件设置 visibility .setVisibility(Ids.all(R.id.tv, R.id.tv_count), View.GONE) // 对多个控件设置某种显示状态 .setVisible(R.id.tv, R.id.tv_count) .setGone(R.id.tv, R.id.tv_count) .setInVisible(R.id.tv, R.id.tv_count) // 通过 bool 值切换两种显示状态 .setVisibleGone(R.id.test_tv, true) .setVisibleInVisible(R.id.test_tv, false) // 设置 select .setSelect(R.id.tv, true) .setSelectYes(R.id.tv_count, R.id.test_tv) .setSelectNo(R.id.tv_count, R.id.test_tv) // 设置 checked .setChecked(R.id.tv, true) .setCheckedNo(R.id.tv_count, R.id.test_tv) .setCheckedYes(R.id.tv_count, R.id.test_tv) // 设置背景 .setBgColor(R.id.test_tv, Color.RED) .setBgColorRes(R.id.test_tv, R.color.colorPrimary) .setBgDrawable(R.id.test_tv, new ColorDrawable(Color.RED)) .setBgRes(R.id.test_tv, R.drawable.wx_logo) // 设置文字颜色 .setTextColor(R.id.test_tv, Color.RED) .setTextColorRes(R.id.test_tv, R.color.colorPrimary) // 设置文字 .setText(R.id.test_tv, "test", true) .setTextRes(R.id.test_tv, R.string.app_name) // 设置图片 .setImage(R.id.test_tv, R.drawable.wx_logo) .setImage(R.id.test_tv, new ColorDrawable(Color.RED)) .setImage(R.id.test_tv, BitmapFactory.decodeFile("test")) .setImage(R.id.test_tv, "http://www.te.com/1.jpg") // 给 itemView 设置 LayoutParams .setLayoutParams(100, 100) // 给指定控件设置 LayoutParams .setLayoutParams(R.id.test_tv, 100, 100) // 点击事件，会发送到 Adapter#ChildViewClickEvent .setClick(R.id.test_tv) // 点击事件，直接设置 listener .setClick(R.id.test_tv, view -&gt; &#123; ToastX.show("点击事件"); &#125;) // 点击事件 .setClick(view -&gt; &#123; ToastX.show("点击事件"); &#125;) // 将某个控件的点击事件绑定到另一个上面 // 针对需要触发点击效果的场景 .linkClick(R.id.cover_iv,R.id.item_view); // 长按事件，会发送到 Adapter#ChildViewLongPressEvent .setLongClick(R.id.test_tv) // 长按事件，直接设置 listener .setLongClick(R.id.test_tv, view -&gt; &#123; ToastX.show("长按事件"); return true; &#125;) // 设置长按触发拖拽事件 .dragOnLongPress(R.id.tv) // 设置触摸触发拖拽事件 .dragOnTouch(R.id.tv) // 设置长按触发侧滑事件 .swipeOnLongPress(R.id.tv) // 设置触摸触发侧滑事件 .swipeOnTouch(R.id.tv); 基础：点击事件点击事件需要在 TypeOpts 设置，单击事件默认是开启的，双击、长按事件需要手动开启；重写 onBindEvent 方法，根据 eventType 的不同，对不同事件进行处理； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class StudentItemBind extends LxItemBinder&lt;Student&gt; &#123; @Override protected TypeOpts newTypeOpts() &#123; return TypeOpts.make(opts -&gt; &#123; opts.viewType = TYPE_STUDENT; opts.layoutId = R.layout.item_squire1; opts.enableLongPress = true; // 开启长按 opts.enableDbClick = true; // 开启双击 opts.enableClick = true; // 开启单击 opts.enableFocusChange = true; // 开启焦点变化事件 &#125;); &#125; @Override public void onBindView(LxContext context, LxViewHolder holder, Student data) &#123; holder.setText(R.id.title_tv, "学：" + data.name) // 给控件加点击事件 .setClick(R.id.title_tv, v -&gt; &#123; &#125;); &#125; @Override public void onBindEvent(LxContext context, Student data, int eventType) &#123; // 如果只有点击事件，那可以不做区分，因为别的根本不会触发 switch (eventType) &#123; case Lx.ViewEvent.CLICK: // 单击 break; case Lx.ViewEvent.LONG_PRESS: // 长按 break; case Lx.ViewEvent.DOUBLE_CLICK: // 双击 break; case Lx.ViewEvent.FOCUS_CHANGE: // 焦点变化，可以通过 context.holder.itemView.hasFocus() 判断有没有焦点 break; case Lx.ViewEvent.FOCUS_ATTACH: // 焦点变化，获得焦点 break; case Lx.ViewEvent.FOCUS_DETACH: // 焦点变化，失去焦点 break; &#125; &#125;&#125; 基础：扩展自定义类型首先声明类型 123456public static final int TYPE_TEACHER = Lx.contentTypeOf();public static final int TYPE_STUDENT = Lx.contentTypeOf();public static final int FOOTER = Lx.extTypeAfterContentOf();public static final int HEADER = Lx.extTypeBeforeContentOf(); 构建 LxAdapter 和平常一样使用，这里我们使用了 4 种类型： 123456LxList list = new LxTypedList();LxAdapter.of(list) // 这里指定了 5 种类型的数据绑定 .bindItem(new StudentItemBind(), new TeacherItemBind(), new HeaderItemBind(),new FooterItemBind()) .attachTo(mRecyclerView, LxManager.grid(getContext(), 3)); 添加数据，它们被添加到一个数据源列表中： 1234567891011121314151617LxList list = new LxList();LxSource snapshot = LxSource.snapshot(list);// 添加两个 headersnapshot.add(TYPE_HEADER, new NoNameData("header1"));snapshot.add(TYPE_HEADER, new NoNameData("header2"));// 交替添加 10 个学生和老师List&lt;Student&gt; students = ListX.range(10, index -&gt; new Student("1"));List&lt;Teacher&gt; teachers = ListX.range(10, index -&gt; new Teacher("2"));for (int i = 0; i &lt; 10; i++) &#123; snapshot.add(TYPE_STUDENT, students.get(i)); snapshot.add(TYPE_TEACHER, teachers.get(i));&#125;// 添加两个 footersnapshot.add(TYPE_FOOTER, new NoNameData("footer1"));snapshot.add(TYPE_FOOTER, new NoNameData("footer2"));// 发布数据更新list.update(snapshot); 从源数据中获取区块数据，对他们做独立的修改操作： 12345678910// 数据源LxList list = new LxList();// 生成 AdapterLxAdapter.of(list)...// 获取内容类型，在这里是中间的学生和老师LxList contentTypeData = list.getContentTypeData();// 获取自定义的 TOP_HEADER 类型LxList extTypeData = list.getExtTypeData(TYPE_HEADER);// 获取内置自定义的 VIEW_TYPE_HEADER 类型LxList extTypeData = list.getExtTypeData(TYPE_FOOTER); 我们发现，拿到每种类型的区块数据后，添加和更改每种特殊的类型，是非常方便的，没有针对性的去做 Header Footer 这些固定的功能，其实它们只是数据的一种类型，可以按照自己的需要做任意的扩展，这样会灵活很多，其他的比如骨架屏、空载页、加载中效果都可以基于这个实现； 功能：事件发布一般来说我们数据和视图是分离的，Adapter 的数据源一般会被 Presenter 等逻辑层持有，一般会有以下两个场景： 从 Presenter 层有一些数据变化的需要，需要 Adapter 响应； 某一些 Adapter 的响应可以被抽离出来，更好的复用； 因此需要事件发布机制，他在 数据（LxList） 和 视图（Adapter） 中间搭建了一条事件通道，借助它可以发布和响应事件；这有点类似于 EventBus 不过他不是注册在内存中的，是依赖于 LxList 的； 123456789101112131415161718192021// 事件public static final String HIDE_LOADING = "HIDE_LOADING";// 定义事件拦截器EventSubscriber subscriber = (event, adapter, extra) -&gt; &#123; LxList lxModels = adapter.getData(); LxList extTypeData = lxModels.getExtTypeData(TYPE_LOADING); extTypeData.updateClear();&#125;;// 全局注入，会对所有 Adapter 生效LxGlobal.subscribe(HIDE_LOADING, subscriber);// 对 Adapter 注入，仅对当前 Adapter 生效LxAdapter.of(models) .bindItem(new StudentItemBind()) .subscribe(HIDE_LOADING, subscriber) .attachTo(mContentRv, LxManager.linear(getContext()));// 直接在数据层注入，会对该数据作为数据源的 Adapter 生效models.subscribe(HIDE_LOADING, subscriber); 发布事件： 123456// 数据源LxList list = new LxList();// 一般我们在 Presenter 等数据处理层会拿到数据源，使用数据源可以直接向 Adapter 发布事件list.postEvent(HIDE_LOADING);list.postEvent(HIDE_LOADING, new LoadingData(LOADING_NONE)); 事件也可以被抽象封装出来，作为一些公共的逻辑复用，例如框架内部内置了如下几个事件： 1234567891011121314151617// 设置加载更多开关list.postEvent(Lx.Event.LOAD_MORE_ENABLE, false)// 结束加载更多list.postEvent(Lx.Event.FINISH_LOAD_MORE);// 结束加载更多，顶部+底部Lx.Event.FINISH_LOAD_MORE// 结束加载更多，底部Lx.Event.FINISH_END_EDGE_LOAD_MORE// 结束加载更多，顶部Lx.Event.FINISH_START_EDGE_LOAD_MORE// 设置加载更多开关Lx.Event.LOAD_MORE_ENABLE// 设置底部加载更多开关Lx.Event.END_EDGE_LOAD_MORE_ENABLE// 设置顶部加载更多开关Lx.Event.START_EDGE_LOAD_MORE_ENABLE 功能：跨越多列（Span）当使用 GridLayoutManager 布局时，可能某种类型需要跨越多列，需要针对每种类型进行指定； 123456789101112131415static class StudentItemBind extends LxItemBinder&lt;Student&gt; &#123; @Override protected TypeOpts newTypeOpts() &#123; return TypeOpts.make(opts -&gt; &#123; opts.viewType = TYPE_STUDENT; opts.layoutId = R.layout.item_squire1; // 使用内置参数，跨越所有列 opts.spanSize = Lx.SpanSize.ALL; // 使用内置参数，跨越总数的一半 opts.spanSize = Lx.SpanSize.HALF; // 使用固定数字，跨越 3 列 opts.spanSize = 3; &#125;); &#125; 指定一个确定的 SpanSize 通常是不灵活的，因为我们不知道 RecyclerView 在使用时指定的列数 (spanCount)，因此建议使用一个标记表示： 12345Lx.SpanSize.NONE // 不设置，默认值Lx.SpanSize.ALL // 跨越整行Lx.SpanSize.HALF // 跨越一半Lx.SpanSize.THIRD // 跨越 1/3Lx.SpanSize.QUARTER // 跨越 1/4 可能这些还不足以兼容到所有情况，可以设置 SpanSize 适配接口，自己来处理这些标记： 12345678910// 跨越 1/5public static final int SPAN_SIZE_FIFTH = --Lx.SpanSize.BASIC;// 处理这个标记，返回真正的 spanSizeLxGlobal.setSpanSizeAdapter((spanCount, spanSize) -&gt; &#123; if (spanSize == SPAN_SIZE_FIFTH &amp;&amp; spanCount % 5 == 0) &#123; return spanCount / 5; &#125; return spanSize;&#125;); 功能：间隔（Space）一般在业务开发中，我们希望布局周边带有一样的间隔，这样比较整齐，一般有两种方案： 使用 padding 来做，中间相接的地方就会变为间隔的两倍，不能均分，也可以动态设置左右不同 padding，但是相对耗时耗力； 使用 ItemDecoration 来做，可以根据位置动态的设置，上下左右间距，但是因为多类型的存在，每种类型的 spanSize 不同，很难一下处理好； 为此提供了 LxSpaceComponent，用来为所有类型布局周边添加相等的间隔，并且在数据增删变动时，也能及时自动修改间距，用法如下： 123456789101112131415LxAdapter.of(mLxModels) .bindItem(new SpaceItemBinder()...) .component(new LxSpaceComponent(50)) .attachTo(mContentRv, LxManager.grid(getContext(), 3));// 自定义扩展LxAdapter.of(mLxModels) .bindItem(new SpaceItemBinder()...) .component(new LxSpaceComponent(50, new LxSpaceComponent.SpaceSetter() &#123; @Override public void set(LxSpaceComponent comp, Rect outRect, LxSpaceComponent.SpaceOpts opts) &#123; // 自己做一些定制改变 &#125; &#125;)) .attachTo(mContentRv, LxManager.grid(getContext(), 3)); 功能：加载更多（LoadMore）加载更多功能由 LxStartEdgeLoadMoreComponent 和 LxEndEdgeLoadMoreComponent 承担，可以选择性的使用它们； 12345678910111213LxAdapter.of(list) .bindItem(new StudentItemBind()) // 顶部加载更多，提前 10 个预加载 .component(new LxStartEdgeLoadMoreComponent(10, comp -&gt; &#123; // 在这里做网络请求，完成后调用 finish 接口 comp.finishLoadMore(); &#125;)) // 底部加载更多，提前 6 个预加载 .component(new LxEndEdgeLoadMoreComponent(6, comp -&gt; &#123; // 在这里做网络请求，完成后调用 finish 接口 comp.finishLoadMore(); &#125;)) .attachTo(mRecyclerView, LxManager.grid(getContext(), 3)); 功能：选择器（Selector）主要用于在列表中实现选择器的需求，单选、多选、状态变化等业务场景; 这部分功能交给 LxSelectComponent 1234567891011LxAdapter.of(list) .bindItem(new StudentItemBind()) // 多选 .component(new LxSelectComponent(Lx.SelectMode.MULTI)) .attachTo(mRecyclerView, LxManager.grid(getContext(), 3));// 从 component 中获取选中的数据集LxSelectComponent component = adapter.getComponent(LxSelectComponent.class);if (component != null) &#123; List&lt;Student&gt; result = component.getResult();&#125; 在 BindView 中描述当数据被选中时如何显示： 12345678910111213141516171819class SelectItemBind extends LxItemBinder&lt;NoNameData&gt; &#123; //... @Override public void onBindView(LxContext context, LxViewHolder holder, NoNameData data) &#123; LxModel model = context.model; // 根据选中状态显示 UI holder.setText(R.id.title_tv, model.isSelected() ? "我被选中" : "条件我没有被选中"); holder.setImage(R.id.cover_iv, "image url"); &#125; @Override public void onBindEvent(LxContext context, NoNameData data, int eventType) &#123; // 点击某项时执行选中操作 LxSelectComponent component = adapter.getComponent(LxSelectComponent.class); if (component != null) &#123; component.select(context.model); &#125; &#125;&#125; 选中某项时通常只是更改一个标记，我们不希望把整个 BindView 方法执行一遍，这会带来性能的损耗，有时还会造成图片闪烁等问题，当选中被触发时，框架也会发出一个 条件更新 的事件，关于 条件更新 可以参考后面相关的文档，这里简单说一下用法： 123456789101112131415161718192021class SelectItemBind extends LxItemBinder&lt;NoNameData&gt; &#123; //... @Override public void onBindView(LxContext context, LxViewHolder holder, NoNameData data) &#123; LxModel model = context.model; // 选中触发时，会触发条件更新 // 如果你的 bind 方法执行了很多操作，当条件更新发生时 // 可以选择性的绑定部分数据，避免性能的损失 if (context.bindMode == Lx.BindMode.CONDITION) &#123; if (context.conditionKey.equals(Lx.Condition.CONDITION_SELECTOR)) &#123; holder.setText(R.id.title_tv, model.isSelected() ? "我被选中" : "条件我没有被选中"); return; &#125; &#125; // 根据选中状态显示 UI holder.setText(R.id.title_tv, model.isSelected() ? "我被选中" : "条件我没有被选中"); holder.setImage(R.id.cover_iv, "image url"); &#125;&#125; 滑动选中：使用 LxSlidingSelectLayout 包裹 RecyclerView 会自动和 LxSelectComponent 联动实现滑动选中功能； 12345678910&lt;com.zfy.adapter.decoration.LxSlidingSelectLayout android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.v7.widget.RecyclerView android:layout_width="match_parent" android:id="@+id/content_rv" android:layout_height="match_parent"/&gt;&lt;/com.zfy.adapter.decoration.LxSlidingSelectLayout&gt; 功能：列表动画（Animator）动画分为了两种: 一种是 BindAnimator，在 onBindViewHolder 里面执行； 一种是 ItemAnimator, 是 RecyclerView 官方的支持方案； 这部分功能由 LxBindAnimatorComponent 和 LxItemAnimatorComponent 完成； BindAnimator内置了以下几种，还可以再自定义扩展： BindAlphaAnimator BindScaleAnimator BindSlideAnimator 12345LxAdapter.of(list) .bindItem(new StudentItemBind()) // 缩放动画 .component(new LxBindAnimatorComponent(new BindScaleAnimator())) .attachTo(mRecyclerView, LxManager.grid(getContext(), 3)); 也可以分类型指定动画，每种类型给予不同的动画效果 12345678910111213class StudentItemBind extends LxItemBinder&lt;Student&gt; &#123; StudentItemBind() &#123; super(TypeOpts.make(opts -&gt; &#123; opts.viewType = TYPE_STUDENT; opts.layoutId = R.layout.item_squire1; // 这种类型单独的动画效果 opts.bindAnimator = new BindAlphaAnimator(); &#125;)); &#125; // ...&#125; ItemAnimator这部分参考 wasabeef-recyclerview-animators 实现，它可以提供更多动画类型的实现。 12345LxAdapter.of(list) .bindItem(new StudentItemBind()) // 缩放动画 .component(new LxItemAnimatorComponent(new ScaleInAnimator())) .attachTo(mRecyclerView, LxManager.grid(getContext(), 3)); 功能：悬挂效果（Fixed）针对每种类型悬挂效果，可以支持所有类型所有布局文件的顶部悬挂效果，需要使用 LxFixedComponent 实现，支持两种实现方式： 采用绘制的方式，优点是悬挂的视图有挤压效果，效率上也更好，但是因为是绘制的所以不支持点击事件，可以采用覆盖一层 View 来解决这个问题； 采用生成 View 的方式，优点是实实在在的 View，点击事件什么的自然都支持，缺点是你需要提供一个容器，而且视图之间没有挤压的效果； 1234567LxAdapter.of(list) .bindItem(new StudentItemBind()) // 悬挂效果 .component(new LxFixedComponent()) // 悬挂效果 .component(new LxFixedComponent(mMyViewGroup)) .attachTo(mRecyclerView, LxManager.grid(getContext(), 3)); 同时在 TypeOpts 中说明哪些类型需要支持悬挂 1234567891011121314class StudentItemBind extends LxItemBinder&lt;Student&gt; &#123; @Override protected TypeOpts newTypeOpts() &#123; super(TypeOpts.make(opts -&gt; &#123; opts.viewType = TYPE_STUDENT; opts.layoutId = R.layout.item_squire1; // 这种类型单独的动画效果 opts.enableFixed = true; &#125;)); &#125; // ...&#125; 功能：拖拽和侧滑(drag/swipe)针对每种类型支持拖拽和侧滑功能，由 LxDragSwipeComponent 完成该功能； 关注配置项，配置项决定了该类型的响应行为； 支持长按、触摸触发相应的响应； 支持全局自动触发和手动触发两种方式； 首先定义拖拽、侧滑得一些配置参数： 12345678public static class DragSwipeOptions &#123; public int dragFlags; // 拖动方向，在哪个方向上允许拖动，默认4个方向都可以 public int swipeFlags; // 滑动方向，在哪个方向上允许侧滑，默认水平 public boolean longPressItemView4Drag = true; // 长按自动触发拖拽 public boolean touchItemView4Swipe = true; // 触摸自动触发滑动 public float moveThreshold = .5f; // 超过 0.5 触发 onMoved public float swipeThreshold = .5f; // 超过 0.5 触发 onSwipe&#125; 然后使用 LxDragSwipeComponent 完成拖拽、侧滑功能： 1234567891011121314151617181920212223242526272829303132LxDragSwipeComponent.DragSwipeOptions options = new LxDragSwipeComponent.DragSwipeOptions();// 在上下方向上拖拽options.dragFlags = ItemTouchquery.UP | ItemTouchquery.DOWN;// 关闭触摸自动触发侧滑options.touchItemView4Swipe = false;LxAdapter.of(list) .bindItem(new StudentItemBind()) // 当侧滑和拖拽发生时触发的时机，可以响应的做高亮效果 .component(new LxDragSwipeComponent(options, (state, holder, context) -&gt; &#123; switch (state) &#123; case Lx.DragState.NONE: // 拖拽无状态 break; case Lx.DragState.ACTIVE: // 触发拖拽 break; case Lx.DragState.RELEASE: // 释放拖拽 break; case Lx.SwipeState.NONE: // 侧滑无状态 break; case Lx.SwipeState.ACTIVE: // 触发侧滑 break; case Lx.SwipeState.RELEASE: // 释放侧滑 break; &#125; &#125;)) .attachTo(mRecyclerView, LxManager.grid(getContext(), 3)); 最后在 TypeOpts 里面配置该类型是否支持侧滑和拖拽，这样可以灵活的控制每种类型数据的行为： 1234567891011class StudentItemBind extends LxItemBinder&lt;Student&gt; &#123; StudentItemBind() &#123; super(TypeOpts.make(opts -&gt; &#123; opts.viewType = TYPE_STUDENT; opts.layoutId = R.layout.item_squire1; opts.enableDrag = true; // 支持拖拽 opts.enableSwipe = true; // 支持侧滑 &#125;)); &#125; // ...&#125; 手动触发：使用以上方法会为整个 item 设置拖拽和侧滑响应，你可以指定某个控件触发这些操作，为了避免冲突我们现在配置项中关闭自动触发逻辑： 12345LxDragSwipeComponent.DragSwipeOptions options = new LxDragSwipeComponent.DragSwipeOptions();// 关闭触摸自动触发侧滑options.touchItemView4Swipe = false;// 关闭长按自动触发拖拽options.longPressItemView4Drag = false; 然后在 onBindView 时，手动关联触发操作： 12345678910111213141516171819202122232425class StudentItemBind extends LxItemBinder&lt;Student&gt; &#123; StudentItemBind() &#123; super(TypeOpts.make(opts -&gt; &#123; opts.viewType = TYPE_STUDENT; opts.layoutId = R.layout.item_squire1; // 当使用 holder 手动设置时，以下属性会被自动更改，可以不用设置 // opts.enableDrag = true; // opts.enableSwipe = true; &#125;)); &#125; @Override public void onBindView(LxContext context, LxViewHolder holder, Student data) &#123; holder // 长按标题控件触发拖拽 .dragOnLongPress(adapter, R.id.title_tv) // 触摸标题控件触发拖拽 .dragOnTouch(adapter, R.id.title_tv) // 长按标题控件触发侧滑 .swipeOnLongPress(adapter, R.id.title_tv) // 触摸标题控件触发侧滑 .swipeOnTouch(adapter, R.id.title_tv); &#125;&#125; 功能：实现 ViewPager (Snap)内部使用 SnapHelper 实现，很简单，只是要把他封装成 LxComponent 的形式，统一起来，由 LxSnapComponent 实现； 1234567LxAdapter.of(list) .bindItem(new StudentItemBind()) // 实现 ViewPager 效果 .component(new LxSnapComponent(Lx.SnapMode.PAGER)) // 实现 ViewPager 效果，但是可以一次划多个 item .component(new LxSnapComponent(Lx.SnapMode.LINEAR)) .attachTo(mRecyclerView, new LinearLayoutManager(getContext())); 模拟 ViewPager 添加了 OnPageChangeListener 123456789101112131415161718192021LxAdapter.of(mLxModels) .bindItem(new PagerItemBind()) .component(new LxSnapComponent(Lx.SnapMode.PAGER, new LxSnapComponent.OnPageChangeListener() &#123; @Override public void onPageSelected(int lastPosition, int position) &#123; // 选中监听 RecyclerView.ViewHolder holder = mRecyclerView.findViewHolderForAdapterPosition(position); RecyclerView.ViewHolder lastHolder = mRecyclerView.findViewHolderForAdapterPosition(lastPosition holder.itemView.animate().scaleX(1.13f).scaleY(1.13f).setDuration(300).start(); if (lastHolder != null &amp;&amp; !lastHolder.equals(holder)) &#123; lastHolder.itemView.animate().scaleX(1f).scaleY(1f).setDuration(300).start(); &#125; &#125; @Override public void onPageScrollStateChanged(int state) &#123; // 滑动状态监听 &#125; &#125;)) .attachTo(mRecyclerView, new LinearLayoutManager(getContext(), LinearLayoutManager.HORIZONTAL, false)); 功能：实现分组列表（Expandable）基于我们基本的设计架构是可以很轻松的实现分组列表效果的，但是这个场景用到的时候比较多，所以内置一些辅助类，用来更好、更简单的实现分组列表； 针对分组列表的场景设计了 LxExpandable 辅助类； 首先 组 的数据结构需要实现接口 LxExpandable.ExpandableGroup: 123456789101112131415161718192021222324252627static class GroupData implements LxExpandable.ExpandableGroup&lt;GroupData, ChildData&gt; &#123; public List&lt;ChildData&gt; children; public String title; public boolean expand; public int groupId; @Override public List&lt;ChildData&gt; getChildren() &#123; return children; &#125; @Override public boolean isExpand() &#123; return expand; &#125; @Override public void setExpand(boolean expand) &#123; this.expand = expand; &#125; @Override public int getGroupId() &#123; return groupId; &#125;&#125; 然后 子 的数据结构需要实现接口 LxExpandable.ExpandableChild： 1234567891011121314151617static class ChildData implements LxExpandable.ExpandableChild&lt;GroupData, ChildData&gt; &#123; public String title; public int childId; public int groupId; public GroupData groupData; @Override public int getGroupId() &#123; return groupId; &#125; @Override public GroupData getGroupData() &#123; return groupData; &#125;&#125; 然后定义的 GroupItemBind 和 ChildItemBind： 点击分组可以展开或者收起当前的分组子数据： 12345678910111213141516171819202122static class GroupItemBind extends LxItemBinder&lt;GroupData&gt; &#123; GroupItemBind() &#123; super(TypeOpts.make(opts -&gt; &#123; opts.spanSize = Lx.SpanSize.ALL; opts.viewType = Lx.ViewType.EXPANDABLE_GROUP; opts.layoutId = R.layout.item_group; opts.enableFixed = true; &#125;)); &#125; @Override public void onBindView(LxContext context, LxViewHolder holder, GroupData data) &#123; holder.setText(R.id.section_tv, data.title + " " + (data.expand ? "展开" : "关闭")); &#125; @Override public void onBindEvent(LxContext context, GroupData listItem, int eventType) &#123; // 展开/关闭分组 LxExpandable.toggleExpand(adapter, context, listItem); &#125;&#125; 点击子数据，可以删除当前子数据： 123456789101112131415161718192021static class ChildItemBind extends LxItemBinder&lt;ChildData&gt; &#123; ChildItemBind() &#123; super(TypeOpts.make(opts -&gt; &#123; opts.spanSize = Lx.SpanSize.ALL; opts.viewType = Lx.ViewType.EXPANDABLE_CHILD; opts.layoutId = R.layout.item_simple; &#125;)); &#125; @Override public void onBindView(LxContext context, LxViewHolder holder, ChildData data) &#123; holder.setText(R.id.sample_tv, data.title + " ，点击删除"); &#125; @Override public void onBindEvent(LxContext context, ChildData data, int eventType) &#123; // 点击删除子项 LxExpandable.removeChild(adapter, context, data); &#125;&#125; 生成 LxAdapter: 123LxAdapter.of(mLxModels) .bindItem(new GroupItemBind(), new ChildItemBind()) .attachTo(mRecyclerView, LxManager.grid(getContext(), 3)); 我们模拟一些假数据： 1234567891011121314151617List&lt;GroupData&gt; groupDataList = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 15; i++) &#123; GroupData groupData = new GroupData("group -&gt; " + i); groupData.groupId = i; groupDataList.add(groupData); List&lt;ChildData&gt; childDataList = new ArrayList&lt;&gt;(); for (int j = 0; j &lt; 5; j++) &#123; ChildData childData = new ChildData("child -&gt; " + j + " ,group -&gt; " + i); childData.childId = j; childData.groupId = i; childData.groupData = groupData; childDataList.add(childData); &#125; groupData.children = childDataList;&#125;LxSource source = LxSource.just(Lx.ViewType.EXPANDABLE_GROUP, groupDataList);mLxModels.update(source); 是不是很简单啊，感觉上还是写了一些代码，没有一行代码实现xxx 的感觉，只是提供一个思路，如果类库内部接管太多业务逻辑其实是不友好的，可以看下 LxExpandable 的代码，其实就是对数据处理的一些封装，基于基本的设计思想很容易抽离出来； 功能：实现嵌套滑动（Nesting）开发中有种比较常见的场景，垂直的列表中，嵌套横向滑动的列表： 横向滑动和纵向滑动事件不能冲突； 上下滑动时，不能因为加载横向的列表造成滑动的卡顿； 滑动过的横向列表，再回来时，要保持原先的滑动状态； 针对这种场景，设计了 LxNesting 辅助工具； 最外层列表的使用跟之前一样就不再赘述了，主要说一下横向列表如何使用 LxNesting 123456789101112131415161718192021222324252627282930class NestingItemBinder extends LxItemBinder&lt;NoNameData&gt; &#123; @Override protected TypeOpts newTypeOpts() &#123; return TypeOpts.make(opts -&gt; &#123; opts.viewType = TYPE_HORIZONTAL_CONTAINER; opts.layoutId = R.layout.item_horizontal_container; opts.spanSize = Lx.SpanSize.ALL; &#125;); &#125; // 初始化没有 adapter 时的 callback，放在这里是避免多次创建造成性能问题 // 使用 list 创建一个 Adapter 绑定到 view 上 private LxNesting mLxNesting = new LxNesting((view, list) -&gt; &#123; LxAdapter.of(list) .bindItem(new HorizontalImgItemBind()) .attachTo(view, LxManager.linear(view.getContext(), true)); &#125;); @Override public void onBindView(LxContext context, LxViewHolder holder, NoNameData listItem) &#123; holder.setText(R.id.title_tv, listItem.desc + " , offset = " + listItem.offset + " pos = " + listItem.pos); // 获取到控件 RecyclerView contentRv = holder.getView(R.id.content_rv); // 数据源 LxSource source = LxSource.just(TYPE_HORIZONTAL_IMG, listItem.datas); // 设置，这里会尝试恢复上次的位置，并计算接下来滑动的位置 mLxNesting.setup(contentRv, context.model, source.asModels()); &#125;&#125; 功能：实现滚轮选择器效果（Picker）使用 LxPicker 实现滚轮选择器效果，内部使用 LxPickerComponent + LxSnapComponent 实现; 当多个选择器级联时，第一个选择后接着就会触发第二个选择，达到递归触发的效果； 12345678910111213141516171819202122232425262728// 配置LxPicker.Opts opts = new LxPicker.Opts();opts.infinite = false; // 无限滚动opts.exposeViewCount = 5; // 暴露的数量opts.maxScaleValue = 1.3f; // 缩放比例opts.itemViewHeight = SizeX.dp2px(50); // 每个 item 高度opts.listViewWidth = SizeX.WIDTH / 3; // 宽度// 容器控件mPicker = new LxPicker&lt;&gt;(mPickerLl);// 当选择流程结束时触发，在这里关闭 loadingmPicker.setOnPickerDataUpdateFinishListener(() -&gt; mLoadingCl.setVisibility(View.GONE));// 数据获取回调LxPicker.PickerDataFetcher&lt;AddressPickItemBean&gt; fetcher = (index, pickValue, callback) -&gt; &#123; mLoadingCl.setVisibility(View.VISIBLE); mViewModel.requestPickerData(pickValue == null ? null : pickValue.getId(), callback); return null;&#125;;// 添加一个 pickermPicker.addPicker(opts, new AddressItemBinder(), fetcher);mPicker.addPicker(opts, new AddressItemBinder(), fetcher);mPicker.addPicker(opts, new AddressItemBinder(), fetcher);// 触发第一个 picker 获取数据mPicker.active(); 数据绑定很简单，可以自己实现 12345678910static class AddressItemBinder extends LxItemBinder&lt;AddressPickItemBean&gt; &#123; @Override protected TypeOpts newTypeOpts() &#123; return TypeOpts.make(R.layout.pay_address_item); &#125; @Override protected void onBindView(LxContext context, LxViewHolder holder, AddressPickItemBean listItem) &#123; holder.setText(R.id.content_tv, listItem == null ? "" : listItem.getShortName()); &#125;&#125; 进阶：使用缓存优化绑定性能当列表滑动时，onBindView 方法会被执行很多次，因此如果在 onBindView 中执行了耗时操作就会影响列表的流畅度；应该尽量避免在 bind 方法中避免计算等操作，一些不会变的数据我们可以将其缓存起来，这部分功能借助 LxCache 实现； 以下是一个简单的例子，使用 Id 作为唯一标识 注册 Mapper 用户计算数据结果； 使用 cache.getString() 获取结果； 123456789101112131415public class StudentItemBinder extends LxItemBinder&lt;Student&gt; &#123; @Override protected void onAdapterAttached(LxAdapter adapter) &#123; super.onAdapterAttached(adapter); // 注册 Mapper 用来计算显示数据，计算后数据会被自动缓存 cache.addMapper(R.id.time_tv, value -&gt; FormatUtils.formatSeconds(value.getDuration())); &#125; @Override protected void onBindView(LxContext context, LxViewHolder holder, Student listItem) &#123; // 显示时，使用 Id 获取数据，数据会被自动缓存 holder.setText(R.id.time_tv, cache.getString(R.id.time_tv, context.model)); &#125;&#125; 如果数据发生了变化，需要清除缓存，清除后数据下次绑定时数据会重新计算： 1LxCache.remove(R.id.time_tv, model); 进阶：使用 Extra 扩展数据在 LxModel 中增加了 extra 他是一个 bundle 类型的数据，可以在不增加字段的情况下扩展一下临时用的数据； 12345LxModel model;// 存model.getExtra().putString("TEMP_DATA","Hello");// 取String tempData = model.getExtra().getString("TEMP_DATA",""); 进阶：使用 Idable 优化 change使用 DiffUtil 比对数据时，类库不知道它们是不是同一个对象，会使用一个自增的 ID 作为唯一标示，以此来触发 notifyDataSetChange，所以当你更改列表中的一个数据时，只会执行一次绑定，这是内部做的优化； 这也意味着每次创建对象这个 ID 都将改变，也就是说学生A 和 学生A，并不是同一个学生，因为这关系到使用者具体的业务逻辑，不过你可以通过实现 Idable 接口来返回你自己的业务 ID，当然这不是必须的。 1234567891011121314static class Student implements Idable &#123; int id; String name; Student(String name) &#123; this.name = name; &#125; @Override public Object getObjId() &#123; return id; &#125;&#125; 进阶：使用 Typeable 内置类型如果你的数据对象只有一个类型，也可以使用数据类实现 Typeable 接口，在接口方法中返回类型，这样打包数据的时候就不需要指定类型了，内部会检测是否是 Typeable 子类，获取真正的类型； 123456789static class InnerTypeData implements Typeable &#123; int type; @Override public int getItemType() &#123; return type; &#125;&#125; 进阶：使用条件更新 场景1：我们的数据并没有改变，但是我们仍旧想触发数据的更新； 场景2：只想更新一个控件，比如下载进度条，这个更新比较频繁，但是不想做不必要的刷新； 基于以上两种应用场景，条件更新应运而生，你可以不改变数据，但是触发更新，并且可以指定条件，仅刷新一个控件的显示，类似 payloads 但是不需要计算有效载荷，只需要制定一个条件即可； 1234567891011121314151617181920212223242526272829public static final String KEY_NEW_CONTENT = "KEY_NEW_CONTENT";public static final String CONDITION_UPDATE_NAME = "CONDITION_UPDATE_NAME";static class StudentItemBind extends LxItemBinder&lt;Student&gt; &#123; // ... @Override public void onBindView(LxContext context, LxViewHolder holder, Student data) &#123; if (context.bindMode == Lx.BindMode.CONDITION) &#123; // 条件更新 Bundle conditionValue = context.conditionValue; if (CONDITION_UPDATE_NAME.equals(context.conditionKey)) &#123; String value = conditionValue.getString(KEY_NEW_CONTENT, "no content"); holder.setText(R.id.title_tv, value + "," + data.name); &#125; &#125; &#125; @Override public void onBindEvent(LxContext context, Student listItem, int eventType) &#123; LxList models = adapter.getData(); models.updateSet(context.layoutPosition, data -&gt; &#123; Bundle bundle = new Bundle(); bundle.putString(KEY_NEW_CONTENT, "I AM NEW CONTENT"); data.setCondition(CONDITION_UPDATE_NAME, bundle); &#125;); &#125;&#125; 进阶：使用有效载荷（payloads）更新某些场景我们只更改了一部分数据，但是会触发 notifyDataSetChanged 重新执行整个条目的绑定，这样会造成性能的损耗，有时图片要重新加载，很不友好，因此我们需要 payploads 更新的方式； payloads 可以被称为有效载荷，它记录了哪些数据是需要被更新的， 我们只更新需要的那部分就可以了，既然称为有效载荷那么他肯定是需要比对和计算的，为了实现它需要自定义这个比对规则，我们看下以下比对方法的简单介绍： areItemsTheSame 当返回 true 的时候表示是相同的元素，调用 areContentsTheSame，推荐使用 id 比对当返回 false 的时候表示是一个完全的新元素，此时会调用 insert 和 remove 方法来达到数据更新的目的 areContentsTheSame 用来比较两项内容是否相同，只有在 areItemsTheSame 返回 true 时才会调用返回 true 表示内容完全相同不需要更新返回 false 表示虽然是同个元素但是内容改变了，此时会调用 changed 方法来更新数据 getChangePayload 只有在 areItemsTheSame 返回 true 时才会调用，areContentsTheSame 返回 false 时调用返回更新事件列表，会触发 payload 更新 为了实现它，需要对数据对象进行一些更改: 实现 Diffable 接口，声明比对规则 实现 Copyable 接口，实现对象的拷贝，如果对象有嵌套，可能需要嵌套拷贝； 实现 Parcelable 接口，作用同 Copyable，写起来简单，但是性能会差一些，二选一即可； 123456789101112131415161718192021222324252627282930class Student implements Diffable&lt;Student&gt;, Copyable&lt;Student&gt; &#123; int id; String name; Student(String name) &#123; this.name = name; &#125; @Override public Student copyNewOne() &#123; Student student = new Student(name); student.id = id; return student; &#125; @Override public boolean areContentsTheSame(Student newItem) &#123; return name.equals(newItem.name); &#125; @Override public Set&lt;String&gt; getChangePayload(Student newItem) &#123; Set&lt;String&gt; payloads = new HashSet&lt;&gt;(); if (!name.equals(newItem.name)) &#123; payloads.add("name_change"); &#125; return payloads; &#125;&#125; 这样我们就通过比对拿到了 payloads, 那我们如何使用这些有效载荷呢？ 1234567891011121314class StudentItemBind extends LxItemBinder&lt;Student&gt; &#123; @Override public void onBindView(LxContext context, LxViewHolder holder, Student data) &#123; if (context.bindMode == Lx.BindMode.PAYLOADS) &#123; // payloads 更新 for (String payload : context.payloads) &#123; if ("name_change".equals(payload)) &#123; holder.setText(R.id.title_tv, data.name); &#125; &#125; &#125; &#125;&#125; 联系我 Android开发技术交流 微信]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Android」自定义控件 - 水波纹效果]]></title>
    <url>%2Farticle%2F5c2aef5c%2F</url>
    <content type="text"><![CDATA[自定义水波纹效果控件，支持以下特性。 进度控制 波纹效果控制（宽度，层次，颜色，波峰高度） 形状形状，理论上支持所有形状，配合 drawable 实现 资源控制，资源的回收和复用，避免占用内存 列表复用 效果展示]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>自定义 View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Android」ConstraintLayout]]></title>
    <url>%2Farticle%2Fc0b3765%2F</url>
    <content type="text"><![CDATA[本文主要对 ConstraintLayout 的布局形式按照不同的约束类型进行划分，对约束属性和辅助组件进行整理。 其中约束属性包括 constraint、center、match_constraint、ratio、percent、bias、chain、weight、circle 等。 辅助组件包括 GuideLine、Barrier、Group、Placeholder 等。 constraint约束布局，是 ConstraintLayout 的核心，借助在 上下左右 四个方向上与其他控件、父控件进行相互约束，确定自己的位置，类似 RelativeLayout，不过要更加灵活。 12345&lt;!--其他方向也是一样--&gt;app:layout_constraintTop_toBottomOf="@+id/test"app:layout_constraintLeft_toLeftOf="parent" center居中布局，并没有居中布局的属性，但是可以通过约束布局指定两个方向上的约束，则控件会默认居中布局。 1234567&lt;!--与父控件约束，在水平方向居中--&gt;app:layout_constraintLeft_toLeftOf="parent"app:layout_constraintRight_toRightOf="parent"&lt;!--与其他控件约束，在垂直方向居中--&gt;app:layout_constraintTop_toTopOf="@id/test_tv"app:layout_constraintBottom_toBottomOf="@id/test_tv" match_constraint匹配约束，不是简单的类似 match_parent，他的意思是在约束范围内匹配空间，在 ConstraintLayout 将控件尺寸声明为 0dp 可以达到 match_constraint 的效果。 12345678910111213&lt;!--高度 match_constraint，控件会撑满 test_tv1 到 test_tv2 之间的空隙--&gt;&lt;TextView app:layout_constraintTop_toTopOf="@+id/test_tv1" app:layout_constraintBottom_toBottomOf="@id/test_tv2" android:layout_width="wrap_content" android:layout_height="0dp"/&gt; &lt;!--高度 10dp，控件会在 test_tv1 到 test_tv2 之间居中，但是高度仍旧是 10dp--&gt;&lt;TextView app:layout_constraintTop_toTopOf="@+id/test_tv1" app:layout_constraintBottom_toBottomOf="@id/test_tv2" android:layout_width="wrap_content" android:layout_height="10dp"/&gt; ratio比例约束，用宽高比来约束控件的尺寸，根据 ratio 计算的那个尺寸需要声明为 match_constraint。 123456789101112131415161718&lt;!--宽度 100，高度 match_constraint，最终高度为 50dp--&gt;android:layout_width="100dp"android:layout_height="0dp"app:layout_constraintDimensionRatio="2:1"&lt;!--默认 宽：高，意为 w:h = 2:1 --&gt;app:layout_constraintDimensionRatio="w,2:1"&lt;!--强制高为基准 高：宽，意为 h:w = 2:1 --&gt;app:layout_constraintDimensionRatio="h,2:1"&lt;!--宽高都为 match_constraint，test_tv 宽度 100dp，则该控件宽度因为其他约束的存在也是可以被确定为 100dp 的，所以也可以这样使用--&gt;app:layout_constraintLeft_toLeftOf="@id/test_tv"app:layout_constraintRight_toRightOf="@id/test_tv"android:layout_width="0dp"android:layout_height="0dp"app:layout_constraintDimensionRatio="2:1" percent百分比布局，用来指定尺寸占据父布局尺寸的百分比，达到更好的适配效果。根据 percent 计算的那个尺寸需要声明为 match_constraint。 12app:layout_constraintWidth_percent="0.5"app:layout_constraintHeight_percent="0.5" bias偏差约束，当一个控件因为其他约束的存在被确定了位置，在他的 上下、左右 会留有距离，Bias 的存在是为了指定 上面和下面、左边和右边 距离的比例分配。 比如一个控件因为左右各有约束居中显示了，指定 Horizontal_bias 为 0.1，则表示他左边的距离占据水平方向空余距离的 1/10。 1234567891011&lt;!--左右约束使他居中，bias 使他靠近左边显示，左边空白占据全部空白距离的1/10--&gt;&lt;TextView app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintHorizontal_bias="0.1" android:layout_width="100dp" android:layout_height="10dp"/&gt; &lt;!--也可以指定垂直方向的偏差--&gt; app:layout_constraintHorizontal_bias="0.5"app:layout_constraintVertical_bias="0.5" chain链约束，多个控件在一个方向上面互相约束，环环相扣，好像一条锁链一样，形成链约束，chainStyle 决定了在一条链当中，空白间距和控件之间是如何摆放的。 1234567891011121314151617181920212223&lt;!--控件受拉力均匀分布，两边和控件之间平分间距--&gt; app:layout_constraintVertical_chainStyle="spread"app:layout_constraintHorizontal_chainStyle="spread"&lt;!--控件受拉力均匀分布，两边没有空白间距，控件之间平分间距--&gt; app:layout_constraintVertical_chainStyle="spread_inside"app:layout_constraintHorizontal_chainStyle="spread_inside"&lt;!--控件全部挤压在中间，空白间距在两边--&gt; app:layout_constraintVertical_chainStyle="packed"app:layout_constraintHorizontal_chainStyle="packed"&lt;!--以下三个控件在一个方向上互相约束，达到一种链的效果--&gt; &lt;View android:id="@+id/v1" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toLeftOf="@+id/v2"/&gt;&lt;View android:id="@+id/v2" app:layout_constraintLeft_toRightOf="@+id/v1" app:layout_constraintRight_toLeftOf="@+id/v3"/&gt;&lt;View android:id="@+id/v3" app:layout_constraintLeft_toRightOf="@+id/v2" app:layout_constraintRight_toRightOf="parent"/&gt; weight权重，类似 LinearLayout 的 weight 属性，根据 weight 计算的那个尺寸需要声明为 match_constraint。 使用 weight 布局的控件需要在一个方向上面有一个完整的约束，也就是他们就好像在一个 LiearLayout 里面的那种感觉，这几个控件互相也是需要有约束的，weight 常和 Chain 布局合作，可以看下面的例子。 12345678910111213141516171819202122232425262728app:layout_constraintHorizontal_weight="1"app:layout_constraintVertical_weight="1"&lt;!--以下三个控件是链约束，宽度是 match_constraint，中间的权重是其他的 2 倍--&gt; &lt;View android:id="@+id/v1" android:layout_width="0dp" android:layout_height="50dp" android:background="#f00" app:layout_constraintHorizontal_weight="1" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toLeftOf="@+id/v2"/&gt;&lt;View android:id="@+id/v2" android:layout_width="0dp" android:layout_height="50dp" android:background="#0f0" app:layout_constraintHorizontal_weight="2" app:layout_constraintLeft_toRightOf="@+id/v1" app:layout_constraintRight_toLeftOf="@+id/v3"/&gt;&lt;View android:id="@+id/v3" android:layout_width="0dp" android:layout_height="50dp" android:background="#00f" app:layout_constraintHorizontal_weight="1" app:layout_constraintLeft_toRightOf="@+id/v2" app:layout_constraintRight_toRightOf="parent"/&gt; circle圆形约束，通过指定圆心、半径、角度达到圆形布局的效果，0度 的位置是控件的垂直正上方，顺时针旋转增大。 12345678&lt;View android:id="@+id/v4" android:layout_width="50dp" android:layout_height="50dp" android:background="#00f" app:layout_constraintCircle="@+id/v2" app:layout_constraintCircleAngle="90" app:layout_constraintCircleRadius="100dp"/&gt; GuideLine参考线，GuideLine 是一个空的 View 他的存在是为了给其他 View 布局提供一个参考的标准 1234567891011121314151617181920212223&lt;!--使用 GuideLine 构建两条居中、互相垂直的参考线，将布局分为 4 个象限--&gt; &lt;android.support.constraint.Guideline android:layout_width="0dp" android:layout_height="0dp" android:orientation="vertical" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintGuide_percent="0.5" app:layout_constraintTop_toTopOf="parent"/&gt;&lt;android.support.constraint.Guideline android:layout_width="0dp" android:layout_height="0dp" android:orientation="horizontal" app:layout_constraintGuide_percent="0.5" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent"/&gt; &lt;!--可以使用如下属性更好的确定 GuideLine 的位置，其他属性使用起来和 View 一样的--&gt;android:orientation="horizontal"app:layout_constraintGuide_percent="0.5"app:layout_constraintWidth_percent="0.5"app:layout_constraintHeight_percent="0.5"app:layout_constraintGuide_begin="10dp"app:layout_constraintGuide_end="10dp" Group分组，因为使用 ConstraintLayout 大幅度的降低了布局的层级的同时，很多原本不同逻辑的 View 组合现在被布局在相同的层级下面，与此同时也丧失了我们隐藏父控件就可以隐藏一整个逻辑组合控件的便利。Group 是一个空的 View，他的作用是用来关联其他控件，也被称为分组，这样一来隐藏 Group 就可以便捷的同时隐藏他关联的所有控件。 1234&lt;android.support.constraint.Group android:layout_width="wrap_content" android:layout_height="wrap_content" app:constraint_referenced_ids="test_id1,test_id2,test_id3"/&gt; Barrier屏障，因为控件之间需要相互约束控制自己的位置，并且每个方向上只能存在一个约束控件，但是在一个方向上可能出现需要和多个控件同时约束的情况，Barrier 是一个空的 View，他的出现就是为了解决某个方向上需要动态的和多个控件约束的情况，关联这些不确定的控件创建一个 Barrier，Barrier 是可以实现在某个方向和多个控件约束的，然后我们控件再和 Barrier 进行约束控制即可。 比如当前的控件需要在两个控件中比较宽的那个右边，但是这两个控件在运行期间内容会不断变化，我们没办法确定哪个是更宽的，使用 Barrier 可以在这两个控件右边设置一个屏障，关联到这两个控件，则随着两个控件的变化，屏障也总是在两个控件中较宽的控件右边，我们的控件与 Barrier 进行约束控制即可。 barrierDirection 屏障的方向。 barrierAllowsGoneWidgets 是否将 GONE 掉的控件考虑在内，默认为 true，即当 Barrier 引用的控件被 GONE 掉时，则 Barrier 默认的创建行为是在已 GONE 掉控件的已解析位置上进行创建。如果设置为 false，则不会将 GONE 掉的控件考虑在内。 123456&lt;android.support.constraint.Barrier app:barrierDirection="bottom" app:barrierAllowsGoneWidgets="true" android:layout_width="wrap_content" android:layout_height="wrap_content" app:constraint_referenced_ids="test_tv1,test_tv2"/&gt; Placeholder占位，Placeholder 是一个空的 View，主要用来占位。 通过 setContentId() 设置内容，被设置的内容会在原来的位置消失而到 PlaceHolder 的位置上。 通过 setEmptyVisibility() 可以设置当没有内容时，PlaceHolder 的可见性，默认是 INVISIBLE。 123&lt;android.support.constraint.Placeholder android:layout_width="100dp" android:layout_height="100dp" /&gt; 综上ConstraintLayout 目前的版本是 1.1.x，新的特性不断的加入进来，目前的开发中已经基本全部使用 ConstraintLayout 来进行布局，它完全可以代其他所有的布局形式，了，相信在不久以后就可以一统江湖了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[海尔兄弟星球分享之规范篇]]></title>
    <url>%2Farticle%2Ff4fca129%2F</url>
    <content type="text"><![CDATA[关于分支管理git flow 图解 主分支 master 稳定分支，用于生产环境，与线上版本同步 dev 开发分支，用于测试环境，用于构建测试版本，来源于 master 流程分支 feature/xxx 功能分支，用于功能开发，来源于 dev，开发完成并自测通过后合并到 dev hotfix/xxx 修复分支，线上功能修复，来源于 master，修复后双向merge 到 dev 和 master release/xxx 发布分支，版本发布使用，来源于 dev 测试后的稳定代码，不应再发功能开发，发布后，要双向 merge 到 dev 和 master。 命名规范 所有命名都应该以业务为优先，并且避免通用命名的方法。另外命名不宜过长，但要表明功能。 关于关键字冲突 123thiz - thisclazz - classinterfaze - interface 方法名使用小驼峰命名，首词应为动词 12public void doAnyThing() &#123;&#125;public String getMyName() &#123;&#125; 类名使用大驼峰命名 1class MainActivity &#123;&#125; 数据类属性使用小驼峰命名 123class DataObj &#123; public String name;&#125; 业务类非静态属性使用 m + 大驼峰 命名 123class HomePresenter &#123; private boolean mIsTesting;&#125; 业务类静态属性使用 s + 大驼峰 命名 123class HomePresenter &#123; private static String sPoolStr;&#125; 数据常量全部大些，下划线分隔 1public static final int TYPE_CUTOFF = 1; 控件命名规范 12private TextView mNameTv;private ImageView mAvatorIv; layout 资源命名 使用 bussiness_xxx.xml 的命名格式，做业务区分 12homepage_fragment_layout.xmlhomepage_fragment_banner_item.xml id 命名 使用 R.id.function_view 的命名格式，这个规则与前面控件命名规范保持一致。 12R.id.content_tvR.id.cover_iv 禁止通用命名 禁止使用类似如下的通用字符串作为变量、方法、常量、资源、id 的名字 123456listlistenerviewa,b,cx,y,z... 分包 本着业务优先的原则，分包方案应以业务模块为划分规则，而不应该以组件类型划分，如 activity/fragment/adapter 这种通用的包划分在项目业务膨胀后将会变得非常难管理。 按照业务划分，对以后的业务拆分和组件化也非常重要。 编码规范 属性注释 1public String name; // 姓名 方法注释 123456789101112/** * 公开方法注释 * * @param name 姓名 */public void makeFullName(String name) &#123;&#125;// 私有方法注释private void doSomeThingInternal() &#123; &#125; 常量提取，并提升到类的顶部 1234public class MainViewModel &#123; public static final int TYPE_TEST = 0; public static final String KEY_NAME = "KEY_NAME";&#125; 启动 Activity 和创建 Fragment 使用静工厂封装/不用 123456789101112131415161718192021222324public class MainActivity extends MvvmActivity &#123; public static final String KEY_NAME = "KEY_NAME"; public static void startActivity(Context context, String name) &#123; Intent intent = new Intent(context, MainActivity.class); intent.putExtra(KEY_NAME, name); context.startActivity(intent); &#125; public static void startActivityForResult(Activity context, int reqCode) &#123; Intent intent = new Intent(context, MainActivity.class); context.startActivityForResult(intent, reqCode); &#125;&#125;// 创建 Fragmentpublic class TestFragment extends Fragment &#123; public static final String KEY_NAME = "KEY_NAME"; public static TestFragment newInstance(String name) &#123; Bundle args = new Bundle(); args.putString(KEY_NAME, name); TestFragment fragment = new TestFragment(); fragment.setArguments(args); return fragment; &#125;&#125; xml 标签在行末闭合 12345678910// good&lt;ImageView android:layout_width="43dp" android:layout_height="43dp" /&gt;// not good&lt;ImageView android:layout_width="43dp" android:layout_height="43dp" /&gt; xml 中使用 left/right 的地方，使用 start/end 消除警告 12345678&lt;ImageView android:layout_gravity="end" android:layout_marginEnd="10dp" android:layout_marginLeft="10dp" android:layout_marginRight="10dp" android:layout_marginStart="10dp" android:layout_width="43dp" android:layout_height="43dp"/&gt; 拒绝硬编码 UI 主要体现在如果是一个列表结构，那么不应该在 xml 挨个罗列，应该在代码中使用循环的形式，动态 inflate 并 addView，这样会具有更好的扩展性。 1234567LinearLayout container = helper.getView(R.id.container);container.removeAllViews();List&lt;HomepageModel.CategoryItem&gt; topCategories = item.topCategories;for (HomepageModel.CategoryItem topCategory : topCategories) &#123; View inflate = LayoutInflater.from(mContext).inflate(R.layout.homepage_category_item, null, false); container.addView(inflate);&#125; 使用 tools 命名空间，不要在 xml 中编码非真实数据 1234&lt;TextView tools:text="兔小贝儿歌"/&gt;&lt;ImageView tools:src="@drawable/icon_test"/&gt; 尽量使用 ConstraintLayout，尽量不要使用 weight 使用 ConstraintLayout 减少布局层级，使用 weight 会导致 measure 多次，应尽量不要使用 weight。 代码格式化 提交代码之前应该先对代码进行格式化，包括 java 代码和 xml 代码。 使用相同的格式化规则能尽量减少代码的冲突。 每行代码不要过长 代码语句不应超过屏幕可观察范围太多，语句太长阅读起来麻烦，而且增加了理解的难度，应该使用中间变量做语句拆分。 内部类必须使用静态关键字声明 禁止使用非静态内部类，尤其是在 Activity 使用 Hander/AsyncTask 等，静态内部类与宿主使用虚引用交互。 123456public class MainActivity &#123; static class MyAdapter extends BaseAdapter &#123; &#125;&#125; 生成 Bean 尽量不要使用 GsonFormat，如果用了最后一定要检查生成的结果，不应该出现 类型为 Object 的属性。 使用范型组织 Bean 避免重复声明没有继承关系的 Bean。 属性声明 不要在类文件中随意位置声明属性，所有属性声明应该提升到文件顶部，在静态常量声明之下。 属性应该尽量避免在声明时初始化，初始化代码放在初始化方法中。 避免使用魔法数字和字符串 1234567// goodMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();map.put(KEY_OPEN_ID,openId);// not goodMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();map.put("openId",openId); Handler 的使用 使用 Handler 必须使用静态内部类，并且在页面销毁时调用 1handler.removeCallbacksAndMessages(null); 这对避免内存泄露至关重要 传递 Context 在任何传递 Context 都要非常慎重，尤其是单例等伪静态实现的情况。 如果不保证持有 Context 的对象可以被及时销毁，则应该使用 WeakRef 来持有上下文的引用。 switch switch 语法必须添加 default 分支。 所有的分支必须以 return 和 break 语句结束。 if if 分支遵循 fast stop 的原则，需要返回的地方优先结束流程。 只有一行的 if 语句，也需要使用 {} 12345678910public void test(int num) &#123; // fast stop if (num &lt; 0) &#123; return; &#125; // 只有一行也需要使用 &#123;&#125; 分离代码结构 if (num &gt; 100) &#123; show('&gt; 100'); &#125;&#125; 及时回收资源 这部分不再赘述，在编写一个页面的代码时，要在销毁页面的时候检查所有占用资源的对象手动回收资源。 关于内存的优化参考这篇文章 todo 测试代码使用 todo 标记，发版本时会检查禁止 todo 代码的出现。 toast toast 统一使用 HToast 封装后的，不要直接使用 ToastUtils 不方便切换。 海尔星球项目相关 DTO 我们会对数据传输的类进行封装，这种类成为 DTO，DTO 类根据使用场景不同继承 BaseXXXDTO，不要声明多余的 DTO 类，后期不好维护，如果需要继承实现应该放在 dtos 文件夹下。 123Flowable&lt;BaseDTO&lt;VideoEntity&gt;&gt; testBaseDTO();Flowable&lt;BaseListDTO&lt;VideoEntity&gt;&gt; testBaseListDTO();Flowable&lt;BasePagedDTO&lt;VideoEntity&gt;&gt; testBasePagedDTO(); 通信 通信建议依赖 EventBus 实现，所有事件继承 BaseEvent，事件要合理分类，不要声明过多的 Event，所有的Event` 类应该在各自业务逻辑包下面。 123456public class LikeTagChooseEvent extends BaseEvent &#123; public static final String CHOOSE_TAG = "CHOOSE_TAG"; public LikeTagChooseEvent(String msg) &#123; super(msg); &#125;&#125; 数据类 数据类放在指定业务文件夹下面的 beans 包下面，并以 XXXBean 命名，统一路径和命名规则，可以简化混淆成本。 模块包结构 123456789101112131415- home - beans - TestBean - dtos - SearchResultDTO - event - TestEvent - tabs // 注意这边可能是别的，但不应该是 fragments 这种 - HomeFragment - AnimationFragment - TestFragment - SearchActivity.java // View - SearchPresenter.java // Presenter - SearchModel.java // Model - SearchService.java // Service 路由管理 更好的页面管理方案应该是基于路由的，也就是 Activity 和 Activity、Activity 和 Fragment 之间应该是松耦合，他们之间不应该有互相的引用 为了后面更好的向路由方案迁移，启动 Activity 和创建 Fragment 统一由 Router 管理 其他类调用 Router 类，启动 Activity 和创建 Fragment，同时所有页面传输的 KEY 也在 Router 类里面注册，尽量复用。 网络请求 请求的 Service 集成在每个模块内部，比如首页的 5 个请求，会在 HomeApiService 里面，除非公共的请求，否则不要使用 CommonService，避免造成 CommonService 臃肿和频繁的代码冲突。 请求方法的命名，如果是 get 请求，方法命名为 getXXX(), post 请求，方法命名为 postXXX()，以此类推，方便看到请求就知道是什么请求方式。 网络请求代码的编写 发起请求使用 Api.use(SomeService.class).xxx，它是一个独立的网络请求管理者，你可以在任何位置使用它。 在 Model 层发起网络请求，并做数据处理，增强 Model 层的功能性，数据的处理使用 compose() 方法，在 ApiTransformers 中提供了大多数数据转换的方法，如果不能满足需求那么应该使用 map 函数再扩展，理论上不应在 Presenter 在做数据的转换和处理操作。 1234public Observable&lt;HomeTopStaticDTO&gt; getIndexUnion() &#123; return Api.use(HomeApiService.class).getIndexUnion() .compose(ApiTransformers.composeBaseDTO(true));&#125; 在 Presenter 层接受转换后的数据，强制 使用 ApiObserver 的静态工厂创建观察者，不要自己创建，统一观察者方便做一些公共的事情，比如加载动画，统一错误处理等等，这至关重要。 创建观察者时，需要传入 View 层的标签，使请求可以绑定到生命周期，自动取消请求，建议使用 lambda 表达式的形式，它让我们更关注业务实现，而不是接口的名字。 12345mModel.getIndexUnion().subscribe(ApiObserver.make(mView.viewTag(), data -&gt; &#123; // 成功代码在这里处理&#125;,error -&gt; &#123; // 错误统一在这里处理，不实现可以不处理。&#125;)); 综上，请大家遵循网络请求的模版代码，统一网络请求的格式。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「源码」ThreadLocal 存储线程本地变量]]></title>
    <url>%2Farticle%2Ff69b558f%2F</url>
    <content type="text"><![CDATA[ThreadLocal 顾名思义就是 线程本地数据 的意思，用于在不同线程之间独立的存取数据，这个数据在每个线程都有一个副本，不同线程存取过程不会相互影响。表现出来的效果就是，我在 A 线程存了一个 a，则我只能在 A 线程再取到、更改这个 a，我在 B 线程是拿不到这个值的。 推荐阅读 ThreadLocal的使用及原理分析 数据的存储结构 线程独立的数据是如何被存储的呢？ 数据其实仍然是被存储在各自线程中，由各自线程去维护，这样实现线程间数据独立的同时，也降低了维护数据的成本，大家管好自己的数据就可以了。而这个数据被存储在 ThreadLocalMap 中，他是 Thread 的一个成员，主要用来存储 本线程 的数据。 每个线程单独维护自己的数据，TheadLocal 只是存取的一个中介，他不管理数据，理解这一点至关重要。 ThreadLocalMap 的数据结构大致如下，看的出来他内部维护的是一个 Entry 数组，Entry 是 WeakRef 的子类，他把 ThreadLocal 和要存储的 Value 成对的存储在了一起。 这个数组的下标索引：是通过 ThreadLocal 哈希处理后获取到的，也就是说使用 ThreadLocal 可以再次定位到这个 Entry 这个数组的值：是 Entry 对象，他是 ThreadLocal 和 Value 的整合。 123456class ThreadLocalMap &#123; static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; Object value; &#125; private Entry[] table;&#125; 在每个线程中都单独维护一个 ThreadLocalMap，初始值为 null，当使用 ThreadLocal 存取数据时通过对 ThreadLocal 进行 hash 处理获得一个数组下标，ThreadLocal 和需要存储的数据对象被打包成一个 Entry 放入数组的指定位置。 也就是说 ThreadLocalMap 是一个 Entry 数组，table[ThreadLocal hash] = Entry(ThreadLocal, Value) 1234567ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY);&#125; 线程独立的存取数据 借助 ThreadLocal 如何保证线程间数据是互相独立的？ 我们通常会获得一个 ThreadLocal 对象，并使用它在不同线程做存取数据的操作。 123456789// 1.8 之后可以使用一个工厂函数返回初始值ThreadLocal&lt;Integer&gt; integerThreadLocal = ThreadLocal.withInitial(() -&gt; 100);// 1.8 之前在子类重写放啊返回初始值ThreadLocal stringThreadLocal = new ThreadLocal&lt;String&gt;() &#123; @Override protected String initialValue() &#123; return "hahha"; &#125;&#125;; 当我们获取数据时，首先借助 Thread.currentThread() 拿到当前方法执行的线程，再从线程中获取本线程维护 ThreadLocalMap 对象，他是一个 Entry(ThreadLocal.hash, Object) 数组，那么此时我么可以将当前的 ThreadLocal 做 hash 处理后，定位到相应的数组下标，取出对应的 Entry 从而拿到里面的 value，如果取不到就返回初始值，简单看一下 get() 的代码会更清晰。 123456789101112131415161718public T get() &#123; // 取到线程 Thread t = Thread.currentThread(); // 拿到线程里面的 ThreadLocalMap ThreadLocalMap map = getMap(t); if (map != null) &#123; // 用 ThreadLocal 做 hash 定位对应的 Entry // this 是 ThreadLocal ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; // 取到 Entry 里面的 value T result = (T)e.value; return result; &#125; &#125; // 返回初始值 return setInitialValue();&#125; 当往 ThreadLocal 中存入数据时，逻辑也是一样的，唯一的不同时，如果线程中的 ThreadLocalMap 没有创建时，此时会创建一个新的 ThreadLocalMap 并将数据存储进去 12345678910111213public void set(T value) &#123; // 获取到线程 Thread t = Thread.currentThread(); // 获取线程维护的 ThreadLocalMap ThreadLocalMap map = getMap(t); // 对 ThreadLocal 做 hash 拿到数组下标，打包 TreadLocal 和 value 存储 if (map != null) // this 是 ThreadLocal map.set(this, value); else // 创建新的 ThreadLocalMap 并存储 createMap(t, value);&#125; 哈希散列 数据存入表中下索引计算的规则？ 上面我们看到的都是 ThreadLocal 的方法，获取数据时，他调用了 ThreadLocalMap 的 getEntry(ThreadLocal) 方法，存入数据时调用了 ThreadLocalMap 的 set(ThreadLocal, Object) 方法，所以说真正完成数据存取的 ThreadLocalMap 类。 前面介绍了 ThreadLocalMap 本质上是一个数组 Entry[]，数组就会有一个容量大小，我们存取数据使用的是下标，这个下标必然需要在 [0, len - 1] 范围内，索引的获取使用的是哈希算法，每个 ThreadLocal 都有一个 threadLocalHashCode 他以一定的规则自增，而且必然不会重复，可以把它看作唯一的 id，当我们使用 ThreadLocal 获取数据时，首先对 threadLocalHashCode 在容量大小 length 上散列，他会生成一个 [0, len - 1] 范围内一个不重复索引，这个操作是可逆的，也就是说我每次用这个 ThreadLocal 一定会定位到这个索引，也就会定位到这个数据。 LocalThreadMap#set向 ThreadLocal 设置数据 1234567891011121314151617181920212223242526272829private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; Entry[] tab = table; int len = tab.length; // 散列得到数组索引 int i = key.threadLocalHashCode &amp; (len-1); // 从当前索引的位置向后查找 for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); // 如果匹配上了，直接覆盖原来的值 if (k == key) &#123; e.value = value; return; &#125; // 发现当前数组中的 ThreadLocal 为空，说明因为一些原因被回收了 // 则清理陈旧的数据 if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; // 没有查找到，创建新的 Entry tab[i] = new Entry(key, value); int sz = ++size; // 扩容 if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash();&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SourceCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle 日常]]></title>
    <url>%2Farticle%2F3c4d21f6%2F</url>
    <content type="text"><![CDATA[本文主要记录学习到的一些 gradle 使用技巧，并不全面，但是是在开发中会用到的一些点，可以借助这些技巧少做很多额外的工作。 代码分包主要是为了应对在不同 buildType 和 flavor 下需要使用不同的代码包这种场景，比如我们在 fortest 时初始化调试工具，但是在 release 时不会初始化，同时我们不希望通过 if(){}else{} 判断来实现，因为这种方式会将所有 buildType 的代码揉在一起，不利于扩展和维护，此时希望最好能够将不同 buildType 的代码分离，不同的构建方式时，打包不同的代码，因此代码包应该这样组织： 代码除了原来的 main 包之外，还分为了 fortest，debug，release 三个包，当使用不同的 buildType 构建时，会打包各个文件夹下的代码，这里不仅限于 java 代码，也包括资源文件等，可以看作 debug 和 main 是同级的，两个包加在一起，打包成最后的 class 文件。 题外话：那么我们什么时候使用 分包 策略，什么时候使用 if(BuildConfig.DEBUG) 判断的方法呢，相比起啦，使用 BuildConfig 判断写起来更简单，不需要在每个包里面去创建类，分包更适合那种不同 buildType 依赖都不同的场景，比如，我在 debug 的时候依赖了调试的 library 而在 release 时没有这个依赖，那么如果用判断的方法的话，在构建 release 时，就会找不到对应的类，因此这种场景下，需要把代码分包，在 debug 包里面才去引用 debugCompile 的内容，而在 release 时是完全没有感知的。另外使用分包的方法有个很大的好处就是代码的完全分离，不会因为其他 buildType 的代码污染你的 release 构建产品。 resValue使用该属性可以根据 buildType 和 flavor 的类型来分别设置不同的 res 资源的 value，比如在不同的 buildType 使用不同的 app_name: 1234567891011121314buildTypes &#123; release &#123; signingConfig signingConfigs.card resValue "string", "app_name", "达卡" &#125; debug &#123; signingConfig signingConfigs.card resValue "string", "app_name", "达卡(debug)" &#125; fortest &#123; signingConfig signingConfigs.card resValue "string", "app_name", "达卡(fortest)" &#125;&#125; buildConfigField使用该属性可以根据 buildType 和 flavor 的类型来更改最后编译生成的 BuildConfig 类，比如我们有一个调试开关 AssistantEntry 需要动态改变，则 1234567891011121314151617buildTypes &#123; release &#123; signingConfig signingConfigs.card buildConfigField "boolean", "AssistantEntry", "false" // 是否开启测试入口 buildConfigField "String", "TypeName", '"release"' // 构建类型 &#125; debug &#123; signingConfig signingConfigs.card buildConfigField "boolean", "AssistantEntry", "true" // 是否开启测试入口 buildConfigField "String", "TypeName", '"debug"' // 构建类型 &#125; fortest &#123; signingConfig signingConfigs.card buildConfigField "boolean", "AssistantEntry", "true" // 是否开启测试入口 buildConfigField "String", "TypeName", '"fortest"' // 构建类型 &#125;&#125; 编译后我们可以生成新的 BuildConfig 类，在原来基础上增加了新的字段 AssistantEntry 12345678910public final class BuildConfig &#123; public static final boolean DEBUG = Boolean.parseBoolean("true"); public static final String APPLICATION_ID = "com.showjoy.card"; public static final String BUILD_TYPE = "debug"; public static final String FLAVOR = ""; public static final int VERSION_CODE = 98; public static final String VERSION_NAME = "1.0.0"; // Fields from build type: debug public static final boolean AssistantEntry = true;&#125; matchingFallbacks当定义了一个新的 buildType，但是依赖的 library 中并没有该 buildType 会造成编译失败，matchingFallbacks 可以使新定义的 buildType 匹配到 library 中已经存在的 buildType。 比如我新定义了 fortest，我可以使 fortest 匹配 library 中的 release 的 buildType，这样都是用 fortest 类型构建时，使用的就是 library 中 release 类型的代码，他接受的是个数组，按照优先级匹配。 123456789101112buildTypes &#123; release &#123; signingConfig signingConfigs.card &#125; debug &#123; signingConfig signingConfigs.card &#125; fortest &#123; signingConfig signingConfigs.card matchingFallbacks = ['release', 'debug'] &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Weex」Better Weex - 多页面事件交互]]></title>
    <url>%2Farticle%2F93c948f2%2F</url>
    <content type="text"><![CDATA[Weex 本身的设计初衷是单页面应用，本身不具有多页面之间通信的能力，但因为客户端应用的特殊性，多页面的通信需求十分常见，比如我在设置页面更新了用户数据，同时需要刷新首页等场景，当遭遇这些场景时，多页面的事件交互就会变得非常吃力。 为了实现多页面通信的需求，参考 Android 中一个比较著名、比较成熟的基于事件总线的通信类库 EventBus 的设计原理，对 Weex 事件机制进行扩展。 BroadcastChannel在 Weex 中有一个 BroadcastChannel 的 API 用来实现页面间的通信，在原生部分使用 WebSocketModule 实现，不过经过实验发现，注册和发送没有什么大问题，不过在取消注册这块做的有漏洞，出现多次页面销毁但是无法取消对事件监听的情况（可能是当时尝试的时候版本低一些），主要是因为 module 的生命周期没能和 weex 页面实例更好的绑定起来，而且它是基于 W3C 的标准设计的，也没有实现类似粘滞事件这种功能的支持。 因此我们暂时不考虑使用 BroadcastChannel 实现多页面通信的需求，希望以后他会变得更完善。 globalEvent1const globalEvent = weex.requireModule('globalEvent'); 他是 Weex 中 页面内 通信的接口，是 native 和 weex 通信的通道，可以用一个 key 作为标示符，触发当前 weex 页面中对 key 事件感兴趣的的方法，关于 weex 相关的内容这里不细说。 1((WXSDKInstance)instance).fireGlobalEventCallback(key, params) 前面说过了，他是负责 native 和 weex 通信的，我们姑且叫他 页面内 通信，因为 weex 和 native 是完全分离的，当我们想在 native 部分向 weex 发送事件和数据，就需要依赖该接口，比如，在页面 resume 时，也通知 weex 一个 resume 事件，让 weex 也可以察觉这一时机。 实现多页面通信实现原理类似 EventBus，关于 EventBus 的源码解析，可以参考这篇博客，因为我们是基于 Weex 进行设计，可以借助 Weex 已经存在的数据和 API，所以实现起来要简单一些。 关于注册表的维护，在 EventBus 中是用列表存储了订阅者的强引用，通过注册和反注册的方法从列表中增加和删除，这样一来因为我们需要存储每个对象的引用，占据内存空间大，而且容易内存泄漏，好在 Weex 每个 Weex 页面渲染后都会唯一生成一个 instanceId，所以我们只要维护一个 instanceId 的列表，然后在事件发送时动态检索对应的 Weex 实例，而 Weex 实例的维护还是交给 WeexSDK 去管理，就简单和稳定很多。 关于事件的发送，在 EventBus 中需要遍历注册表，找到对应接受者然后执行他的方法，而在 Weex 中，我们拿到 Weex 实例后借助 globalEvent 发送事件的方法将事件发送到 Weex 即可。 因此，首先我们会维护一个 event - instanceId 的注册表，它的意义是 事件 - 对该事件感兴趣的Weex实例列表 的映射，每个 event 后面跟着一个 Set&lt;instanceId&gt; 里面存储了对该 Event 页面感兴趣的 Weex 实例，比如 事件 updateUser，对该事件感兴趣的页面有 A(instanceId = 132) 页面，B(instanceId = 133) 页面，C(instanceId = 135) 页面。 1private val mEventInstanceIdMap by lazy &#123; mutableMapOf&lt;String, MutableSet&lt;String&gt;&gt;() &#125; 注册事件我们需要在 Module 中增加注册方法，供 Weex 调用，调用方法大致如下： 1234const event = weex.requireModule('event');event.registerEvent('updateUser',(data) =&gt; &#123; // get user data&#125;); 当 Weex 那边发起注册时，根据 event 拿到对应的 instanceId 列表，并将当前页面的 instanceId 存入列表中，完成 事件-Weex实例 的映射。 1234567fun registerEvent(event: String?, instantId: String?) &#123; // check... val nonNullEvent = event ?: return val registerInstantIds = mEventInstanceIdMap[nonNullEvent] ?: mutableSetOf() registerInstantIds.add(instantId) mEventInstanceIdMap[nonNullEvent] = registerInstantIds&#125; 发送事件同样需要在 Module 中提供接口方法，大致如下： 12const event = weex.requireModule('event');event.postEvent('updateUser', &#123; data: user &#125;); 发送事件时，根据 event 拿到关注该事件的 instanceId 列表，循环从 WeexSDK 中取出真正的 WXSDKInstance 对象，再利用 globalEvent 将事件发送给 Weex，达到页面间通信的目的。 123456789101112131415161718192021fun postEvent(event: String, params: Map&lt;String, Any&gt;) &#123; if (WXSDKManager.getInstance() == null) &#123; log("post event WXSDKManager.getInstance() == null") return &#125; val renderManager = WXSDKManager.getInstance().wxRenderManager if (renderManager == null) &#123; log("post event WXSDKManager.getInstance().wxRenderManager == null") return &#125; val registerInstantIds = mEventInstanceIdMap[event] ?: listOf&lt;String&gt;() val allInstants = renderManager.allInstances for (instance in allInstants) &#123; // 该事件被该 instant 注册过 if (instance != null &amp;&amp; !instance.instanceId.isNullOrEmpty() &amp;&amp; registerInstantIds.contains(instance.instanceId)) &#123; instance.fireGlobalEventCallback(event, params) &#125; &#125;&#125; 取消注册我们需要在 Module 中增加接口方法，供 Weex 调用，调用方法大致如下： 12const event = weex.requireModule('event');event.unRegisterEvent('updateUser'); 当页面销毁时，或者使用者人为触发反注册事件时，会将该页面的 instantceId 移除掉，那么该页面将不会再接受到事件通知。 这里多做了一次校验，当不传入 event 时，将会删除当前页面注册的所有事件，而当 event 指定时，会从关注该 event 的 instanceId 列表中将本页面 instanceId 删除。 1234567891011121314fun unRegisterEvent(event: String?, instanceId: String?) &#123; val nonNullId = instanceId ?: return if (event.isNullOrBlank()) &#123; // 删除本页面所有的事件 for (mutableEntry in mEventInstanceIdMap) &#123; if (mutableEntry.value.isNotEmpty()) &#123; mutableEntry.value.remove(nonNullId) &#125; &#125; &#125; else &#123; // 删除本页面的指定事件 val mutableSet = mEventInstanceIdMap[event] mutableSet?.remove(nonNullId) &#125; 粘滞事件考虑到在 Weex 使用场景不多，暂时没有实现]]></content>
      <categories>
        <category>weex</category>
      </categories>
      <tags>
        <tag>weex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rxjava2.x开发-n-Backpressure-todo]]></title>
    <url>%2Farticle%2F2a4b463b%2F</url>
    <content type="text"><![CDATA[本文主要记录总结背压的相关知识。 当上游发送的事件的速度很快，下游处理事件的速度很慢，就会出现背压，这很好理解，就好比一条水管，上游水流量太大，下游水流量太小，上游送过来的水下游不能及时输出，就会产生压力，这就是背压。 背压是指在异步场景中，被观察者发送事件速度远快于观察者的处理速度的情况下，一种告诉上游的被观察者降低发送速度的策略 本来想写一段程序触发一下 MissingBackpressureException ，结果没成功。 在 RxJava2.x 中 Observable 是默认不支持背压的，而 Flowable 是支持背压的。]]></content>
      <categories>
        <category>Android</category>
        <category>Library</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Library</tag>
        <tag>RxJava2.x</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信32Kb图片压缩方案[微信]]]></title>
    <url>%2Farticle%2Fd5d0a5d2%2F</url>
    <content type="text"><![CDATA[网络上关于如何针对图片进行有效合理的压缩其实已经有很多成熟的解决方案了，我这里要说的是针对微信 32KB 限制的压缩方案，这也是在 SocialSdkLibrary 中采用的，经过了很多细节的测试，当然这可能不是最好的方法，欢迎一起讨论。 假如希望得到一个大小为 maxSize 大小的图片，整个压缩过程分为如下几个步骤： 获取图片的宽高，这个很简单使用 options.inJustDecodeBounds 可以实现。 利用 bitmap 的宽高，通过 w*h &lt; maxSize 为标准大致计算目标图片宽高，这里的计算是不精确的 使用近似的目标宽高 decode 目标图片，经过此步之后拿到的 bitmap 会稍微大于 maxSize。 细节调整，利用 matrix.scale 每次缩小为原来的 0.9，循环逼近目标大小。 计算原始宽高这里就是最基本的方法，但是因为流程的完整，还是记录下。 1234567891011public static Size getBitmapSize(String filePath) &#123; // 仅获取宽高 BitmapFactory.Options options = new BitmapFactory.Options(); // 该属性设置为 true 只会加载图片的边框进来，并不会加载图片具体的像素点 options.inJustDecodeBounds = true; BitmapFactory.decodeFile(filePath, options); // 获得原图的宽和高 int outWidth = options.outWidth; int outHeight = options.outHeight; return new Size(outWidth, outHeight);&#125; 计算近似宽高首先说一下为什么要有这一步： 为了尽量少的占用内存，我们获取的图片只是用来在打开微信时展现一个缩略图，而实际的图片大小是无法预估的，不能盲目拿到内存中，因此我们要先计算一个大致的尺寸； 最后一步中，我们将会采用循环压缩的方式逼近目标大小，先进行这步压缩，也是为了减少最后循环的次数； 这一步骤的目标就是获取到一个稍微大于 32KB 的图片，后面再进行细节微调。 那么接下来如何计算一个合适的宽高，我们简单的这样约束 32kb = w * h，虽然这样并不完全合理，因为最终 byte[] 的长度和宽高并没有绝对的关系，不过之前也说过了，这步是不精确的，目标是一个大于稍微 32KB 的 bitmap; 于是可以得到如下关系，为了好理解，就用汉字标识： 12345比例(&gt;1) = 较长边 / 较短边32KB = 较短边 * 较长边32KB = 较短边 * 较短边 * 比例(&gt;1)较短边 = sqrt(maxSize/比例(&gt;1))较长边 = 较短边 * 比例(&gt;1) 经过上面的关系，可以按照比例计算出 较短边 和 较长边，代码如下，简单看下： 123456789101112131415161718192021222324252627282930313233343536373839/** * 根据kb计算缩放后的大约宽高 * * @param originSize 图片原始宽高 * @param maxSize byte length * @return 大小 */private static Size calculateSize(Size originSize, int maxSize) &#123; int bw = originSize.width; int bh = originSize.height; Size size = new Size(); // 如果本身已经小于，就直接返回 if (bw * bh &lt;= maxSize) &#123; size.width = bw; size.height = bh; return size; &#125; // 拿到大于1的宽高比 boolean isHeightLong = true; float bitRatio = bh * 1f / bw; if (bitRatio &lt; 1) &#123; bitRatio = bw * 1f / bh; isHeightLong = false; &#125; // 较长边 = 较短边 * 比例(&gt;1) // maxSize = 较短边 * 较长边 = 较短边 * 较短边 * 比例(&gt;1) // 由此计算短边应该为 较短边 = sqrt(maxSize/比例(&gt;1)) int thumbShort = (int) Math.sqrt(maxSize / bitRatio); // 较长边 = 较短边 * 比例(&gt;1) int thumbLong = (int) (thumbShort * bitRatio); if (isHeightLong) &#123; size.height = thumbLong; size.width = thumbShort; &#125; else &#123; size.width = thumbLong; size.height = thumbShort; &#125; return size;&#125; 第一次采样获取目标图片拿到目标尺寸之后，根据目标尺寸和原始图片尺寸，计算对应的 inSimpleSize，对图片进行第一次的 decode。 同样因为这一步不是一个那么精确的操作，因此对于大小比较小的图片（这里定的是 400*400）就不进行压缩了，怕压的太厉害，其他的就是按照常规的采样获取到一个 bitmap; 需要注意的是由于图片大小和图片尺寸没有绝对的关系，所以要给一个更高的上限，我们在调用 calculateSize() 使用的不是 32KB，而是用了他的 5 倍，这样可以保证图片最终稍微大于 32KB; 123456789101112131415161718192021222324252627282930/** * 使用 path decode 出来一个差不多大小的，此时因为图片质量的关系，可能大于kbNum * * @param filePath path * @param maxSize byte * @return bitmap */public static Bitmap getMaxSizeBitmap(String filePath, int maxSize) &#123; Size originSize = getBitmapSize(filePath); int sampleSize = 0; // 我们对较小的图片不进行采样，因为采样只是尽量接近 32k 和避免占用大量内存 // 对较小图片进行采样会导致图片更模糊，所以对不大的图片，直接走后面的细节调整 if (originSize.height * originSize.width &lt; 400 * 400) &#123; sampleSize = 1; &#125; else &#123; Size size = calculateSize(originSize, maxSize * 5); while (sampleSize == 0 || originSize.height / sampleSize &gt; size.height || originSize.width / sampleSize &gt; size.width) &#123; sampleSize += 2; &#125; &#125; BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = false; options.inSampleSize = sampleSize; options.inMutable = true; Bitmap bitmap = BitmapFactory.decodeFile(filePath, options); LogUtils.e(TAG, "sample size = " + sampleSize + " bitmap大小 = " + bitmap.getByteCount()); return bitmap;&#125; 循环逼近目标大小此时我们拿到了一个大小稍微大于 32KB 的 bitmap，接下来需要循环压缩该 bitmap 使最终得到 byte[] 小于 32KB; 这里使用 Matrix 的 setScale() 方法，每次将图片缩小为原来的 0.9，并且不断检测大小，直到达到标准。 1234567891011121314151617181920212223242526public static byte[] getStaticSizeBitmapByteByBitmap(Bitmap srcBitmap, int maxSize, Bitmap.CompressFormat // 首先进行一次大范围的压缩 Bitmap tempBitmap; ByteArrayOutputStream output = new ByteArrayOutputStream(); // 设置矩阵数据 Matrix matrix = new Matrix(); srcBitmap.compress(format, 100, output); // 如果进行了上面的压缩后，依旧大于32K，就进行小范围的微调压缩 byte[] bytes = output.toByteArray(); LogUtils.e(TAG, "压缩之前 = " + bytes.length); while (bytes.length &gt; maxSize) &#123; matrix.setScale(0.9f, 0.9f);//每次缩小 1/10 tempBitmap = srcBitmap; srcBitmap = Bitmap.createBitmap( tempBitmap, 0, 0, tempBitmap.getWidth(), tempBitmap.getHeight(), matrix, true); recyclerBitmaps(tempBitmap); output.reset(); srcBitmap.compress(format, 100, output); bytes = output.toByteArray(); LogUtils.e(TAG, "压缩一次 = " + bytes.length); &#125; LogUtils.e(TAG, "压缩后的图片输出大小 = " + bytes.length); recyclerBitmaps(srcBitmap); return bytes;&#125; 最后测试图片压缩的结果： 1234567891011121314151617181920212223242526272829303132333435测试图片大小 14.58M 原始图片大小 = 8000 * 4160 目标图片大小 = 559 * 291 sample size = 16 采样后 bitmap大小 = 520000 开始循环压缩之前 bytes = 143255 压缩一次 bytes = 110424 压缩一次 bytes = 86231 压缩一次 bytes = 66464 压缩一次 bytes = 53433 压缩一次 bytes = 42418 压缩一次 bytes = 34061 压缩一次 bytes = 26745 压缩后的图片输出大小 bytes = 26745测试图片大小 388.16KB 原始图片大小 = 479 * 850 目标图片大小 = 303 * 537 sample size = 2 采样后 bitmap大小 = 406300 开始循环压缩之前 bytes = 56926 压缩一次 bytes = 47832 压缩一次 bytes = 39200 压缩一次 bytes = 31752 压缩后的图片输出大小 bytes = 31752测试图片为 2.39M 原始图片大小 = 2160 * 3840 目标图片大小 = 303 * 538 sample size = 8 采样后 bitmap大小 = 518400 开始循环压缩之前 bytes = 92282 压缩一次 bytes = 73441 压缩一次 bytes = 58790 压缩一次 bytes = 47730 压缩一次 bytes = 39083 压缩一次 bytes = 31457 压缩后的图片输出大小 bytes = 31457 可以看到当图片很大时，会造成压缩次数过多，而且出来的图片被压缩的更厉害，而平常更常见的网络图（通常几百K）拍摄图（通常2-4M）可以达到不错的压缩效果。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「源码」看看 EventBus]]></title>
    <url>%2Farticle%2F4e49ab58%2F</url>
    <content type="text"><![CDATA[EventBus 是基于观察者模式的发布/订阅事件总线，它让组件间的通信变得更加简单。类似广播系统，不过 EventBus 所有的订阅和发送都是在内存层面的，使用起来远比广播简单，也更容易管理。 先说明在事件总线中的几个关键词： 事件发送者，发出事件的人 订阅者，处理事件的人 订阅者中处理事件的方法，因为每个订阅者感兴趣的事件有多种，因此会有多个处理事件的方法 订阅，是一个名词，指的是一种关系，一个订阅指的是某个订阅者中的处理某个事件的方法，由订阅者和事件类型唯一确定。 订阅事件注册当希望接受到事件时，需要在 onCreate() 执行 register() 方法，这里的 subscriber 通常是我们的 activity，在注册方法中会检索当前类的 Class 中声明的接受事件的方法，并将他们注册到对应的映射中。 123456789public void register(Object subscriber) &#123; Class&lt;?&gt; subscriberClass = subscriber.getClass(); List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod); &#125; &#125;&#125; 内存中存储的数据结构有如下几个： 123456// 事件 - List&lt;订阅(Subscription)&gt; 每个订阅由订阅者、事件类型唯一确定private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;// 订阅者 - List&lt;关注的事件&gt; 每个订阅者可能关注多个事件private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;// 事件对应下的粘滞事件private final Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents; 查找订阅方法列表当执行 register() 方法时，会借助 SubscriberMethodFinder 类从注册的对象的 Class 中查找。 123456789101112131415161718192021List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123; // 从缓存中找是否已经检索过了，有缓存就直接返回 List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass); if (subscriberMethods != null) &#123; return subscriberMethods; &#125; // 是否忽略索引功能，忽略的话会直接使用反射的方法搜索，否则会检测有没有相关的索引可以使用 if (ignoreGeneratedIndex) &#123; subscriberMethods = findUsingReflection(subscriberClass); &#125; else &#123; // 支持索引的情况，会优先从索引中查找，加快查找的速度 subscriberMethods = findUsingInfo(subscriberClass); &#125; if (subscriberMethods.isEmpty()) &#123; // 没有找到任何的订阅方法将会抛出异常，所以至少要用注解订阅一个方法 &#125; else &#123; // 针对这个 class 查找到订阅的方法列表，存缓存，下次更快的返回 METHOD_CACHE.put(subscriberClass, subscriberMethods); return subscriberMethods; &#125;&#125; 因为我们不考虑索引的情况，最终查找方法都会走到方法 findUsingReflectionInSingleClass，内部的原理相对简单，遍历该类的所有方法，找到共有的、只有一个参数、且带有 @Subscribe 注解的方法，存储到列表中。 1234567891011121314151617181920212223242526private static final int MODIFIERS_IGNORE = Modifier.ABSTRACT | Modifier.STATIC | BRIDGE | SYNTHETIC;private void findUsingReflectionInSingleClass(FindState findState) &#123; Method[] methods; methods = findState.clazz.getDeclaredMethods(); for (Method method : methods) &#123; int modifiers = method.getModifiers(); // 共有的方法 &amp; 不是静态、抽象、不是编译生成的方法 if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123; Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); // 参数长度只能是1 if (parameterTypes.length == 1) &#123; Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class); // 方法上面带有 @Subscribe 注解 if (subscribeAnnotation != null) &#123; Class&lt;?&gt; eventType = parameterTypes[0]; if (findState.checkAdd(method, eventType)) &#123; ThreadMode threadMode = subscribeAnnotation.threadMode(); findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(), subscribeAnnotation.sticky())); &#125; &#125; &#125; &#125; &#125;&#125; 这个过程是一个循环，每次都会向上查找当前类的父类，知道到达 java 内置的类中，这就意味着，父类中声明的订阅方法，在子类实例中也会接收到。查找的结果最终会生成一个 SubscriberMethod 的列表，这个类中存储了订阅方法的全部信息，数据结构如下： 12345678public class SubscriberMethod &#123; final Method method; // 当前的方法，可执行 final ThreadMode threadMode; // 线程类型 final Class&lt;?&gt; eventType; // 参数的类型，也就是他订阅的事件的类型 final int priority; // 优先级 final boolean sticky; // 是否是粘滞事件 String methodString; // 方法的字符串&#125; 订阅到映射中1234// 事件 - List&lt;订阅(Subscription)&gt; 每个订阅由订阅者、事件类型唯一确定private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;// 订阅者 - List&lt;关注的事件&gt; private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber; 订阅的过程就是根据订阅者 Subscriber 及该订阅者的某个处理事件的方法 SubscriberMethod 来生成 Subscription 并且存储到映射当中。 123456789101112131415161718private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123; // 存储到 事件 - List&lt;订阅&gt; 映射中 Class&lt;?&gt; eventType = subscriberMethod.eventType; Subscription newSubscription = new Subscription(subscriber, subscriberMethod); CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); // ... 不存在则创建新的 int size = subscriptions.size(); for (int i = 0; i &lt;= size; i++) &#123; if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123; subscriptions.add(i, newSubscription); break; &#125; &#125; // 存储到 订阅者 - List&lt;关注的事件&gt; 映射中 List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber); // ... 不存在则创建新的 subscribedEvents.add(eventType); // ... // 对 Sticky Event 的处理，后面单独说&#125; 取消注册由于事件总线的机制基于内存实现，所有的订阅都会存储在内存中，因此必须在合适的时机取消注册，来释放占用的内存空间。 当取消注册时： 借助之前存储的 订阅者-List&lt;关注事件&gt; 的映射快速的获取到，当前订阅者感兴趣的事件列表。 然后遍历事件列表，从 事件-List&lt;订阅&gt; 的映射中，删除所有的订阅。 最后将当前订阅者从 订阅者-List&lt;关注事件&gt; 删除，完成取消订阅的过程。 获取当前订阅者关注的全部事件，遍历取消注册。 123456789101112131415161718192021222324252627public synchronized void unregister(Object subscriber) &#123; List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber); if (subscribedTypes != null) &#123; for (Class&lt;?&gt; eventType : subscribedTypes) &#123; unsubscribeByEventType(subscriber, eventType); &#125; typesBySubscriber.remove(subscriber); &#125; else &#123; &#125;&#125;// 从订阅列表中删除对应的订阅private void unsubscribeByEventType(Object subscriber, Class&lt;?&gt; eventType) &#123; List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); if (subscriptions != null) &#123; int size = subscriptions.size(); for (int i = 0; i &lt; size; i++) &#123; Subscription subscription = subscriptions.get(i); if (subscription.subscriber == subscriber) &#123; subscription.active = false; subscriptions.remove(i); i--; size--; &#125; &#125; &#125;&#125; 发送事件当需要发送事件使用 EventBus 的 post() 方法。 借助 ThreadLocal 每个线程单独维护一个、且仅一个 PostingThreadState 对象，这个对象的数据结构如下, 内部存储了当前发送事件状态的的一些关键信息。 12345678final static class PostingThreadState &#123; final List&lt;Object&gt; eventQueue = new ArrayList&lt;Object&gt;(); // 事件队列 boolean isPosting; // 是否正在发送事件，是的话不需要启动循环读取事件 boolean isMainThread; // 是否是主线程 Subscription subscription; // 一个订阅 Object event; // 当前的事件 boolean canceled; // 是否被取消&#125; 获取本线程的 PostingThreadState 对象，进行初始化，并开始轮询处理队列中的事件。 123456789101112131415161718public void post(Object event) &#123; PostingThreadState postingState = currentPostingThreadState.get(); List&lt;Object&gt; eventQueue = postingState.eventQueue; eventQueue.add(event); if (!postingState.isPosting) &#123; postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper(); postingState.isPosting = true; try &#123; // 从队列中循环读取事件处理 while (!eventQueue.isEmpty()) &#123; postSingleEvent(eventQueue.remove(0), postingState); &#125; &#125; finally &#123; postingState.isPosting = false; postingState.isMainThread = false; &#125; &#125;&#125; 继续往深里面看 postSingleEvent() 方法，他每次处理一个从队列中取出来的事件，这里做了一个区分，是否支持继承，这个值默认是 true，支持继承时，如果对当前事件的父类、接口对应的事件感兴趣，那么他也可以处理该事件。例如当前要处理 A 事件，A 继承自 B，同时实现 C 接口，能处理 B,C 事件的订阅者将也会参与处理此 A 事件。 123456789101112131415161718private void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123; Class&lt;?&gt; eventClass = event.getClass(); boolean subscriptionFound = false; if (eventInheritance) &#123; // 向父类搜索，将父类、接口全部查找到 List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass); int countTypes = eventTypes.size(); for (int h = 0; h &lt; countTypes; h++) &#123; Class&lt;?&gt; clazz = eventTypes.get(h); subscriptionFound |= postSingleEventForEventType(event, postingState, clazz); &#125; &#125; else &#123; subscriptionFound = postSingleEventForEventType(event, postingState, eventClass); &#125; if (!subscriptionFound) &#123; // 没有找到订阅的方法，处理分支 &#125;&#125; 事件订阅者排队处理接下来会走 postSingleEventForEventType() 方法，这个方法负责找到对这个事件感兴趣的 订阅 Subscription 列表， Subscription 里面包含了订阅者、处理对应事件的方法等信息。 拿到列表之后便循环将事件给列表中的订阅依次处理，在之前注册时，是有一个优先级别的，优先级高的将会先获得处理事件的权利。 优先级别较高的处理者可以停止事件的传递，只需要抛出一个异常，被 finally 块捕捉后，就会中断轮询，从而终止事件的传递。 123456789101112131415161718192021222324252627282930private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; CopyOnWriteArrayList&lt;Subscription&gt; subscriptions; synchronized (this) &#123; subscriptions = subscriptionsByEventType.get(eventClass); &#125; // 遍历所有的订阅，处理事件 if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) &#123; for (Subscription subscription : subscriptions) &#123; postingState.event = event; postingState.subscription = subscription; boolean aborted = false; try &#123; // 让 subscription 处理 event postToSubscription(subscription, event, postingState.isMainThread); aborted = postingState.canceled; &#125; finally &#123; // 如果优先级别较高的处理者异常，则后续处理者将无法处理该事件 postingState.event = null; postingState.subscription = null; postingState.canceled = false; &#125; // 退出轮询 if (aborted) &#123; break; &#125; &#125; return true; &#125; return false;&#125; 分发线程处理者执行处理事件的最后一步，是 postToSubscription() 他负责将事件的处理分发到不同的线程队列中，在添加订阅注解 @Subscribe 时可以指定 threadMode，这极大的方便了我们在事件传递后切换不同线程处理事件，例如我们常常要在子线程处理数据，而通知主线程更新 UI，使用 EventBus 只需要指定 @Subscribe(threadMode=ThreadMode.Main) 则在处理事件时所有操作在内部便被切换到了主线程，真正做到了对线程切换的无感知。 分为了如下几种类型： POSTING 发送线程，或者说是当前线程更贴切一些，在其他类库中通常叫 Immediate， 也就是不用切换线程。 MAIN 主线程，不解释。 BACKGROUND 后台线程，如果发送线程是主线程，则开辟新的线程执行，否则将在当前线程执行。 ASYNC 异步线程，无论怎样，总是开启新的子线程去执行。 这里就要看一下几个处理者 HandlerPoster/BackgroundPoster/AsyncPoster 实现原理大致相同，内部维护一个队列，不停的把里面的事件取出来处理。 HandlerPoster 是基于 Handler 实现对队列的轮询。 BackgroundPoster 则是用死循环来做的，谁让人家有自己的线程呢。 AsyncPoster 就更富了，根本不轮询，每次都是一个新的线程。 123456789101112131415161718192021222324private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123; switch (subscription.subscriberMethod.threadMode) &#123; case POSTING: invokeSubscriber(subscription, event); break; case MAIN: if (isMainThread) &#123; invokeSubscriber(subscription, event); &#125; else &#123; mainThreadPoster.enqueue(subscription, event); &#125; break; case BACKGROUND: if (isMainThread) &#123; backgroundPoster.enqueue(subscription, event); &#125; else &#123; invokeSubscriber(subscription, event); &#125; break; case ASYNC: asyncPoster.enqueue(subscription, event); break; &#125;&#125; 最终调用的 invokeSubscriber() 很简单就是利用反射调一下对应的 method 1subscription.subscriberMethod.method.invoke(subscription.subscriber, event); 粘滞事件的实现我把 Sticky Event 翻译成 粘滞事件 不知道对不对，他的出现主要是因为我们需要处理事件是总是要先注册再发送事件，根本原因在于当一个事件发出时，他的生命周期很短，所有对他感兴趣的订阅者处理完了之后他就被抛弃了，后面的订阅者再感兴趣也没用，因为早就被清理啦。 要解决这个问题也很简单，就是延长事件的生命周期，即使大家都不理他了，他也能顽强的活着，万一后面还有人对他感兴趣呢。所以实现的原理也就很明了了，找个列表把它全部存起来，除非你手动给删除，否则就 粘不拉几 的附着在你的内存里，等着他的真命天子出现。 123456789// 事件类型 - 事件实例private final Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;// 发送粘滞事件时，先存起来给后面的人用，然后按照常规流发送出去public void postSticky(Object event) &#123; synchronized (stickyEvents) &#123; stickyEvents.put(event.getClass(), event); &#125; post(event);&#125; 还要提供一个渠道，让新加入进来的订阅者能够察觉到这里有粘滞事件的存在，如果感兴趣也可以处理它。这个时机就是注册时，当一个订阅者被添加到注册表中时，此时如果存在粘滞事件，用当前订阅者感兴趣的事件为 key 获取存在的粘滞事件，如果有感兴趣的就临幸一下。于是可以完善一下之前未说完的 register() 方法： 首先要求当前订阅者的处理事件的方法要对粘滞事件感兴趣，这个在注解上可以声明。 继承，如果支持继承，当前事件的子类粘滞事件都会被取出来检查是否可以被处理。 123456789101112131415161718192021private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123; // ... 前面这块说过了 // 这个订阅者的这个订阅方法是对粘滞事件感兴趣的 if (subscriberMethod.sticky) &#123; // 事件是否继承 if (eventInheritance) &#123; Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet(); // 当前事件的子类粘滞事件都会被取出来检查是否可以被处理 for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123; Class&lt;?&gt; candidateEventType = entry.getKey(); if (eventType.isAssignableFrom(candidateEventType)) &#123; Object stickyEvent = entry.getValue(); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; else &#123; Object stickyEvent = stickyEvents.get(eventType); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125;&#125; 接下来的 checkPostStickyEventToSubscription() 就会调用前面已经说过的 postToSubscription() 方法，开始发送到不同的线程中执行，这部分和普通的事件是一样的啦。 理解事件的继承粘滞事件这里也出现了一个关于事件继承的检索，在上一节也出现了一次，单独拿出来说一下异同之处。 可以类比函数入参的限制，如果一个方法声明中参数是父类，那么传参时可以传递子类对象进去，声明了子类的话，是不能传递父类对象的。 举个例子，设定下场景，我们现在有事件基类 BaseEvent 和一个事件子类 ImplEvent 是继承关系。 第一种场景，发送普通事件，我发送了一个 ImplEvent，因为我发的是个子类事件，也就是说所有声明关注 BaseEvent 的订阅者也都可以将当前事件作为入参，所以向上检索对 ImplEvent 父类、父接口感兴趣的订阅者去执行。 第二个场景，发送粘滞事件，发送一个 BaseEvent 的粘滞事件，因为是在注册时触发执行，那么说明当前订阅者对 BaseEvent 感兴趣，既然他的入参是父类事件，那么子类事件也同样可以作为他的处理事件方法的入参，于是检索所有粘滞事件找到所有 BaseEvent 的子类事件都交给当前订阅者处理。 Weex 事件机制在 Weex 中有一个 BroadcastChannel 的 API 用来实现页面间的通信，在原生部分使用 WebSocketModule 实现，不过经过实验发现，注册和发送没有什么大问题，不过在取消注册这块做的有漏洞，出现多次页面销毁但是无法取消对事件监听的情况（可能是当时尝试的时候版本低一些），主要是因为 module 的生命周期没能和 weex 页面实例更好的绑定起来，而且它是基于 W3C 的标准设计的，也没有实现类似粘滞事件这种功能的支持。 最后决定根据事件总线的机制来尝试实现页面之间的通信，在 Weex 中有一个 页面内 通信的接口，他是 native 和 weex 通信的通道，可以用一个 key 作为标示符，触发当前 weex 页面中对 key 事件感兴趣的的方法，关于 weex 相关的内容这里不细说。 1((WXSDKInstance)instance).fireGlobalEventCallback(key, params) 实现原理类似 EventBus，不过因为基于 weex 就没那么复杂，同样需要维护一个注册表，相对于 EventBus 要对订阅者强引用持有，这里使用了每个 weex 页面唯一的 instanceId 作为标记，存储这个标记而不是存储真正的 WXSDKInstance 对象，避免内存泄漏。 1private val mEventInstanceIdMap by lazy &#123; mutableMapOf&lt;String, MutableSet&lt;String&gt;&gt;() &#125; 注册，当 weex 那边发起注册时，拿到对应的 instanceId 存储到映射中。 12345678910// 注册接受某事件// event.registerEvent('myEvent')// globalEvent.addEventListener('myEvent', (params) =&gt; &#123;&#125;);fun registerEvent(key: String?, instantId: String?) &#123; // do check... val nonNullKey = key ?: return val registerInstantIds = mEventInstanceIdMap[nonNullKey] ?: mutableSetOf() registerInstantIds.add(instantId) mEventInstanceIdMap[nonNullKey] = registerInstantIds&#125; 发送事件时，根据事件的 key 拿到对他关注的订阅者的 instanceId 列表，循环从 weex sdk 中取出真正的 WXSDKInstance 对象，再利用页面内通信的 API 将事件发送给指定页面，达到页面间通信的目的。 123456789101112131415// 发送事件// event.post('myEvent',&#123;isOk:true&#125;);fun postEvent(key: String, params: Map&lt;String, Any&gt;) &#123; // do check... val registerInstantIds = mEventInstanceIdMap[key] ?: listOf&lt;String&gt;() val allInstants = renderManager.allInstances for (instance in allInstants) &#123; // 遍历找到订阅的 instanceId 进而拿到 weex 实例发送页面内事件 if (instance != null &amp;&amp; !instance.instanceId.isNullOrEmpty() &amp;&amp; registerInstantIds.contains(instance.instanceId)) &#123; instance.fireGlobalEventCallback(key, params) &#125; &#125;&#125; 当页面销毁时，同时自动取消注册，释放内存和避免不必要的事件触发 12345678override fun onWxInstRelease(weexPage: WeexPage?, instance: WXSDKInstance?) &#123; val nonNullId = instance?.instanceId ?: return for (mutableEntry in mEventInstanceIdMap) &#123; if (mutableEntry.value.isNotEmpty()) &#123; mutableEntry.value.remove(nonNullId) &#125; &#125;&#125; 最后，目前只是一个简单的实现，能够基本实现页面间通信的需求，不过还需要更多地调研和其他端同学的配合，相信会越来越完善。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SourceCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Glide-平滑加载的图片框架 [源码]]]></title>
    <url>%2Farticle%2F47636f69%2F</url>
    <content type="text"><![CDATA[本文按照 Glide 常用的如下用法来分析源码： 1Glide.with(context).load("url").thumbnail().into(imageView); 根据上面的代码，将内容分为以下几个章节： Glide - 强大的顶层管理类 Glide.with() - 创建及缓存 RequestManager .load(url) - 创建 RequestBuilder .thumbnail() - 配置 RequestBuilder .into(target) - 发起 Request 开始加载资源 缓存和数据源 数据转换 总结 强大的 GlideGlide 是一个单例对象，在这个框架中功能相对复杂，每个功能都由对应的类实现，但是他们都被 Glide 类统一管理，Glide 的构造方法很长，主要是初始化一些内部持有的管理类，类比来看的 Glide 就类似高级管理阶层，下属还有很多次级管理层。 简单看一下重要的成员变量： 123456789Glide.javaGenericLoaderFactory loaderFactory; // 工厂管理类，负责 ModelLoader 的注册和缓存实现TranscoderRegistry transcoderRegistry = new TranscoderRegistry(); // ResourceTranscoder 工厂管理类DataLoadProviderRegistry dataLoadProviderRegistry; // DataLoadProvider 注册管理Engine engine; // 负责从内存缓存、文件缓存、数据源中获取资源BitmapPool bitmapPool; // 用来控制复用 Bitmap 的内存空间MemoryCache memoryCache; // Lru 内存缓存 Glide.with() Glide.with() 方法将会返一个 RequestManager 对象。 在讨论 Glide.with() 之前，先来关注一下两个比较重要的点： 借助 Fragment 同步与宿主 Activity 的生命周期及内存管理。 RequestManager 的创建和缓存 借助 Fragment当加载图片时，我们需要时刻观察宿主 Activity 的状态： 结合生命周期，对后台线程做一些耗时操作，比如网络请求、IO 流、图片的编解码等，在适当的时机进行暂停、重启或销毁操作； 关注内存变化，当回调 onTrimMemory() 等内存回收方法时，框架内部能够感知到； 需要做到这些，就需要在 Activity 的各种方法中调用框架对应的方法，但是这样造成很强的耦合，使用起来会变的很繁琐，不过 Glide 使用了一种比较巧妙的办法那就是在对应的 Activity 中添加一个空的 Fragment，这个 Fragment 不会绘制任何 UI，但是由于 Fragment 和 Activity 的特殊关系，当这个 Fragment 被添加到 Activity 中时，他的生命周期就与 Activity 的生命周期同步了，内部只需要关注 Fragment 的生命周期即可，而对外是完全封闭的。 在 Glide 内部提供了 RequestManagerFragment 和 SupportRequestManagerFragment 对 v4.Fragment 做了兼容，他们主要关注的是如下方法： 12345678910// 生命周期方法onAttach()onDetach()onStart()onStop()onDestroy()// 内存不足回调onTrimMemory(int level)onLowMemory() RequestManager 的缓存在 Fragment 内部持有一个 RequestManager，当 Fragment 的生命周期+内存回收方法被回调时，RequestManager 的对应方法会被调用，从而实现对请求和内存的管理。 我们希望在每个 Activity 中仅有一个 RequestManager 来统一处理，而不是每次都创建一个新的，因此我们要对 RequestManager 做一个缓存，而这个缓存也是借助 Fragment 来实现的，每次向 Activity 中添加 Fragment 时，总会使用唯一的 tag，这样需要使用 RequestManager 时，会先去拿对应 tag 的 Fragment，拿到了说明已经创建过，取出 RequestManager 直接使用，否则创建新的 Fragment(持有 RequestManager)用指定的 tag 添加到 Activity 中，同时拿到 RequestManager。 因为 v4.Fragment 的问题，所有的方法都会有一个 support 的对应方法，以下仅保留关键代码： 1234567891011121314151617181920212223242526272829303132333435363738// RequestManagerRetriever.java// 从 Activity 开始public RequestManager get(Activity activity) &#123; return fragmentGet(activity, fm);&#125;// 从 Fragment 开始public RequestManager get(Fragment fragment) &#123; FragmentManager fm = fragment.getChildFragmentManager(); return supportFragmentGet(fragment.getActivity(), fm);&#125;// 从 Fragment 中取得 RequestManagerRequestManager fragmentGet(Context context, android.app.FragmentManager fm) &#123; RequestManagerFragment current = getRequestManagerFragment(fm); RequestManager requestManager = current.getRequestManager(); if (requestManager == null) &#123; requestManager = new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode()); current.setRequestManager(requestManager); &#125; return requestManager;&#125;// 从 android.app.FragmentManager 获取 Fragment，没有的话会添加新的RequestManagerFragment getRequestManagerFragment(final android.app.FragmentManager fm) &#123; RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG); if (current == null) &#123; current = pendingRequestManagerFragments.get(fm); if (current == null) &#123; current = new RequestManagerFragment(); pendingRequestManagerFragments.put(fm, current); fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss(); handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget(); &#125; &#125; return current;&#125; 所有图片的加载总是以 Glide.with() 方法开始，当调用 Glide.with() 方法时，会借助单例 RequestManagerRetriever 来获取到一个 RequestManager，当然这里不仅仅是单纯的获取、还包括缓存及同步生命周期等，这个在上面已经说过了。 1234public static RequestManager with(Context context) &#123; RequestManagerRetriever retriever = RequestManagerRetriever.get(); return retriever.get(context);&#125; RequestManagerRetriever 是一个单例，他对 RequestManagerFragment 及其内部的 RequestManager 进行管理，Retriever 是猎犬、寻回的意思，RequestManagerRetriever 也就是对 RequestManager 进行寻回，找到已经在使用的 RequestManager，可以说很形象啦。当需要获取 RequestManager 时，借助这条 猎犬 即可，他会给你找回合适的 RequestManager。 RequestManagerRequestManager 主要用来管理请求的发送和停止， 内部有一个 ConnectivityMonitor 它使用 BroadcastReceiver 实现，用于检测网络变化。 12ConnectivityMonitor connectivityMonitor = factory.build(context, new RequestManagerConnectivityListener(requestTracker)); 使用 RequestTracker 来真正的管理请求队列 12private final Set&lt;Request&gt; requests = Collections.newSetFromMap(new WeakHashMap&lt;Request, Boolean&gt;());private final List&lt;Request&gt; pendingRequests = new ArrayList&lt;Request&gt;(); .load(Type param) load(Type param) 将会返回一个 DrawableTypeRequest 对象，他并不是一个真正的 Request，更像一个 RequestBuilder，其实他真的是 GenericRequestBuilder 的子类，是建造者模式的体现，用来进行其他参数的配置。 利用 Glide.with() 此时我们已经获取到了合适的 RequestManager 对象，可以使用 .load() 方法选择加载文件、Uri、网络路径等： 1234567891011121314151617181920RequestManager.javapublic DrawableTypeRequest&lt;String&gt; load(String string) &#123; return (DrawableTypeRequest&lt;String&gt;) fromString().load(string);&#125;public DrawableTypeRequest&lt;String&gt; fromString() &#123; return loadGeneric(String.class);&#125;public DrawableTypeRequest&lt;File&gt; load(File file)&#123;...&#125;public DrawableTypeRequest&lt;File&gt; fromFile()&#123;...&#125;public DrawableTypeRequest&lt;Uri&gt; load(Uri uri)&#123;...&#125;public DrawableTypeRequest&lt;Uri&gt; fromUri()&#123;...&#125;public DrawableTypeRequest&lt;Integer&gt; load(Integer resourceId)&#123;...&#125;public DrawableTypeRequest&lt;Integer&gt; fromResource()&#123;...&#125;public DrawableTypeRequest&lt;byte[]&gt; load(byte[] model)&#123;...&#125;public DrawableTypeRequest&lt;byte[]&gt; fromBytes()&#123;...&#125; 可以看到每种数据类型会对应不同的 load(Type param) 方法，同时又会对应一个 fromType() 方法来构造 DrawableTypeRequest 对象，而他们最终都会使用 loadGeneric() 方法来创建一个 DrawableTypeRequest 12345678910RequestManager.javaprivate &lt;T&gt; DrawableTypeRequest&lt;T&gt; loadGeneric(Class&lt;T&gt; modelClass) &#123; ModelLoader&lt;T, InputStream&gt; streamModelLoader = Glide.buildStreamModelLoader(modelClass, context); ModelLoader&lt;T, ParcelFileDescriptor&gt; fileDescriptorModelLoader = Glide.buildFileDescriptorModelLoader(modelClass, context); return optionsApplier.apply( new DrawableTypeRequest&lt;T&gt;(modelClass, streamModelLoader, fileDescriptorModelLoader, context, glide, requestTracker, lifecycle, optionsApplier));&#125; ModelLoader这里可以看到有 ModelLoader，他负责完成数据转换的功能，例如想要加载网络图片，会提供一个 url 那么就会有一个 ModelLoader 完成 String-&gt; InputStream 的转化，通过网络请求拿到 InputStream。 这里会有更丰富的内容，统一在数据转换一节中讨论，这里需要知道的是他作为 DrawableTypeRequest 的成员，在将来会承担数据转换的工作。 DataLoadProvider在上面我们创建了一个 DrawableTypeRequest，看一下构造方法 123456789101112DrawableTypeRequest(Class&lt;ModelType&gt; modelClass, ModelLoader&lt;ModelType, InputStream&gt; streamModelLoader, ModelLoader&lt;ModelType, ParcelFileDescriptor&gt; fileDescriptorModelLoader, Context context, Glide glide, RequestTracker requestTracker, Lifecycle lifecycle, RequestManager.OptionsApplier optionsApplier) &#123; super(context, modelClass, buildProvider(glide, streamModelLoader, fileDescriptorModelLoader, GifBitmapWrapper.class, GlideDrawable.class, null),glide, requestTracker, lifecycle);&#125;DrawableRequestBuilder(Context context, Class&lt;ModelType&gt; modelClass, LoadProvider&lt;ModelType, ImageVideoWrapper, GifBitmapWrapper, GlideDrawable&gt; loadProvider, Glide glide, RequestTracker requestTracker, Lifecycle lifecycle) &#123;&#125; 发现他需要一个 DataLoadProvider，他也是起到了一个数据转换的作用，不过它是提供编解码器来将 InputStream 等格式转化成 Bitmap 及 GifDrawable 等格式。 这里会有更丰富的内容，统一在数据转换一节中讨论，这里需要知道的是他作为 DrawableTypeRequest 的成员，在将来会承担数据转换的工作。 .thumbnail() .thumbnail() 等配置项都是 GenericRequestBuilder 的成员方法，返回值是 GenericRequestBuilder，达到链式调用的目的。 这里只是用 thumbnial 来代指一系列的配置请求的方法，实际上配置项要更多，大致列举如下： 1234567891011121314151617181920212223242526272829303132333435// 控制图片尺寸thumbnail(float size) // 0-1,先加载缩略图，内部实现是创建一个新的 thumbnailRequestsizeMultiplier(float size) // 0-1，控制加载图片的大小，和缩略图有本质区别override() // 加载指定大小图片// 编解码器encoder()cacheDecoder()decoder()sourceEncoder()// 缓存策略和优先级diskCacheStrategy() // 磁盘缓存策略priority() // 请求的优先级别，缩略图的优先级总会比原图高一些skipMemoryCache() // 跳过内存缓存// 变换和动画transform() // 对图片进行变化，比如圆形裁剪dontTransform() // 去掉变换效果transcoder()animate() // 加载动画dontAnimate() // 去掉加载动画// 占位图placeholder() // 加载时占位图fallback() // 资源为null时的占位图，没有将会使用 errorerror() // 加载失败占位图// 其他listener() // 加载监听signature() // 唯一标记// 加载preload() // 提前加载准备资源到内存中，下次使用时速度会快into() // 加载到指定 target 以上的一系列方法都是一些配置项，调用之后作为参数存储起来，请求的时候使用 12345678910111213141516171819private Key signature = EmptySignature.obtain(); // 对应 signature()private RequestListener&lt;? super ModelType, TranscodeType&gt; requestListener; // 对应 listener()private Float thumbSizeMultiplier; // 对应 thumbnail()private GenericRequestBuilder&lt;?, ?, ?, TranscodeType&gt; thumbnailRequestBuilder; // 对应 thumbnail()private Float sizeMultiplier = 1f; // 对应 sizeMultiplier()private Priority priority = null; // 对应 priority()private boolean isCacheable = true; // 对应 skipMemoryCache()private GlideAnimationFactory&lt;TranscodeType&gt; animationFactory = NoAnimation.getFactory(); // 对应 animate()private int overrideHeight = -1; // 对应 overide()private int overrideWidth = -1; // 对应 overide()private DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.RESULT; // 对应 diskCacheStrategy()private Transformation&lt;ResourceType&gt; transformation = UnitTransformation.get(); // 对应 transform()// 缩略图private int placeholderId;private Drawable placeholderDrawable;private int errorId;private Drawable errorPlaceholder;private Drawable fallbackDrawable;private int fallbackResource; .into .into() 和 .preload() 方法会返回 Target 对象。 调用 into() 方法后，意味着构造已经完成，将会创建请求开始加载图片，本次图片加载的流程也进入了下一个阶段–请求阶段。 当最后调用 into() 方法或者 preload() 方法时，将会从这个 target 中取出之前在发送的请求，然后清除掉，并构建新的 Request 并发起请求。 1234567891011121314public &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into(Y target) &#123; Util.assertMainThread(); Request previous = target.getRequest(); if (previous != null) &#123; previous.clear(); requestTracker.removeRequest(previous); previous.recycle(); &#125; Request request = buildRequest(target); target.setRequest(request); lifecycle.addListener(target); requestTracker.runRequest(request); return target;&#125; 使用所有配置的参数构建 Request，主要还是有缩略图的情况要特殊处理一下，因为缩略图其实和原图是两个独立的 Request，两个请求同时创建出来，同时缩略图请求优先级高于原图请求，因此要特殊处理。 1234567891011121314151617181920212223242526272829303132private Request buildRequestRecursive(Target&lt;TranscodeType&gt; target, ThumbnailRequestCoordinator parentCoordinator) &#123; if (thumbnailRequestBuilder != null) &#123; if (thumbnailRequestBuilder.animationFactory.equals(NoAnimation.getFactory())) &#123; thumbnailRequestBuilder.animationFactory = animationFactory; &#125; if (thumbnailRequestBuilder.priority == null) &#123; thumbnailRequestBuilder.priority = getThumbnailPriority(); &#125; if (Util.isValidDimensions(overrideWidth, overrideHeight) &amp;&amp; !Util.isValidDimensions(thumbnailRequestBuilder.overrideWidth, thumbnailRequestBuilder.overrideHeight)) &#123; thumbnailRequestBuilder.override(overrideWidth, overrideHeight); &#125; ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator); Request fullRequest = obtainRequest(target, sizeMultiplier, priority, coordinator); // Guard against infinite recursion. isThumbnailBuilt = true; // Recursively generate thumbnail requests. Request thumbRequest = thumbnailRequestBuilder.buildRequestRecursive(target, coordinator); isThumbnailBuilt = false; coordinator.setRequests(fullRequest, thumbRequest); return coordinator; &#125; else if (thumbSizeMultiplier != null) &#123; ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator); Request fullRequest = obtainRequest(target, sizeMultiplier, priority, coordinator); Request thumbnailRequest = obtainRequest(target, thumbSizeMultiplier, getThumbnailPriority(), coordinator); coordinator.setRequests(fullRequest, thumbnailRequest); return coordinator; &#125; else &#123; return obtainRequest(target, sizeMultiplier, priority, parentCoordinator); &#125;&#125; 开始加载资源其实这里的请求是一个更广义上的概念，虽然我们大多情况下会加载一个网络图片，但是这里的请求意思是对资源的请求，这个资源可能是一个文件、一张网络图片或者是一个 Uri，不要先入为主的觉得是一个网络请求。 到目前为止，经历了一系列的配置，请求被构建出来了，接下来是加载请求阶段，在这之前可以对之前的一些关键点做一下总结： 所有请求都会通过 RequestManager 来管理，他监控宿主的生命周期，并调整请求的开始和结束，这一切都是通过它内部 RequestTracker 来完成的，作为 RequestManager 的一个成员，他负责了请求队列的管理（发起和暂停等），是真正意义上的请求管理类。 使用配置的参数构建出来的对象是 GenericRequest，他是一个真正的请求，上面我们看到调用了 requestTracker.runRequest() 方法，里面调用了 request.begin() 方法，请求从这里开始。 在发起请求时会调用 onSizeReady 方法，在方法内部，从 DataLoadProivder 中取得 ModelLoader 进而获取到 DataFetcher 他是获取数据的工具类，然后还有 ResourceTranscoder 用来转码操作。 1234567891011121314GenericRequest.javapublic void onSizeReady(int width, int height) &#123; status = Status.RUNNING; width = Math.round(sizeMultiplier * width); height = Math.round(sizeMultiplier * height); ModelLoader&lt;A, T&gt; modelLoader = loadProvider.getModelLoader(); final DataFetcher&lt;T&gt; dataFetcher = modelLoader.getResourceFetcher(model, width, height); ResourceTranscoder&lt;Z, R&gt; transcoder = loadProvider.getTranscoder(); loadedFromMemoryCache = true; loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder, priority, isMemoryCacheable, diskCacheStrategy, this); loadedFromMemoryCache = resource != null;&#125; 缓存和数据源最关键的地方是使用 engine.load() 触发加载，这个 Engine 是 Glide 的成员，之前被传递到 Request 中的，简单看一下 load() 方法中的伪代码，表面看起来分成了 3 步： loadFromCache() loadFromActiveResources() EngineJob.run() 前面两步是从内存缓存中获取数据，EngineJob 内部则是从文件缓存和数据源中获取，因为涉及耗时操作，这部分会在线程池中执行。 123456789101112131415161718192021222324252627282930Engine.javapublic &lt;T, Z, R&gt; LoadStatus load(...) &#123; EngineKey key = ... // 内存中获取 EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable); if (cached != null) &#123; cb.onResourceReady(cached); return null; &#125; // 内存中获取 EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable); if (active != null) &#123; cb.onResourceReady(active); return null; &#125; // 该任务是不是正在执行 EngineJob current = jobs.get(key); if (current != null) &#123; current.addCallback(cb); return new LoadStatus(cb, current); &#125; // 从文件缓存和数据源获取、包含资源的编解码等 EngineJob engineJob = ... EngineRunnable runnable = new EngineRunnable(engineJob, decodeJob, priority); jobs.put(key, engineJob); engineJob.addCallback(cb); engineJob.start(runnable); return new LoadStatus(cb, engineJob);&#125; 当使用 engine.load() 时，就会开始获取资源，资源的获取会按照 内存缓存 -&gt; 文件缓存 -&gt; 原始数据 这样的顺序去查找, Glide 采用还是常用的内存、文件两级缓存的方式，针对资源返回的位置，可以分为如下几个来源： LruCache&lt;Key,Resource&gt; - 基于 Lru 算法的内存缓存，在超出指定内存时，会进行清理 Map&lt;Key,WeakRef&lt;Resource&gt;&gt; - 虚引用做的内存缓存，系统内存不足时回收资源 DiskLruCache - 基于 Lru 算法做的文件缓存 Source - 数据源，可能是文件，可能是网络图，他是最原始的目标文件 其中内存缓存和文件缓存对应的数据结构如下： 12345Engine.javaprivate final MemoryCache cache; // Lru 缓存private final Map&lt;Key, WeakReference&lt;EngineResource&lt;?&gt;&gt;&gt; activeResources; // 虚引用缓存private final LazyDiskCacheProvider diskCacheProvider; // 文件 Lru 缓存 内存缓存内存缓存方案的选择，考虑如下几个方面： LruCache 的优点是可以有效的将内存控制在一个范围内，并优先保留最后使用的图片，缺点是当内存到达界限时就会开始回收，长列表时有可能会将正在显示的图片回收掉。 WeakRef 的优点是在不造成内存溢出的前提下，上限较高，资源的回收由系统管理，只有在内存不足时才会回收资源，缺点是可能造成占用大量的内存，触发系统 gc 造成断崖式的内存回收。 当产生大量加载事件时，会不停的开辟和回收资源占用的内存空间，造成显著的内存抖动。 更优化的内存缓存方案应该满足 3 个条件: 对最近使用资源更宽容，给予这部分资源更充足的内存空间，保证正在使用的图片不会被回收 对没有使用的资源有一个上限管控，既能保证缓存的优势，又不会对内存空间造成压力 减少内存空间的开辟操作，能够尽量复用已经开辟好的内存空间 Glide 选择的缓存方案是将内存缓存分成两级，同时用一个 BitmapPool 来保留已经开辟的内存空间: activeResouces Map&lt;Key, WeakRef&lt;Resource&gt;&gt; 用来存储正在使用的资源 lruCache LruCache&lt;Key, Resource&gt; 用来存储没有引用计数的资源 BitmapPool Lru&lt;Bitmap&gt; 每次创建 Bitmap 都会优先从 BitmapPool 中查找可以复用的内存空间 资源的存储：当从文件缓存或 Source 中获取到目标资源时，存储到 activeResouces 中，因为该资源处于被获取使用的状态，当然除了 activeResouces 的 WeakRef 它还被展示它的 View 持有，具有一个强引用，这保证了即使发生 gc 也只会回收掉 activeResouces 中那些不被 View 引用的资源。 资源的获取：先从 lruCache 中获取，拿到资源后从 lruCache 删除，加入 activeResouces 中，保证该资源不会因为达到 lruCache 的内存上限而被回收。 资源的回收：当资源被触发回收时，计算引用数，没有引用就从 activeResouces 移除，存储到 lruCache 中，方便下次可以从内存中读取到。 文件缓存文件缓存选择的是 DiskLruCache ，是一个基于 Lru 算法的文件缓存方案，在 Android 上有比较广泛的应用，原理这里不展开说了。 文件缓存的查找在 EngineRunnable 的 run() 方法中： 12345678910111213EngineRunnable.javapublic void run() &#123; resource = decode();&#125;private Resource&lt;?&gt; decode() throws Exception &#123; if (isDecodingFromCache()) &#123; return decodeFromCache(); &#125; else &#123; return decodeFromSource(); &#125;&#125; 从文件缓存读取和从数据源读取都在 run() 方法中实现，这里加载的策略取决于一个 Stage 的枚举类型，他有两个值： CACHE：表示从文件缓存中读取资源 SOURCE：表示从数据源中读取资源，数据源是指网络资源、原始文件等 初始值永远是 Stage.CACHE 意味着总是尝试先从文件缓存中读取，注意这个枚举决定了是从 缓存文件 加载还是从 数据源 加载，不要和下面的弄混了。 当从文件缓存中读取时，又需要关注一个 DiskCacheStrategy 的枚举，在构建 Glide 的请求时我们可能会配置这个加载策略，它由两个内部字段构成 cacheSource：意为缓存和加载原始缓存数据 cacheResult：意为缓存和加载转换后的缓存数据，这个转换包括根据宽高压缩、transform 转换等 对于文件缓存加载来说，如果不 强制指定 总是优先 cacheResult 如果获取不到再 cacheSource 从原始缓存数据中加载并作转换操作，注意这个枚举决定了是加载 原始文件 还是加载 转换后 的文件。下面分为 result 和 source 两个流程比较一下差别: result：Key -&gt; Disk 获取 -&gt; cacheDecoder 解码 -&gt; transcode() 转码 -&gt; 返回数据 source：Key.getOriginKey() -&gt; Disk 获取 -&gt; cacheDecoder 解码 -&gt; 使用 Key 写入文件缓存 -&gt; transcode() 转码 -&gt; 返回数据 对比上面的过程，主要取决于 Key， 这个 Key 是使用 id/signature/width/height 等组成的联合键，而 Key.getOriginKey() 则只比对 id/signature 从而达到缓存原始数据 （Source）和 结果数据 (Result) 数据源当使用 State.CACHE 策略从文件缓存中加载失败时，将会转换成 Stage.SOURCE，并重新运行当前 EngineRunnable，从而开始从数据源加载数据 12345678private void onLoadFailed(Exception e) &#123; if (isDecodingFromCache()) &#123; stage = Stage.SOURCE; manager.submitForSource(this); &#125; else &#123; manager.onException(e); &#125;&#125; 数据源数据的加载由 DataFetcher 来完成，DataFetcher 是在 Glide 初始化时注册的 ModelLoaderFactory 生成的，这个在后面会再细说。 借助 fetcher.loadData() 可以获取到数据源的原始数据，此时根据 DiskCacheStrategy 的不同，也分为两个不同的缓存渠道： result：Key -&gt; SourceDecoder 解码原始数据 -&gt; transform() 转换 -&gt; 使用 Key 写入文件缓存 -&gt; transcode() 转码 source：Key.getOriginalKey() -&gt; SourceEncoder 编码写入 Disk -&gt; Disk 获取 -&gt; cacheDecoder 解码 -&gt; transform() 转换 -&gt; 使用 Key 写入文件缓存 -&gt; transcode() 转码 关于缓存的总结上面涉及了一些编解码、转换转码等操作，我们不需要格外关注，只需要知道他是对数据的一种变换，我们在理解整个流程时，不需要太关注那些编解码、写文件等操作，只要能够理清整体缓存流程，理解其中的设计原理。 为了更好的理解，下面对一些步骤进行简单的解释： Key 是由 id/signature/width/height 组成的联合键，作为缓存文件的键值，他是非常精确的，而 Key.getOriginKey() 只关心 id/signature，是更通用的键值。 fetcher 类似数据加载器，提前配置好的，由 GenericLoaderFactory 管理，用来加载数据，可以简单理解为通过网络 Url 转换成 InputStream 流的过程 SourceDecoder 解码原始数据 是说将 fetcher 拿回来的数据进行解码，可以简单理解为将 InputStream 转换为 Bitmap 的过程 SourceEncoder 编码写入 Disk 将 fetcher 返回的数据进行编码操作，输出到 OutputStream，可以简单理解为网络请求返回的 InputStream 转换成 outputStream 的过程。 cacheDecoder 解码，cacheEncoder 是之前就配置好的一个转码器，由 DataLoadProvider 提供，主要负责将文件转换成目标数据，可以简单理解为将文件转为 Bitmap 类似的操作 transcode() 转码，这是一个转码操作，也是之前就配置好的，由 DataLoadProviderRegistry 管理，可以简单理解为将 Bitmap 转换为 GlideDrawable 这种数据的过程 transform() 转换 在构建 Glide 请求时配置的，是自定义，比如转换成圆角、圆形图之类的操作 针对 内存 -&gt; 文件 -&gt; 数据源 的整个流程，整理一个流程图，展示一下整个数据加载的过程。 数据转换上面页陆陆续续提到了一些编解码前面提到了几种进行数据转换的类，这里汇总整理介绍，更直观的归纳一下这几种数据转化的作用和使用的时机。 ModelLoader 负责将 String、Uri、int、URL 等等类型转化成 InputStream 和 ParcelFileDescriptor，是整个转化流程的第一步，他的原始数据类型都是我们调用 load() 方法里面支持的数据类型。 DataLoadProvider 负责编解码的转换，它提供 Encoder 和 Decoder，可以将 InputStream 和 ParcelFileDescriptor 转换成 Bitmap、GifDrawable 等，很明显，是接着上一步进行的一个编解码操作，他的原始数据类型，就是 ModelLoader 的目标数据类型。 ResourceTranscoder 负责结果数据类型的转换，可以将 Bitmap 和 GifDrawable 转换成 GlideDrawable 等，原始数据类型就是上一步的目标数据类型。 ModelLoaderModelLoader 用来针对某种数据源和返回数据创建一个 DataFetcher 用来请求数据，这里的请求是对数据源的请求，不仅仅限于网络请求。 123public interface ModelLoader&lt;T, Y&gt; &#123; DataFetcher&lt;Y&gt; getResourceFetcher(T model, int width, int height);&#125; ModelLoader 的类型很多，他们统一被 GenericLoaderFactory 管理，使用的工厂模式，在使用时使用对应的工厂类创建，同时加入缓存，获取时优先从缓存中获取，他是 Glide 的成员，在 Glide 初始化时被创建，并注册常用的 ModelLoaderFactory，这个类主要做两件事情： 管理 ModelLoader 工厂的注册表 管理 ModelLoader 的缓存 注册表和缓存使用两层 Map 结构实现，理解起来比较麻烦，例如注册表表的定义如下： 1Map&lt;Class/*T*/, Map&lt;Class/*Y*/, ModelLoaderFactory/*T, Y*/&gt;&gt; 所以 String-&gt;InputStream 和 String-&gt;ParcelFileDescriptor的 ModelLoaderFactory 注册进去是： 123Map&lt;String,Map&lt;InputStream, ModelLoaderFactory&lt;String,InputStream&gt;&gt;&gt;Map&lt;String,Map&lt;ParcelFileDescriptor, ModelLoaderFactory&lt;String, ParcelFileDescriptor&gt;&gt;&gt; 这样一个结构的注册表，当你拿着 String-&gt;InputStream 去查找时，就能找到对应的 Factory。 123456789101112131415161718192021222324GenericLoaderFactory.javaprivate &lt;T, Y&gt; ModelLoaderFactory&lt;T, Y&gt; getFactory(Class&lt;T&gt; modelClass, Class&lt;Y&gt; resourceClass) &#123; Map&lt;Class/*Y*/, ModelLoaderFactory/*T, Y*/&gt; resourceToFactories = modelClassToResourceFactories.get(modelClas ModelLoaderFactory/*T, Y*/ result = null; if (resourceToFactories != null) &#123; result = resourceToFactories.get(resourceClass); &#125; if (result == null) &#123; for (Class&lt;? super T&gt; registeredModelClass : modelClassToResourceFactories.keySet()) &#123; if (registeredModelClass.isAssignableFrom(modelClass)) &#123; Map&lt;Class/*Y*/, ModelLoaderFactory/*T, Y*/&gt; currentResourceToFactories = modelClassToResourceFactories.get(registeredModelClass); if (currentResourceToFactories != null) &#123; result = currentResourceToFactories.get(resourceClass); if (result != null) &#123; break; &#125; &#125; &#125; &#125; &#125; return result;&#125; 缓存就不必说了，每次使用工厂创建耗时耗力，在内存中缓存一份，等查找时优先去内存中查找已经创建过的 ModelLoader 直接复用就可以了。 12345678910GenericLoaderFactory.javapublic class GenericLoaderFactory &#123; // 注册表 private final Map&lt;Class/*T*/, Map&lt;Class/*Y*/, ModelLoaderFactory/*T, Y*/&gt;&gt; modelClassToResourceFactories = new HashMap&lt;Class, Map&lt;Class, ModelLoaderFactory&gt;&gt;(); // 缓存实现 private final Map&lt;Class/*T*/, Map&lt;Class/*Y*/, ModelLoader/*T, Y*/&gt;&gt; cachedModelLoaders = new HashMap&lt;Class, Map&lt;Class, ModelLoader&gt;&gt;();&#125; 最后，这个注册表是可扩展的，你可以给他注册自己的 ModelLoaderFactory 来解析合适的数据类型，当然针对常用的类型，Glide 类中已经注册了默认的许多工厂。 12345678910111213register(File.class, ParcelFileDescriptor.class, new FileDescriptorFileLoader.Factory());register(File.class, InputStream.class, new StreamFileLoader.Factory());register(int.class, ParcelFileDescriptor.class, new FileDescriptorResourceLoader.Factory());register(int.class, InputStream.class, new StreamResourceLoader.Factory());register(Integer.class, ParcelFileDescriptor.class, new FileDescriptorResourceLoader.Factory()register(Integer.class, InputStream.class, new StreamResourceLoader.Factory());register(String.class, ParcelFileDescriptor.class, new FileDescriptorStringLoader.Factory());register(String.class, InputStream.class, new StreamStringLoader.Factory());register(Uri.class, ParcelFileDescriptor.class, new FileDescriptorUriLoader.Factory());register(Uri.class, InputStream.class, new StreamUriLoader.Factory());register(URL.class, InputStream.class, new StreamUrlLoader.Factory());register(GlideUrl.class, InputStream.class, new HttpUrlGlideUrlLoader.Factory());register(byte[].class, InputStream.class, new StreamByteArrayLoader.Factory()); 这样理解起来稍微有些抽象，我们来看一个网络相关的注册实现，GlideUrl 是一个包装，所有和网络相关的都会最终转成 GlideUrl ： 1register(GlideUrl.class, InputStream.class, new HttpUrlGlideUrlLoader.Factory()); 看一下 HttpUrlGlideUrlLoader 的实现，实现一个方法 getResourceFetcher()，返回 HttpUrlFetcher 这个类主要用来使用 HttpUrlConnection 发起网络请求，请求图片返回 InputStream 流。 1234567891011121314151617public class HttpUrlGlideUrlLoader implements ModelLoader&lt;GlideUrl, InputStream&gt; &#123; private final ModelCache&lt;GlideUrl, GlideUrl&gt; modelCache; public static class Factory implements ModelLoaderFactory&lt;GlideUrl, InputStream&gt; &#123; private final ModelCache&lt;GlideUrl, GlideUrl&gt; modelCache = new ModelCache&lt;GlideUrl, GlideUrl&gt;(500); @Override public ModelLoader&lt;GlideUrl, InputStream&gt; build(Context context, GenericLoaderFactory factories) &#123; return new HttpUrlGlideUrlLoader(modelCache); &#125; &#125; @Override public DataFetcher&lt;InputStream&gt; getResourceFetcher(GlideUrl model, int width, int height) &#123; return new HttpUrlFetcher(url); &#125;&#125; 总结：可以发现 ModelLoader 主要就是用来对源数据进行一个请求操作。 DataLoadProviderDataLoadProvider 负责编解码操作，主要是提供编解码器，将 InputStream 和 File 转换成真正意义上的图片，也就是 Bitmap 和 GifDrawable 等。 123456public interface DataLoadProvider&lt;T, Z&gt; &#123; ResourceDecoder&lt;File, Z&gt; getCacheDecoder(); // 缓存解码器，从文件缓存中解码出目标资源 ResourceDecoder&lt;T, Z&gt; getSourceDecoder(); // 数据源解码器，从数据源中解码出目标资源 Encoder&lt;T&gt; getSourceEncoder(); // 数据源编码器，将数据源编码到 OutputStream ResourceEncoder&lt;Z&gt; getEncoder(); // 资源解码器，将资源编码到 OutputStream&#125; 上面的接口使用了很多范型，我们借助 StreamBitmapDataLoadProvider 来理解他，这个类是一个实现，它是针对 InputStream 和 Bitmap 编解码的实现 1234567891011121314151617181920212223242526272829303132333435363738394041public class StreamBitmapDataLoadProvider implements DataLoadProvider&lt;InputStream, Bitmap&gt; &#123; private final StreamBitmapDecoder decoder; private final BitmapEncoder encoder; private final StreamEncoder sourceEncoder; private final FileToStreamDecoder&lt;Bitmap&gt; cacheDecoder; public StreamBitmapDataLoadProvider(BitmapPool bitmapPool, DecodeFormat decodeFormat) &#123; sourceEncoder = new StreamEncoder(); decoder = new StreamBitmapDecoder(bitmapPool, decodeFormat); encoder = new BitmapEncoder(); cacheDecoder = new FileToStreamDecoder&lt;Bitmap&gt;(decoder); &#125; @Override public ResourceDecoder&lt;File, Bitmap&gt; getCacheDecoder() &#123; // 缓存解码器，从文件缓存中解码出目标资源 // 这里就是将 File 解码成 Bitmap return cacheDecoder; &#125; @Override public ResourceDecoder&lt;InputStream, Bitmap&gt; getSourceDecoder() &#123; // 数据源解码器，从数据源中解码出目标资源 // 这里是将请求回来的 InputStream 解码成 Bitmap return decoder; &#125; @Override public Encoder&lt;InputStream&gt; getSourceEncoder() &#123; // 数据源编码器，将数据源编码到 OutputStream // 这里是将请求回来的 InputStream 转换成 OutputStream 用来存文件什么的 return sourceEncoder; &#125; @Override public ResourceEncoder&lt;Bitmap&gt; getEncoder() &#123; // 资源解码器，将资源编码到 OutputStream // 将已经转换好的 Bitmap 转成 OutputStream 用来存文件什么的 return encoder; &#125;&#125; 也是采用注册表的方式，但是没有使用工厂，直接存储在内存中，使用 DataLoadProviderRegistry 来管理，内部同样是一个 Map 结构，存放了需要使用 DataLoadProvider，而且他也是 Glide 的成员对象。 12345public class DataLoadProviderRegistry &#123; private static final MultiClassKey GET_KEY = new MultiClassKey(); private final Map&lt;MultiClassKey, DataLoadProvider&lt;?, ?&gt;&gt; providers = new HashMap&lt;MultiClassKey, DataLoadProvider&lt;?, ?&gt;&gt;();&#125; 在 Glide 创建的时候初始化 123456789101112131415161718Glide.javadataLoadProviderRegistry = new DataLoadProviderRegistry();StreamBitmapDataLoadProvider streamBitmapLoadProvider = new StreamBitmapDataLoadProvider(bitmapPool, decodeFormat);dataLoadProviderRegistry.register(InputStream.class, Bitmap.class, streamBitmapLoadProvider);FileDescriptorBitmapDataLoadProvider fileDescriptorLoadProvider = new FileDescriptorBitmapDataLoadProvider(bitmapPool, decodeFormat);dataLoadProviderRegistry.register(ParcelFileDescriptor.class, Bitmap.class, fileDescriptorLoadProvider);ImageVideoDataLoadProvider imageVideoDataLoadProvider = new ImageVideoDataLoadProvider(streamBitmapLoadProvider, fileDescriptorLoadProvider);dataLoadProviderRegistry.register(ImageVideoWrapper.class, Bitmap.class, imageVideoDataLoadProvider);GifDrawableLoadProvider gifDrawableLoadProvider = new GifDrawableLoadProvider(context, bitmapPool);dataLoadProviderRegistry.register(InputStream.class, GifDrawable.class, gifDrawableLoadProvider);dataLoadProviderRegistry.register(ImageVideoWrapper.class, GifBitmapWrapper.class, new ImageVideoGifDrawableLoadProvider(imageVideoDataLoadProvider, gifDrawableLoadProvider, bitmapPool));dataLoadProviderRegistry.register(InputStream.class, File.class, new StreamFileDataLoadProvider()); TranscoderTranscoder 做的是一个转码操作，负责将一种资源转换成另一种资源。 123public interface ResourceTranscoder&lt;Z, R&gt; &#123; Resource&lt;R&gt; transcode(Resource&lt;Z&gt; toTranscode);&#125; 使用 TranscoderRegistry 管理，注册表管理。123456public class TranscoderRegistry &#123; private static final MultiClassKey GET_KEY = new MultiClassKey(); private final Map&lt;MultiClassKey, ResourceTranscoder&lt;?, ?&gt;&gt; factories = new HashMap&lt;MultiClassKey, ResourceTranscoder&lt;?, ?&gt;&gt;();&#125; 同样是 Glide 的成员，在 Glide 创建的时候注册 1234567Glide.javatranscoderRegistry.register(Bitmap.class, GlideBitmapDrawable.class, new GlideBitmapDrawableTranscoder(context.getResources(), bitmapPool));transcoderRegistry.register(GifBitmapWrapper.class, GlideDrawable.class, new GifBitmapWrapperDrawableTranscoder( new GlideBitmapDrawableTranscoder(context.getResources(), bitmapPool))); 对比 类 管理类 原始数据类型 目标数据类型 ModelLoader GenericLoaderFactory String(网络，文件等)int(资源)Uri(资源定位)File(文件)URL(网络) InputStreamParcelFileDescriptor DataLoadProvider DataLoadProviderRegistry ParcelFileDescriptorInputStream BitmapGifDrawable ResourceTranscoder TranscoderRegistry BitmapGifBitmapWrapper GlideDrawableGlideBitmapDrawable 总结我们就以加载文件里的图片为例完整的理解一下第一次的基本加载过程： 1234567数据源ModelLoader(DataFetcher)转化为 InputStreamDataLoadProvider(SourceDecoder) -&gt; 存文件缓存解码为 BitmapResourceTranscoder(transcode)转码为 GlideDrawable 对于上述加载过程构造的 RequestBuilder 为 12public class GenericRequestBuilder&lt;ModelType, DataType, ResourceType, TranscodeType&gt; &#123;&#125;public class GenericRequestBuilder&lt;File, InputStream, Bitmap, GlideDrawable&gt; &#123;&#125; 可以看出 12345File -&gt; InputStream -&gt; Bitmap -&gt; GlideDrawableModelType 数据源类型DataType 数据类型，从数据源 fetch 得到ResourceType 资源类型，由数据类型解码得到TranscodeType 转码类型，由资源类型转码得到 理解了这几种转换就能更清晰的理解 Glide 的内部原理]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SourceCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 性能优化 - UI [进阶]]]></title>
    <url>%2Farticle%2Fd1ceed0f%2F</url>
    <content type="text"><![CDATA[本文主要总结和记录 Android 开发过程中对 UI 绘制上的优化，优化 UI 绘制可以减少绘制的时间，尽可能快速的将界面展示出来，还可以减轻 CPU 的压力，避免过度绘制，保证 UI 的流畅度。 前言界面 UI 每隔 16 ms 请求绘制一次，相当于 1000ms/16 =&gt; 60fps，60fps 是人能感觉到的最高帧率，也就是说超过 60fps 是没有必要的，同时，如果低于 30fps 将会无法流畅展示内容。 过度绘制 调试过度绘制 通过手机的开发者选项可以调试过度绘制，设置 -&gt; 开发者选项 -&gt; 调试GPU过度绘制 -&gt; 显示GPU过度绘制 打开调试过度绘制以后，界面会显示不同的颜色，分别代表过度绘制的次数： 颜色 描述 表示 蓝紫色 overdraw 1倍 绘制了2次，大片的蓝紫色是可以接受的 绿色 overdraw 2倍 绘制了3次，中等大小的绿色区域是可以接受的但你应该尝试优化、减少它们 淡红 overdraw 3倍 绘制了4次，小范围可以接受 深红 overdraw 4倍 绘制了5+次，这是错误的，要修复 查看微信的过度绘制情况，首页基本在2倍以内，其他页面列表有3倍的情况，4倍的绘制一般出现在极小的区域内，比如文字和图标等。 目标是尽量增加蓝紫色的区域，减少红色区域。 GPU 使用 通过手机的开发者选项可以开启 GPU 呈现模式分析， 设置 -&gt; 开发者选项 -&gt; GPU呈现模式分析 ，可以查看某个界面的 GPU 占用情况。 UI 层级如果布局层级嵌套过深，也会导致 UI 绘制的问题，尤其是使用 xml 布局文件，因为一方面解析 xml 就需要耗费大量的 CPU，另外布局 measure 的时候，子布局需要告知父布局自己的大小和占据的位置，层级过多之后就会占用更多的时间和内存。 Hierarchy Viewer 是一个查看 UI 布局层级的工具，使用 AndroidStudio 在 Tools -&gt; Android -&gt; Device Monitor 不过真机无法调试，只能使用模拟器，不过大家可以参考这个项目 GitHub-ViewServer，不过在电脑上面查看会很卡，而且拖动起来很不方便。 如果项目中使用了网络框架，可以使用： 12compile 'com.facebook.stetho:stetho:1.4.2',compile 'com.facebook.stetho:stetho-okhttp3:1.4.2', 然后在 chrome://inspect 查看布局，点击指定布局，手机会同时高亮显示 UI 优化解决办法针对以上两种情况，解决 UI 绘制问题主要是 减少过度绘制 和 减少布局层级 两个方面。 删除重复无用的背景 如果层级覆盖的情况下，优先设置底层 View 的背景，顶层如果具有相同颜色的背景，就不要重复设置啦。 如果底层的 View 覆盖了整个屏幕，那么 Window 的背景也是不需要的，可以使用： 1getWindow().setBackgroundDrawable(null); 合理选择布局 布局要遵循 增加宽度，减小深度 的原则，尽可能的减少 UI 层级 不使用绝对布局 AbsoluteLayout。 复杂布局，优先使用 RelativeLayout，可以更好的控制子控件的位置。 相同的层级情况下，优先使用 LinearLayout，他的布局效率更高。 尽可能少用 layout_weight 属性，他会造成多次测量。 使用 ConstraintLayout，可以很好的减少布局的层级。 Xml Drawable 规则图形，尽量使用 shape.xml 代替图片 使用 selector 时，将 normal 状态下的颜色设置为 transparent Include 使用 &lt;include/&gt; 标签复用布局，这个其实并不能起到优化 UI 绘制的作用，不过讲合适的布局分离处理做成独立的 xml，可以更好的将布局组件化。 1234567&lt;include layout="@layout/activity_about_us" android:layout_width="match_parent" android:layout_height="100dp" android:layout_margin="10dp" android:orientation="horizontal" android:visibility="visible"/&gt; 使用 &lt;include/&gt; 需要注意几点，在 &lt;include/&gt; 标签中可以使用部分属性来从新定义布局，如 width、height、visibility、margin、id 等，如指定了 id，将会覆盖 &lt;include/&gt; 里面根布局的 id，造成查找不到的情况。 ViewStub 如果一个控件大多数情况下不进行显示，那么使用 ViewStub 要比使用 Visibility 更好，他不会占据任何位置，解析 xml 也不会耗费更多资源。 12345&lt;ViewStub android:id="@+id/viewstub" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout="@layout/activity_about_us"/&gt; 当需要展示内部布局时，使用 inflate() 展开布局，布局展开后，ViewStub 里面的内容就会代替 ViewStub 的位置，同时 ViewStub 就查找不到了，而且我们也不希望展开多次，所以要做一下空判断，不为空时，使用 setVisibility 展示布局。 12345678910111213private View viewStubView;private void openViewStub() &#123; // 已经展开，直接使用 setVisibility if (viewStubView != null) &#123; viewStubView.setVisibility(View.VISIBLE); &#125; else &#123; ViewStub viewStub = findViewById(R.id.viewstub); // 没有展开，使用 ViewStub if (viewStub != null) &#123; viewStubView = viewStub.inflate(); &#125; &#125;&#125; Merge 使用 xml 布局时，最外层只能有一个父控件，当我们希望把其中部分提取到 &lt;include/&gt; 中时，就需要在子布局最外层再加一层控件包含，这样就增加了布局的深度。 &lt;merge/&gt; 就是为了解决上述问题，它主要是用来将两个相同的布局合并为一个，主要用于两种情况： 第一种情况是，调用 setContentView() 时，其实是将我们的布局设置到了 id 为 R.id.content 的 FrameLayout 中，那么如果我们的顶层布局也是 FrameLayout，同时没有 background 和 padding 等属性，那么就可以使用 &lt;merge/&gt;，将二者合为一个，理解起来也简单，本来就是两个一样的布局套在一起，合为一个并不影响。 第二种情况是，使用 &lt;include/&gt; 时也是一样的道理，如果 &lt;include/&gt; 中的顶层布局和他将要添加到的布局里面的 layout 是一样的，那么就可以使用 &lt;merge/&gt;，节省一层布局，如下： 1234567891011121314151617// test_layout.xml&lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;TextView ... /&gt; &lt;include layout="@layout/test_item_layout"/&gt;&lt;/LinearLayout&gt;// test_item_layout.xml&lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;TextView ... /&gt; &lt;TextView ... /&gt;&lt;/LinearLayout&gt; 由于 &lt;include/&gt; 顶层 View 也是 LinearLayout，因此可以使用 &lt;merge/&gt; 代替 1234567&lt;merge android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;TextView ... /&gt; &lt;TextView ... /&gt;&lt;/merge&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 性能优化 - 内存 [进阶]]]></title>
    <url>%2Farticle%2F666476b4%2F</url>
    <content type="text"><![CDATA[本文主要总结 Android 开发过程中对内存使用上的优化，通过及时有效的管理内存空间可以避免内存泄漏和 OOM 的发生。 前言四种引用类型： 强引用：默认引用类型，强引用的对象即使抛出 OOM 也不会被回收。 软引用 SoftReference：当内存不足时会被回收。 弱引用 WeakReference：在 GC 时，一旦发现了只具有弱引用的对象，都会进行回收。 虚引用 PhantomReference：任何时候都可以被 GC 回收。 内存问题主要体现在： 内存泄漏：指的是当一个对象不再被使用时，由于其他对象仍然持有该对象的强引用，导致该对象无法被释放，造成内存空间的浪费，大量占据内存空间可能引发 OOM; 内存溢出：即 OOM，当向系统申请内存时，没有足够的内存空间时会引发 OOM，OOM 发生的情况很多，而且最后 Crash 的地方并不一定是问题的根源，可能是其他的操作占用了大量内存。 内存抖动：指的是频繁的有大量的对象创建和销毁，引发高频的系统 GC，当 GC 线程启动时其他线程都会暂停，会造成页面的卡顿等。 解决内存问题的原则： 避免创建大对象，如不使用 inSampleSize 的 Bitmap 等 避免大量创建重复对象，如在循环中创建对象 避免生命周期不可控的对象引用，如在子线程中引用上下文 避免少的开辟新的内存空间，建议尽量复用可复用的内存空间，如后文介绍的 ByteArrayPool 以及 Bitmap 的 inBitmap 属性 内存分析和监控 获取分配的内存和可用内存大小 12long totalMemory = Runtime.getRuntime().totalMemory();long freeMemory = Runtime.getRuntime().freeMemory(); Android Profiler 使用 AndroidStudio，通过 View -&gt; ToolWindows -&gt; Android Profiler，可以查看内存、网络、CPU 变化情况，还可以 Dump 内存记录，用于内存分析。 Memory View 使用 AndroidStudio，通过 View -&gt; ToolWindows -&gt; Memory View，可以结合断点调试 dump 指定断点处的内存使用情况，进行内存分析。 内存监控 当应用内存不足时，会调用 Application 的 onTrimMemory() 方法，我们可以在这里做一些清理内存的操作，避免内存过大造成 OOM 1234567public class MyApplication extends BaseApplication &#123; @Override public void onTrimMemory(int level) &#123; super.onTrimMemory(level); &#125; &#125; LeakCanaryLeakCanary-GitHub : A memory leak detection library for Android and Java. LeakCanary 是 squre 开源的一个用于在 Android 和 Java 平台下检测内存泄漏的工具，提供了两种依赖方式，在 release 版本下不会进行内存泄漏的检测，避免性能问题。 12compile "com.squareup.leakcanary:leakcanary-android-no-op:1.5.1"debugCompile "com.squareup.leakcanary:leakcanary-android:1.5.1" 在 Application 中初始化 1234567891011121314151617181920212223public class MyApplication extends BaseApplication &#123; @Override public void onCreate() &#123; super.onCreate(); initLeakCanary(); &#125; private RefWatcher mRefWatcher; public void initLeakCanary() &#123; if (LeakCanary.isInAnalyzerProcess(this)) &#123; return; &#125; mRefWatcher = LeakCanary.install(this); &#125; public static RefWatcher getRefWatcher(Context context) &#123; MyApplication application = (MyApplication) context.getApplicationContext(); return application.mRefWatcher; &#125;&#125; 初始化之后就可以自动检测 Activity 的内存泄露问题，如果需要检测 Fragment 等其他对象的内存问题，需要在希望对象被回收的时候注册检测监听 1234567public class MyFragment extends BaseFragment &#123; @Override public void onDestroy() &#123; super.onDestroy(); MyApplication.getRefWatcher(getContext()).watch(this,"fragment"); &#125;&#125; 内部类导致内存泄漏在内存问题上我们简单的把内部类分为静态内部类和非静态内部类： 静态内部类：与外部类独立，内部类的创建不需要依赖外部类实例，而是依赖于 Class 本身，他只能访问外部类的静态变量和方法，可以看作一个完全独立的类，与外部类完全隔离，不会存在内存泄漏的问题。 非静态内部类：也就是其他类型的内部类，主要包括局部内部类、匿名内部类等，他们的创建依赖于外部类的实例，非静态内部类可以访问外部的非静态成员，甚至是私有成员，这是因为内部类中隐式的持有了外部类的引用，在编译后，会形成 OuterClass$InnerClass 类，而这个类中就会持有外部类的引用，因此当外部类被销毁后，由于内部类仍旧强引用持有了外部类，因此外部类不能被及时回收，造成内存泄漏问题。 不是说所有的内部类都会造成内存泄漏，外部类销毁时通常也会销毁内部类，内存泄漏往往发生在由于一些原因导致内部类无法被销毁的情况，如生命周期不统一。 生命周期不统一导致内存泄漏生命周期不统一指的是 ObjB 引用了 ObjA，但是 ObjB 比 ObjA 生命更长，当 ObjA 自己销毁时，由于 ObjB 还在活跃，导致 ObjA 无法被回收。 因为内部类持有外部类的引用，如果内部类存在于一个新的线程里面，那么内部类的生命周期就依赖于新的线程的生命周期，两者不一致，当外部类被销毁时，就会造成内存问题，比较常见的体现在 Handler、AsyncTask 和 Thread 等涉及线程的操作。 Handler 123456Handler mHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); &#125;&#125;; 在 Activity 中使用 Handler 发送的 Message 排队在 Looper 线程的 MessageQueue 中，同时 Message 中持有 Handler 的引用，而由于Handler 匿名内部类隐式的持有了外部类的引用，就相当于 Activity 被强关联在了这条消息上面。即 Activity -&gt; Handler -&gt; Message -&gt; MessageQueue -&gt; Looper 当 Activity 被销毁后还是会按照指定的时间发送该消息，造成内存泄漏。因此在 Activity 非静态的声明一个 Handler 会警告：匿名的 Handler 可能会引发内存泄漏 1This Handler class should be static or leaks might occur (anonymous android.os.Handler) 这个问题尤其体现在使用 Handler 发送了一个延时消息，当 Activity 被销毁后，这个消息才被发送出来，开始执行。 除了匿名声明 Handler 之外，当使用 Handler 发送一个 Runnable 时也会存在一样的问题，这里 Handler 不是内部类了，但是发送的 Runnale 里面也会隐式持有外部类的应用，即 Activity -&gt; Runnale -&gt; Message -&gt; MessageQueue -&gt; Looper 1234567Handler mHandler = new Handler();mHandler.post(new Runnable() &#123; @Override public void run() &#123; &#125;&#125;); Thread 和 AsyncTask 通常我们在子线程执行耗时任务，执行完成后再回到主线程操作，如下面的例子中，Thread 和 AsyncTask 结束的时机是没办法控制的，而他们都会持有外部 Activity 的引用，导致无法回收。 12345678910111213new Thread(new Runnable() &#123; @Override public void run() &#123; &#125;&#125;).start();new AsyncTask&lt;Void, Void, Void&gt;() &#123; @Override protected Void doInBackground(Void... voids) &#123; return null; &#125;&#125;.execute(); 针对生命周期不一致问题的优化方案单纯的内部类不会造成内存泄漏，不用过分保护，对于生命周期不可控的内部类，采用静态声明，结合虚引用来将内部类和外部类隔离 12345678910111213141516static class NoLeakHandler extends Handler &#123; private WeakReference&lt;Activity&gt; mActivityWeakRef; public NoLeakHandler(Activity activity) &#123; mActivityWeakRef = new WeakReference&lt;&gt;(activit &#125; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); Activity activity = mActivityWeakRef.get(); if (activity != null) &#123; activity.finish(); &#125; &#125;&#125;Handler mHandler = new NoLeakHandler(this); 使用线程进行操作时，也需要使用虚引用与 Context 交互 123456789101112131415161718class NoLeakAsyncTask extends AsyncTask&lt;Void, Void, Void&gt; &#123; private WeakReference&lt;Activity&gt; mActivityWeakRef; public NoLeakAsyncTask(Activity activity) &#123; mActivityWeakRef = new WeakReference&lt;&gt;(activity); &#125; @Override protected Void doInBackground(Void... voids) &#123; return null; &#125; @Override protected void onPostExecute(Void aVoid) &#123; super.onPostExecute(aVoid); Activity activity = mActivityWeakRef.get(); if (activity != null) &#123; activity.finish(); &#125; &#125;&#125; 当 Activity 销毁时，将 Handler 的消息队列清空 1mHandler.removeCallbacksAndMessages(null); 静态引用导致内存泄漏静态引用的变量不依赖于某个类实例，所以他不会随着某个实例的销毁而随之销毁，因此一旦声明静态引用了某个对象实例，即使抛出异常也不会被回收。 使用静态变量要慎重，避免为了简单的共享数据静态的声明占用大量内存的数据对象，尤其是集合类对象。 类比上面的说法，也可以看作生命周期不统一造成的问题，因为静态引用的变量具有和 Application 相同的生命周期，而 Activity 的生命周期通常较短。 静态引用 Context 导致内存泄漏这边单独拿出来说是因为在 Android 中静态引用 Context 也是内存泄漏重灾区，如下列举常见的几种可能静态引用 Context 的场景如： 某个对象没有静态引用 Context，但是这个对象在其他位置被静态引用了，导致 Context 间接的静态引用。 单例，单例其实也是静态的引用，不能在单例中引用 Context。 Toast，为了管理 Toast，比如避免大量 Toast 排队通常会写一个 ToastUtils，里面就会静态持有 Toast 对象，而 Toast 中是引用了 Context 的。 View，由于 View 中引用了 Context，静态的 View 就很危险。 Animator，属性动画通常绑定到一个 View 上面，静态引用 Animator 相当于静态引用了 View。 Animation，补间动画中并没有显式的引用 View 或者 Context，但是他有一个 mListenerHandler，这个监听在 View.draw() 方法中如果当前 View 的 Animation 不为空，会给他一个 mAttachInfo.mHandler，而这里面引用了 ViewRootImpl.mContext。 特别注意静态引用的集合数据类型，如 List 和 Map，里面通常会存储大量的对象，如果这些对象中有某些对象引用了 Context，同样会造成内存泄漏。 当不可避免的需要静态引用 Context 时，使用虚引用代替 12WeakReference&lt;Context&gt; mContextWeakRef;mContextWeakRef = new WeakReference&lt;&gt;(getContext()); 尽可能使用 Application 的 Context，而不是 Activity 的。 12Context appContext = context.getApplicationContext();Application application = (Application) context.getApplicationContext(); 资源回收不及时指的是一些对象我们使用完后要及时关闭、回收或者解除注册，来保证内存可以被及时回收，如： Cursor IO 流 Bitmap Animation BroadcastReceiver 尽可能及时的回收资源和内存空间 123456789101112131415161718192021222324// CursorCursor cursor = ...;cursor.close();// StreamFileOutputStream outputStream = ...outputStream.close();// BitmapBitmap bitmap = ...;bitmap.recycle();// AnimationAnimation animation = ...;animation.cancel();animation.setAnimationListener(null);// BroadcastReceiverBroadcastReceiver broadcastReceiver = ...context.unregisterReceiver(broadcastReceiver);// bytebyte[] bytes = new byte[1024 * 8];bytes = null; Bitmap 占用大量内存图片是应用运行过程中内存占用的大户，大多数的 OOM，都是因为 Bitmap 处理不当导致的，因此把 Bitmap 单独拿出来说一下。 图片质量要求不是那么高的时候，使用 RBG_565 Config 描述 ALPHA_8 8位Alpha位图 RGB_565 16位RGB位图 ARGB_4444 16位ARGB位图 ARGB_8888 32位ARGB位图 1234567Bitmap bitmap = null;bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);BitmapFactory.Options options = new BitmapFactory.Options();options.inPreferredConfig = Bitmap.Config.RGB_565;bitmap = BitmapFactory.decodeFile(filePath, options); 针对显示的大小计算 inSampleSize 对图片进行采样显示 1234567891011121314151617181920212223242526public Bitmap decodeFile(String filePath) &#123; // 想显示的图片大小 int reqWidth = 100; int reqHeight = 100; // 先获取图片宽高 BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeFile(filePath, options); int imgHeight = options.outHeight; int imgWidth = options.outWidth; // 计算 sampleSize int inSampleSize = 1; if (imgHeight &gt; reqHeight || imgWidth &gt; reqWidth) &#123; final int halfHeight = imgHeight / 2; final int halfWidth = imgWidth / 2; // 在保证解析出的 bitmap 宽高分别大于目标尺寸宽高的前提下 // 取可能的 inSampleSize 的最大值 while ((halfHeight / inSampleSize) &gt; reqHeight &amp;&amp; (halfWidth / inSampleSize) &gt; reqWidth) &#123; inSampleSize *= 2; &#125; &#125; options.inSampleSize = inSampleSize; options.inJustDecodeBounds = false; return BitmapFactory.decodeFile(filePath, options);&#125; 使用 inBitmap 优化 Bitmap 内存使用 参考1: Android Developer Manage Memory 参考2: 关于 inBitmap 的知乎回答 参数 inBitmap 主要是用来复用已经存在 Bitmap 内存空间，他要求你将一个已经存在的 Bitmap 放入 options，这样新创建的 Bitmap 将会重新放在这块内存空间上，减少了内存空间的重复开辟和回收。 这个参数结合 LruCache 将会有更好的使用效果，在 LruCache 中被移除的 Bitmap 不用立刻进行回收，而是存储起来为下一个将要创建 Bitmap 提供内存空间，从而避免开辟过多的内存，造成浪费和 OOM。 重复创建对象在代码中常常有一些循环操作和发生频率比较高的操作，在这类操作中应该尽量避免创建对象，虽然不会导致内存泄漏但是频繁创建和销毁对象会占用大量内存和引起显著的内存抖动，例如： 高频操作，接入 Weex 时用到自定义请求支持 OkHttpClientAdapter，每次发送请求都会走这个 Adapter，同时创建 OkHttpClient 然后发送请求，在实际应用中请求发送频率很高，因此创建了大量的 OkHttpClient，后来将创建对象的代码提取到构造方法中，这个问题得到了改善。 循环，开发过程中，循环次数往往不可控，应该避免在循环中创建新的对象。 字符串拼接操作，每次字符串拼接都会产生一个新的字符串，因此如果有频繁的拼接操作，请使用 StringBuilder。 方法名的定义导致使用的不当，在 getXXX() 方法中不应该进行创建对象的操作，如果有要加入仅创建一次的判断，因为当别人和自己在使用该方法可能会直接调用，因为对使用者来说，这只是一个获取操作，就会频繁的使用它，并不知道内部返回了一个全新的对象。 12345678910111213141516171819private ViewModel mViewModel;// 不应该在 get 方法中不加判断的创建对象public ViewModel getViewModel() &#123; return new ViewModel();&#125;// 如果仅执行创建新对象的操作应该命名为 newXXX()public ViewModel newViewModel() &#123; return new ViewModel();&#125;// 如果一定要使用 get() 方法，需要增加创建一次的判读public ViewModel getViewModel() &#123; if(mViewModel == null)&#123; mViewModel = new ViewModel(); &#125; return mViewModel;&#125; 大量使用 byte 内存问题通常我们不会大量使用 byte[] ，一般用他来处理 IO 流，但是当我们有需求频繁进行 IO 时，比如文件读取、网络请求等需求，每次创建新的 byte[] 会占据大量的内存空间，原则上我们应该尽量减少内存空间的开辟，针对这种场景我们可以使用 ByteArrayPool 来管理和复用已经存在的内存空间，避免内存占用过多和内存抖动的发生。 下面是参考 Glide 源码中的一个设计，ByteArrayPool 是一个单例，里面维护一个 Queue，每次使用 byte[] 时，从 Queue 中取出并删除，使用完了再放回去，以便其他人可以继续使用已经开辟的内存空间。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public final class ByteArrayPool &#123; private static final String TAG = "ByteArrayPool"; private static final int TEMP_BYTES_SIZE = 64 * 1024; // 64 KB. private static final int MAX_SIZE = 2 * 1048 * 1024; // 512 KB. private static final int MAX_BYTE_ARRAY_COUNT = MAX_SIZE / TEMP_BYTES_SIZE; private final Queue&lt;byte[]&gt; tempQueue = Util.createQueue(0); private static final ByteArrayPool BYTE_ARRAY_POOL = new ByteArrayPool(); public static ByteArrayPool get() &#123; return BYTE_ARRAY_POOL; &#125; private ByteArrayPool() &#123; &#125; public void clear() &#123; synchronized (tempQueue) &#123; tempQueue.clear(); &#125; &#125; // 从队列中取出一个 byte[],没有就创建新的返回 public byte[] getBytes() &#123; byte[] result; synchronized (tempQueue) &#123; result = tempQueue.poll(); &#125; if (result == null) &#123; result = new byte[TEMP_BYTES_SIZE]; if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, "Created temp bytes"); &#125; &#125; return result; &#125; // 使用完了放回队列，但是要维持总内存不超过 max public boolean releaseBytes(byte[] bytes) &#123; if (bytes.length != TEMP_BYTES_SIZE) &#123; return false; &#125; boolean accepted = false; synchronized (tempQueue) &#123; if (tempQueue.size() &lt; MAX_BYTE_ARRAY_COUNT) &#123; accepted = true; tempQueue.offer(bytes); &#125; &#125; return accepted; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 开发问题汇总]]></title>
    <url>%2Farticle%2F39cb08bb%2F</url>
    <content type="text"><![CDATA[本文主要记录 Android 开发过程中遇到的比较 神（cao）奇（dan）的问题， 一些简单的问题却难以定位，查找问题时耽误很多时间，开发过程中应该从开始就规避这类问题的发生。 Bundle 传递问题为了保证从外面传递过来的数据能够被完整的传递下去，通常我们会直接将原先的 bundle 直接传递下去，例如： 123456789101112131415161718192021222324252627public class DetailPagerAdapter extends FragmentPagerAdapter &#123; Bundle bundle; public DetailPagerAdapter(FragmentManager fm, Bundle bundle) &#123; super(fm); this.bundle = bundle; &#125; @Override public Fragment getItem(int position) &#123; BaseFragment fragment = null; switch (position) &#123; case 0: fragment = new DetailIndexFragment(); break; case 1: fragment = new DetailGraphicFragment(); bundle.putInt("type", 1); break; &#125; if (null != fragment) &#123; fragment.setArguments(bundle); &#125; return fragment; &#125;&#125; 这样会造成的问题是多个对象同时持有了 bundle 的引用，如上面例子中 adapter 的宿主，DetailIndexFragment 和 DetailGraphicFragment 都会持有 bundle 的引用，这会让数据变的难以管理，bundle 里面的数据会莫名其妙的发生改变，而我们难以定位是谁改变了他，好的做法是，创建一个全新的 bundle 并持有当前状态下的数据。 1234567891011121314151617181920212223242526public class DetailPagerAdapter extends FragmentPagerAdapter &#123; Bundle mTransBundle; public DetailPagerAdapter(FragmentManager fm, Bundle bundle) &#123; super(fm); mTransBundle = bundle; &#125; @Override public Fragment getItem(int position) &#123; BaseFragment fragment = null; fragmentBundle = new Bundle(mTransBundle); switch (position) &#123; case 0: fragment = new DetailIndexFragment(); break; case 1: fragment = new DetailGraphicFragment(); fragmentBundle.putInt("type", 1); break; &#125; fragment.setArguments(fragmentBundle); return fragment; &#125;&#125; getter 方法中创建对象案例：在 Activity 的 onResume() 方法中调用了 getViewModel() 获取到 ViewModel 进行一些操作，但是没想到 getter 方法中没做判断每次都会返回新的对象，造成了大量的内存占用。 在 getter 方法中不应该进行创建对象的操作，如果有要加入仅创建一次的判断，因为当别人和自己在使用该方法可能会直接调用，因为对使用者来说，这只是一个获取操作，就会频繁的使用它，并不知道内部返回了一个全新的对象。 12345678910111213141516171819private ViewModel mViewModel;// 不应该在 get 方法中不加判断的创建对象public ViewModel getViewModel() &#123; return new ViewModel();&#125;// 如果仅执行创建新对象的操作应该命名为 newXXX()public ViewModel newViewModel() &#123; return new ViewModel();&#125;// 如果一定要使用 get() 方法，需要增加创建一次的判读public ViewModel getViewModel() &#123; if(mViewModel == null)&#123; mViewModel = new ViewModel(); &#125; return mViewModel;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从 Retrofit 看动态代理 [设计模式]]]></title>
    <url>%2Farticle%2Fe73f8f32%2F</url>
    <content type="text"><![CDATA[本文主要学习代理模式在 Java 下的实现，以及 动态代理 在 Retrofit 中的应用。 代理模式 ：给某一个对象提供一个代理，并由代理对象控制对原对象的引用，它可以在屏蔽对目标对象访问的同时，进行自定义的扩展。 Graphic Design Patterns - 代理模式 优缺优点 代理模式能够协调调用者和被调用者，在一定程度上降低了系 统的耦合度。 远程代理使得客户端可以访问在远程机器上的对象，远程机器 可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。 虚拟代理通过使用一个小对象来代表一个大对象，可以减少系 统资源的消耗，对系统进行优化并提高运行速度。 保护代理可以控制对真实对象的使用权限。 缺点 由于在客户端和真实主题之间增加了代理对象，因此 有些类型的代理模式可能会造成请求的处理速度变慢。 实现代理模式需要额外的工作，有些代理模式的实现 非常复杂。 静态代理我们模拟一个场景：我们要邀请一个歌手来参加一场演唱会，那么我们是不能直接和歌手联系的，我们需要先联系歌手的经纪人，在这里经纪人扮演了代理的角色，他屏蔽了我们对歌手的访问，我们要联系歌手，必须通过经纪人代理实现。 首先定义接口实现 12345// 歌手接口interface SingingInterface &#123; // 开始表演 void performance();&#125; 同时根据接口实现一个真正的歌手类，比如 周董 123456class JayChou implements SingingInterface &#123; @Override public void performance() &#123; log("`快快使用双截棍，哼哼哈嘿--`"); &#125;&#125; 定义经纪人类，它可以与歌手联系，并且屏蔽外界对歌手的访问，而且他还要做一些额外的工作，比如安排歌手档期及收取报酬等。 12345678910111213// 经纪人class StarBroker implements SingingInterface&#123; private SingingInterface mSingingInterface; public StarBroker() &#123; mSingingInterface = new JayChou(); &#125; @Override public void performance() &#123; log("安排歌手档期。"); mSingingInterface.performance(); log("收取报酬。"); &#125;&#125; 最后我们可以预约歌手来参加我们的演唱会啦 12StarBroker starBroker = new StarBroker();starBroker.performance(); 动态代理在静态代理中我们使用代理类来控制对目标对象的访问，实现起来相对麻烦，我们要定义代理类并且让它持有目标对象的引用，而且当需要代理的方法越来越多时，就需要在每个方法中再去调用目标对象的对应方法。 动态代理是一种在运行期间动态生成代理类的方法，他不需要定义代理类的类结构，而是借助 InvocationHandler 接口，对目标对象所有方法进行代理。 关于 InvocationHandler 接口，他只有一个方法： Object proxy 当前的代理类 Method method 代理类被调用的方法 Object[] args 调用方法时传入的参数 1public Object invoke(Object proxy, Method method, Object[] args) throws Throwable 我们动态生成代理类在执行方法时，会通过这个方法，然后我们就可以在这个方法里面去调用目标对象的对应方法，并做一些自己的扩展，达到代理目标对象访问的目的。 我们定义 InvocationHandler 的实现类， 12345678910111213141516class SingingInvocationHandler implements InvocationHandler &#123; // 目标对象 private Object singer; public SingingInvocationHandler(Object singer) &#123; this.singer = singer; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 下面实现了类似经纪人的功能 log("安排歌手档期。"); // 调用目标对象的对应方法 Object invoke = method.invoke(singer, args); log("收取报酬。"); return invoke; &#125;&#125; 借助 SingingInvocationHandler 实现运行期的动态代理，这里说一下几个参数的意义 SingingInterface.class.getClassLoader() =&gt; 是代理类生成需要的的 loader new Class[]{SingingInterface.class} =&gt; 代理类需要实现的接口列表，这里可以是多个 new SingingInvocationHandler(new JayChou()) =&gt; InvocationHandler + 目标对象 1234SingingInterface proxy = (SingingInterface) Proxy.newProxyInstance( SingingInterface.class.getClassLoader(), new Class[]&#123;SingingInterface.class&#125;, new SingingInvocationHandler(new JayChou())); 当我们使用生成的代理类对象 proxy 调用方法时，就会经过 InvocationHandler 里面的实现啦。 12// 执行 SingingInterface 的方法proxy.performance(); 123安排歌手档期。`快快使用双截棍，哼哼哈嘿--`收取报酬。 为了体现动态代理和静态代理的相似之处，上面的写法相对简单，其实也是存在很多问题的，我们生成的代理对象 proxy 可以实现多个接口，执行的所有方法甚至是从 Object 中继承的方法都会经过 InvocationHandler，因此在进行代理是我们必须是选择性的代理部分方法。 声明 TestInterface 用来测试代理类实现多个接口的情况 123interface TestInterface &#123; void testProxyMethod();&#125; 所以我们生成代理类时就变成了如下，此时的 proxy 既是 SingingInterface 的实现类也实现了 TestInterface 1234SingingInterface proxy = (SingingInterface) Proxy.newProxyInstance( SingingInterface.class.getClassLoader(), new Class[]&#123;SingingInterface.class, TestInterface.class&#125;, new SingingInvocationHandler(new JayChou())); 对 InvocationHandler 也进行一下完善，让他可以区分不同的方法的来源，然后选择性的进行代理 12345678910111213141516171819202122232425262728293031class SingingInvocationHandler implements InvocationHandler &#123; // 目标对象 private Object singer; public SingingInvocationHandler(Object singer) &#123; this.singer = singer; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 全部的方法都会被代理到这边，如果是 Object 的方法，不尽兴代理 // 我们可以使用该方法区分，方法来自哪个父类或者接口，选择性的进行代理 if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (method.getDeclaringClass() == TestInterface.class) &#123; return method.invoke(new TestInterface() &#123; @Override public void testProxyMethod() &#123; log("执行了 TestInterface 的方法哦"); &#125; &#125;, args); &#125; // 下面实现了类似经纪人的功能 if (method.getDeclaringClass() == SingingInterface.class) &#123; log("安排歌手档期。"); Object invoke = method.invoke(singer, args); log("收取报酬。"); return invoke; &#125; return null; &#125;&#125; 我们分别执行 Object 、SingingInterface 和 TestInterface 的方法 123456// 执行 Object 的方法proxy.hashCode();// 执行 SingingInterface 的方法((SingingInterface) proxy).performance();// 执行 TestInterface 的方法((TestInterface) proxy).testProxyMethod(); 12345执行了 Object 的方法哦安排歌手档期。`快快使用双截棍，哼哼哈嘿--`收取报酬。执行了 TestInterface 的方法哦 Retrofit 与 动态代理这里不是对 Retrofit 源码进行分析，那需要更大的篇幅，这里只是针对动态代理在 Retrofit 的应用方式进行学习。 作为现在网络请求框架中最受欢迎的 Retrofit，框架设计上最大的特点就是使用了动态代理将网络请求变成一个使用注解配置的过程。 在原来的模式中，我们需要借助 OkHttp 做创建请求，配置数据，发起请求，返回数据，解析数据等一系列操作，而借助动态代理，可以把这些操作都对使用者屏蔽掉，使用者只需要做两件事，那就是配置请求和处理解析好的数据，这样更大程度上的专注于业务逻辑。 整个过程是这样的： 我们声明包含一系列请求方法的接口类 ApiService，并在方法上使用注解对 Path、Header、Query 等请求必须的参数进行配置。 借助 Retrofit 的静态方法 create() 动态生成 ApiService 类型的代理对象返回给调用者。 当调用者调用代理类的方法发起请求时，就会进入 InvocationHandler 中 从注解中获取到全部的配置，初始化请求，发起请求，等待返回，解析数据 将解析好的数据返回，调用者就会拿到期望的数据 声明请求的 ApiService，它只是一个接口，普普通通的接口，每个方法上面的注解用来承载一些请求的配置 123456public interface ApiService&#123; @GET("/page/list") @Headers("domain:baidu") Observable&lt;List&lt;String&gt;&gt; getList(@Query("type") int type);&#125; 使用 Retrofit 的静态方法创建动态代理对象 123ApiService apiService = mRetrofit.create(ApiService.class);apiService.getList(2); 看一下 create() 方法中的实现 12345678910111213141516171819202122232425public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; // 创建请求、发起请求、解析数据 ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;);&#125; 我们不去关注解析注解配置和请求发起的具体实现，看起来和我们之前介绍的动态代理实现是一样的，所以 Retrofit 选择了一种非常合适的设计模式，让原本很复杂的操作变得很简单很优雅。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Https 详解 [网络]]]></title>
    <url>%2Farticle%2F882ae1dd%2F</url>
    <content type="text"><![CDATA[超文本传输安全协议（HTTPS，常称为 HTTP over TLS/SSL）是一种通过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。 本文主要介绍 ： Https 如何保证数据传输的安全 CA 的存在及其安全性 证书工具 keytool 证书验证流程 Https 握手流程 Android 下进行 Https访问 TLS/SSLTCP (Transmission Control Protoco) 传输层控制协议 TLS (Transport Layer Security) 传输层安全协定 SSL (Secure Socket Layer) 安全套接层 HTTP(Hypertext Transfer Protocol) 基于 TCP 协议，无连接，每次连接只处理一个请求，结束后断开连接；无状态，无法保持用户状态，使用 cookie 和 session 解决。 HTTPS(HTTP over TLS/SSL) 安全的 http 协议，HTTP 协议和 TCP 协议之间增加了 TLS/SSL 保证数据的安全传输。 历史进程： 12345678910111213141994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。1996年，SSL 3.0版问世，得到大规模应用。1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版。2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。最新的变动是2011年TLS 1.2的修订版。TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。 Https 安全性HTTP 协议的不安全性体现在 3 个方面： 风险 描述 https解决方案 窃听风险 攻击者可以获知消息内容 消息加密 篡改风险 攻击者可以篡改消息内容 消息摘要 冒充风险 攻击者可以冒充其他人参与通信 CA 身份认证 CA 不可信 信任的 CA 乱签发证书 证书锁 窃听/嗅探指的是路由上的攻击者，可以偷窥到传输的消息内容。 解决方案： 使用对称加密算法加密通信内容，窃听者获取到消息也无法识别，存在问题 -&gt; 密钥传递的安全性，在网络上面的通信双方都是陌生人，无法识别身份，密钥要通过网络传输时很有可能被窃取。❌ 使用非对称加密算法加密通信内容，发布的公钥用来加密，私钥用来解密，即使公钥被窃取，依然无法解密消息内容。存在问题 -&gt; 速度慢，消耗大；公钥被公开，如果回发私钥加密的信息，任何持有公钥的人都可以解密。❌ 最终，消息内容仍旧使用对称加密算法来加密，但是前期对称加密的密钥交换使用非对称加密来进行，客户端使用服务端公钥加密对称加密的密钥，这样就只有拥有私钥的服务端可以获取到加密内容，由于对称加密密钥长度有限，加密的时间可以忽略不计。✅ 以上，可以防止嗅探的问题，路由上面的攻击者即使获取到消息也无法识别消息的内容。 消息篡改消息加密以后攻击者无法获取消息内容的含义，但是可以篡改消息内容，篡改之后接收方也无法感知。 解决方案： 采用 消息摘要（见文末注脚） 算法可以验证数据的完整性，我们将发送的消息进行摘要，连同消息一起发送给接收方，接收方拿到消息之后对消息做同样的摘要处理，对比摘要结果，即可知道消息有没有被篡改。 以上，可以解决消息完整性和真实性的问题。 中间人攻击中间人攻击（Man-in-the-middle Attack，MITM）指的是攻击者在链路上伪装自己，与通讯双方分别建立联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。 作为 A 和 B 通信路由上的攻击者 M，作为中间人伪造自己的身份。A 向 B 请求用于通信的 PK_A，但是被中间人 M 截获，他伪造生成了假的公钥 PK_M，发送给了 A，同时向 B 请求并获取了 B 的公开密钥 PK_B，原来安全的通信过程 A(使用 PK_B 加密) -&gt; 安全 -&gt; B(使用 SK_B 解密)，现在变成了 A(使用 PK_M 加密) -&gt; M(使用 SK_M 解密获取明文内容，再用 PK_B 加密，可能篡改数据) -&gt; B(使用 SK_B 解密)。 出现问题的原因在于，密钥在交换的初期是不安全的，网络上的通信双方，无法确定对方的身份，即无法获悉当前的公钥是不是自己想要的公钥。 解决方案： 引入第三方公正作信用背书，第三方公正具有权威性，他和通信双方没有关系，接收方无条件信任公证机构，也就会信任他签名的信息。这种机构被称为 CA（Certificate Authority 机构，即数字证书认证机构。CA 机构与浏览器和操作系统厂商合作，将公钥内置在浏览器和操作系统中，也就是不走网络传输了，这样一定程度上保证了公钥不会被窃取篡改。 服务端 Server 将自己的消息（消息内容大致包括电子签证机关的信息、公钥用户信息、公钥、权威机构的签字和有效期等）进行摘要之后，发给 CA 机构 AUTH 签发证书，Server 使用自己的私钥对消息摘要加密，形成证书，并将证书和消息内容发送给 Client，Client 收到后，发现是 AUTH 的证书，同时对 AUTH 是信任的，则会使用 AUTH 的公钥对证书进行解密（这里涉及证书链的验证，其实要更加复杂），获取到消息摘要，同时对收到的消息进行摘要，对比，如果一致则说明内容没有被篡改，是可信的，因为生成加密数据的私钥只有 CA 机构才有，这一过程称为验证数字签名。 以上，可以解决中间人攻击的文图，另外涉及到非对称加密的两种应用场景，详细介绍见文末非对称加密应用场景。 CA 错误签发受信任的 CA（证书颁发机构）有好几百个，他们成为整个网站身份认证过程中一个较大的攻击面。实际上，目前由于 CA 失误导致错误签发证书，以及个别 CA 出于某些目的（如监控加密流量）故意向第三方随意签发证书这两种情况时有发生。现有的证书信任链机制最大的问题是，任何一家受信任的 CA 都可以签发任意网站的站点证书，这些证书在客户端看来，都是合法的，是可以通过验证的。 解决方案： 证书锁（Certificate Pinning），证书锁是为了防范由 「伪造或不正当手段获得网站证书」 造成的中间人攻击。 证书锁类似于 HPKP 技术（下面有简单介绍），给予我们主动选择信任 CA 的权利。它的工作原理就是使用预先设置的证书指纹和服务器传过来的证书链中的证书指纹进行匹配，只要有任何一对指纹匹配成功，则认为是一次合法的连接，否则禁止本次链接。 也就是说，使用证书锁之后，不是所有被系统信任的 CA 都可以通过验证，只有我保存了指纹的一些 CA 签发的证书才可以，比如有 100 个 CA 机构，但我就信任其中一个，我可以保证这个 CA 不会乱签发证书，那我就只保存这个 CA 的指纹，即使攻击者从其他的 99 个 CA 签发证书，对我进行攻击，也无法完成连接。 证书锁定增加了安全性，但限制了你的服务器团队升级 TLS 证书的能力。 以上，可以解决 CA 机构签发证书权威性不足的问题，相关解决方案详见文末 签发证书权威性问题 🔥 综上，对称加密通信 + 非对称加密交换密钥 + CA 认证身份 + 证书锁锁定证书指纹 共同保证了 https 的安全性。 CA 安全性作为全网 https 连接的权威公正，CA 的安全性至关重要。 安全保存 CA从根 CA 开始到直接给客户发放证书的各层次 CA，都有其自身的密钥对。CA 中心的密钥对一般由硬件加密服务器在机器内直接产生，并存储于加密硬件内，或以一定的加密形式存放于密钥数据库内。加密备份于 IC 卡或其他存储介质中，并以高等级的物理安全措施保护起来。 密钥的销毁要以安全的密钥冲写标准，彻底清除原有的密钥痕迹。需要强调的是，根 CA 密钥的安全性至关重要，它的泄露意味着整个公钥信任体系的崩溃，所以 CA 的密钥保护必须按照最高安全级的保护方式来进行设置和管理。CA 的私钥是自己靠上述方法保管的，不对外公开。 所以 CA 密钥的安全性依赖于物理硬件的安全性，不通过网络传输避免了被攻击的可能。 CA 的公钥是厂商跟浏览器和操作系统合作，把公钥默认装到浏览器或者操作系统环境里。比如 firefox 就自己维护了一个可信任的 CA 列表，而 chrome 和 IE 使用的是操作系统的 CA 列表。 证书链现在大的 CA 都会有证书链，证书链的好处一是安全，保持根 CA 的私钥离线使用。第二个好处是方便部署和撤销，即如果证书出现问题，只需要撤销相应级别的证书，根证书依然安全。 根 CA 证书都是自签名，即用自己的公钥和私钥完成了签名的制作和验证。而证书链上的证书签名都是使用上一级证书的密钥对完成签名和验证的。 证书验证证书是否是信任的有效证书 是否信任 ：接收方内置了信任根证书的公钥，需要证书是不是这些信任根证书签发的或者信任根证书的二级证书机构颁发的。 是否有效：证书是否在有效期内。 是否合法：对方是不是上述证书的合法持有者，证明对方是否持有证书的对应私钥。验证方法两种，一种是对方签个名，我用证书验证签名；另外一种是用证书做个信封，看对方是否能解开。 是否吊销：验证是否吊销可以采用黑名单方式或者 OCSP 方式。黑名单就是定期从 CA 下载一个名单列表，里面有吊销的证书序列号，自己在本地比对一下就行。优点是效率高。缺点是不实时。OCSP 是实时连接 CA 去验证，优点是实时，缺点是效率不高。 自签名证书如何验证自签名证书是自己给自己签发的证书，也就是说自己做自己的 CA 机构，为自己担保，因此无法内置在系统当中，因此我们通常会在客户内置一个证书文件，自己进行校验。 简单来说，握手流程需要两对密钥对： 一对 CA 的密钥对 JKS_A，由 CA 机构维护，通常他的公钥内置在 os 中，用来签名服务端信息摘要，保证服务端公钥的真实性，避免中间人攻击。 一对服务器的密钥对 JKS_B，他是握手过程中随机生成的，然后用「它的公钥及其他内容」的摘要去向 CA 实时签发证书，用来进行对称密钥的加密传输。 自签名证书就是不走 CA 机构，而是自己生成一对密钥对 JKS_C，他的作用就好比 CA 的密钥对 JKS_A，也是为了保证公钥的真实性，握手过程和原来一样，只是我们不需要去 CA 签发证书了，用自己的 JKS_C 签发就可以了；同样因为 JKS_C 是我们自己的密钥对，公钥没有被内置在 os 中，所以此时需要我们自己把 cert 文件（JKS_C 的公钥）放到本地，自己完成原本由 os 完成的 CA 校验任务。 双向验证双向验证指的是，不光客户端要验证来自服务器的连接是不是可靠，服务器也要验证客户端。 服务端也会内置一套受信任的 CA 证书列表，用于验证客户端证书的真实性。验证过程和客户端验证服务端类似。 Https 握手单向验证握手过程： 1、Client Hello ➡️ 客户端向服务器发送握手信息，告知自己支持的加密算法、摘要算法、安全层协议版本、随机数 Random-Secret-C。 2、Server Hello ⬅️ 服务端随机生成本次握手需要的非对称加密的密钥对（私钥+公钥），将来用来传输对称加密密钥。 服务端生成消息，内容包含随机数 Random-Secret-S，确定的一组加密算法和摘要算法，服务端公钥，域名信息等。 服务端对信息内容摘要，使用摘要的信息向 CA 机构申请的签名证书。 服务端向客户端发送消息和申请的证书。 如果需要双向验证的话，请求客户端证书。 3、验证服务端证书，提取服务端公钥 ➡️ 客户端从信任证书列表中发现是受信任的证书，会首先验证证书是否被信任、有效性、合法性等信息，验证过程参照上面的 证书验证。 验证通过，客户端使用 CA 机构的公钥对证书解密，拿到消息的摘要，对真正的消息内容进行摘要，对比确定消息没有被篡改，则取出服务端公钥。 如果需要双向验证的话，向服务端发送自己的证书。 客户端生成随机数字 Pre-Master-Secret，将其进行摘要处理，使用服务端公钥对消息和摘要结果加密，发送给服务器，并发送一个编码改变通知，说明以后将会开始加密通信。 4、生成对称加密密钥 ⬅️ 如果需要双向验证的话，首先验证客户端证书，验证过程类似客户端验证，验证失败则断开连接 服务器使用私钥对收到的信息解密，对消息进行摘要对比无误，则说明对称加密的密钥没有被篡改，然后使用 Random-Secret-C,Random-Secret-S,Pre-Master-Secret 生成最终将要进行对称加密通信的密钥 Master-Secret。 服务器使用 Master-Secret 加密一段握手信息及其摘要，发送给客户端，并发送一个编码改变通知，说明以后将会开始加密通信。 5、客户端验证加密结果，握手结束 👌 客户端使用 Random-Secret-C,Random-Secret-S,Pre-Master-Secret 生成同样的对称加密密钥 Master-Secret，使用密钥解密，并验证信息摘要，没有问题则握手结束。 后面的通信将会使用新生成的对称加密密钥加密进行。 图解： 问题记录Q：为什么要有 3 个随机数？ 不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于 SSL 协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。对于RSA密钥交换算法来说，Pre-Master-Secret 本身就是一个随机数，再加上 hello 消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。 Pre-Master 的存在在于 SSL 协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么 Pre-Master-Secret 就有可能被猜出来，那么仅适用 Pre-Master-Secret 作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上 Pre-Master-Secret 三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。” Q：放在 Android 客户端的 cert 文件是啥？ 是自签名证书的公钥，自签名证书就是自己做自己的 CA 机构，服务端会自己维护一个密钥对 JKS，他就相当于 CA 的签发证书的密钥对，在握手过程中服务器不需要走 CA 申请签名证书了，自己签发就可以，原本 CA 的公钥被内置在 os 中，CA 的验证不需要我们来关注，但是现在是自签名的，自己做自己的 CA，所以 JKS 的公钥我们要内置在客户端中，自己完成验证过程，替代原来 os 的验证。 证书工具-keytool提取证书内容为一个字符串 1keytool -printcert -rfc -file [srca.cer] 生成密钥对 1keytool -genkey -alias [march_server] -keyalg RSA -keystore [march_server.jks] -validity 3600 -storepass [123456] 读取密钥对信息 1keytool -list -v -keystore [srca.jks] -storepass [123456] 提取公钥，签发 cert 文件 1keytool -export -alias march_server -file march_server.cer -keystore march_server.jks -storepass 123456 将客户端公钥导入客户端密钥对中，主要是服务器不能使用 cert 证书，需要导入到 jks 文件中 1keytool -import -alias [march_client] -file [march_client.cer] -keystore [march_client_for_server.jks] 搭建 https 服务这部分内容参考了 CSDN-hongyang-Android Https 完全解析，这里做一个汇总和整理。 借助 tomcat 搭建简单的 https 服务，主要是用来测试，之前使用 12306 的证书测试，但是前段时间 12306 证书换掉了，现在已经是正式证书了，所以不得以需要自己搭建一个简单的服务来做访问测试。 搭建单向验证的 https 服务 首先我们准备好密钥和证书，使用 keytool 工具生成服务端 march_server.jks 密钥对，然后提取服务端公钥 march_server.cert。 配置服务，主要是配置 tomcat/conf/server.xml 文件，添加一个如下的 Connector。 123456789101112131415161718192021222324&lt;!-- https 测试服务 clientAuth 和 truststoreFile 配置服务器验证客户端 keystoreFile 和 keystorePass 配置客户端验证服务器 --&gt; &lt;Connector clientAuth="false" keystoreFile="/Users/march/Documents/march_server.jks" keystorePass="123456" disableUploadTimeout="true" enableLookups="true" SSLEnabled="true" acceptCount="100" maxSpareThreads="75" maxThreads="200" minSpareThreads="5" protocol="org.apache.coyote.http11.Http11NioProtocol" scheme="https" secure="true" port="8443" sslProtocol="TLS"/&gt; 搭建双向验证的 https 服务 再生成客户端密钥对 march_client.jks，然后签发客户端公钥 march_client.cert，为了能在服务端使用，将 march_client.cert 导入到新的密钥对 march_client_for_server.jks。使用的命令都可以在上一节找到，生成这几个密钥，是为了搭建后面的服务作准备。 更改 conf/server.xml 配置 12345678910111213141516171819202122232425&lt;!-- https 测试服务 clientAuth 和 truststoreFile 配置服务器验证客户端 keystoreFile 和 keystorePass 配置客户端验证服务器 --&gt; &lt;Connector clientAuth="true" truststoreFile="/Users/march/Documents/march_client_for_server.jks" keystoreFile="/Users/march/Documents/march_server.jks" keystorePass="123456" disableUploadTimeout="true" enableLookups="true" SSLEnabled="true" acceptCount="100" maxSpareThreads="75" maxThreads="200" minSpareThreads="5" protocol="org.apache.coyote.http11.Http11NioProtocol" scheme="https" secure="true" port="8443" sslProtocol="TLS"/&gt; 此时浏览器已经不能访问 Android 进行 Https 访问如果你的证书是购买的 CA 签发的证书，是可以直接进行 https 访问的，不需要做什么特殊处理，下面主要介绍使用自签名证书的情况。 启用双向验证时，Android 客户端也不能直接使用 march_client.jks 需要转为 bks 文件，使用下面的工具。jks 转 bks 工具 注：这部分不是说如何发请求，只是讨论怎么配置证书和密钥对去发起 Https 访问。 在 Android 中进行 Https 访问，主要牵扯到以下几个关键类： TrustManagerFactory，它主要是用来导入自签名证书，用来验证来自服务器的连接。 KeyManagerFactory，当开启双向验证时，用来导入客户端的密钥对。 SSLContext，SSL 上下文，使用上面的两个类进行初始化，就是个上下文环境。 😠 都让开，我要贴代码了！ SSLContext为了简单起见，我们先来看看如何生成 SSLContext 12345678910111213141516171819/** * 创建 SSLContext * @param keyManagerFactory 用于双向验证，不需要可以直接为空 * @param trustManagerFactory 用于导入证书 * @return SSLContext */private SSLContext getSSLContext(@Nullable KeyManagerFactory keyManagerFactory, TrustManagerFactory trustManagerFactory) throws NoSuchAlgorithmException, KeyManagementException &#123; if (trustManagerFactory == null) return null; SSLContext sslContext = SSLContext.getInstance("TLS"); KeyManager[] keyManagers = null; if (keyManagerFactory != null) &#123; keyManagers = keyManagerFactory.getKeyManagers(); &#125; sslContext.init(keyManagers, trustManagerFactory.getTrustManagers(), new SecureRandom()); return sslContext;&#125; TrustManagerFactory导入客户端证书，生成 TrustManagerFactory 123456789101112131415161718192021222324252627282930/** * 导入客户端证书，生成 TrustManagerFactory * @param serverCertInputStreams 证书的输入流 * @return TrustManagerFactory */private TrustManagerFactory getTrustManagerFactory(InputStream... serverCertInputStreams) throws KeyStoreException, CertificateException, NoSuchAlgorithmException, IOException &#123; if (serverCertInputStreams == null || serverCertInputStreams.length == 0) &#123; return null; &#125; CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509"); // 为证书设置一个keyStore，并将证书放入 keyStore 中 KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); keyStore.load(null, null); int index = 0; for (InputStream inputStream : serverCertInputStreams) &#123; String alias = Integer.toString(index++); Certificate certificate = certificateFactory.generateCertificate(inputStream); keyStore.setCertificateEntry(alias, certificate); &#125; // 创建 TrustManagerFactory TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); trustManagerFactory.init(keyStore); TrustManager[] trustManagers = trustManagerFactory.getTrustManagers(); if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) &#123; throw new IllegalStateException("Unexpected default trust managers:" + Arrays.toString(trustManagers)); &#125; return trustManagerFactory;&#125; KeyManagerFactory双向验证时，配置客户端密钥对，生成 KeyManagerFactory 12345678910111213141516171819/** * 双向验证时，配置客户端密钥对，生成 KeyManagerFactory * * @param clientCertInputStream 密钥对输入流 * @param passWd 密钥对密码 * @return KeyManagerFactory */private KeyManagerFactory getKeyManagerFactory(InputStream clientCertInputStream, String passWd) throws KeyStoreException, CertificateException, NoSuchAlgorithmException, IOException, UnrecoverableKeyException &#123; if (clientCertInputStream == null || passWd == null) &#123; return null; &#125; //本地证书 初始化keystore KeyStore clientKeyStore = KeyStore.getInstance(KeyStore.getDefaultType()); clientKeyStore.load(clientCertInputStream, passWd.toCharArray()); KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); keyManagerFactory.init(clientKeyStore, passWd.toCharArray()); return keyManagerFactory;&#125; Init Connection这样我们就拿到了已经生成好的 SSLContext，我们需要的 KeyManagerFactory，TrustManagerFactory 都已经加到 SSLContext 里面了。 如果是用 HttpsURLConnection 1connection.setSSLSocketFactory(sslContext.getSocketFactory()); 如果是用 OkHttp 12345678910111213// 这个方法已经过时了okHttpClientBuilder.sslSocketFactory(sslContext.getSocketFactory());// 新的方法需要一个 X509TrustManager，那我们就从 TrustManagerFactory 取出来给他TrustManagerFactory trustManagerFactory = getTrustManagerFactory(serverCertInputStreams);KeyManagerFactory keyManagerFactory = getKeyManagerFactory(clientCertInputStream, passWd);if (trustManagerFactory != null) &#123; X509TrustManager x509TrustManager = (X509TrustManager) trustManagerFactory.getTrustManagers()[0]; SSLContext sslContext = getSSLContext(keyManagerFactory, trustManagerFactory); if (x509TrustManager != null &amp;&amp; sslContext != null) &#123; okHttpClientBuilder.sslSocketFactory(sslContext.getSocketFactory(), x509TrustManager); &#125;&#125; HostnameVerifier另外 HostnameVerifier 也是必要的，这个 HttpsURLConnection 和 OkHttp 没啥差别 12345678910111213connection.setHostnameVerifier(new HostnameVerifier() &#123; @Override public boolean verify(String hostname, SSLSession session) &#123; return true; &#125;&#125;);okHttpClientBuilder.hostnameVerifier(new HostnameVerifier() &#123; @Override public boolean verify(String hostname, SSLSession session) &#123; return true; &#125;&#125;); 推荐阅读腾讯云-HTTPS 原理浅析及其在 Android 中的使用 阿里移动安全 CSDN 如何理解HTTP协议的 “无连接，无状态” 特点？ 知乎 一个故事让你彻底理解 Https 简书 HTTPS 是如何保证安全的？ 个人博客-饿了么Android-聊聊 Android HTTPS 的使用姿势 个人博客-细说 CA 和证书 个人博客-https详解 概要介绍 CSDN-hongyang-Android Https 完全解析 阮一峰-SSL/TLS协议运行机制的概述 注脚消息摘要（Message Digest） 指的是将长度不固定的参数作为输入参数，运行特定 hash 函数，生成固定长度的输出，这个输出就是消息的摘要，常用算法有 MD5 和 SHA1，摘要算法是单向不可逆的，即无法从摘要重新反向出原消息的内容。 信用背书 票据的收款人或持有人在转让票据时，在票据背面签名或书写文句的手续。背书的人就会对这张支票负某种程度、类似担保的偿还责任。 非对称加密的两种应用场景 某用户使用自己的私钥对数据加密，任何人都可以使用公钥对数据进行解密，因为私钥只有该用户持有，则说明该数据一定出自于该用户。公众可以用这一方法验证内容是否完整，是否被篡改，接受者可以认定该内容出自该用户，该用户也无法抵赖，这被称作数字签名。 某用户使用公开的公钥对数据进行加密，那么可以保证只有发布公钥的一方可以对数据进行解密，别人无法获取数据的内容，保证数据传递的安全。 应对 CA 签发证书权威性问题的解决方案 Google 推动的 Certificate Transparency 技术，它旨在通过开放的审计和监控系统，提高 HTTPS 网站证书安全性。CT 技术能改善这种情况，但 CT 还没有普及，现阶段浏览器不能贸然阻断没有提供 SCT 信息的 HTTPS 网站。CT 介绍 HTTP Public Key Pinning 技术 HPKP 介绍]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>NetWork</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片处理-1-马赛克和涂鸦效果]]></title>
    <url>%2Farticle%2F245d7c3b%2F</url>
    <content type="text"><![CDATA[图片处理系列之涂鸦效果 其实马赛克效果是我们最常见的涂鸦效果之一，可以用来局部遮挡图片，但是涂鸦效果不仅仅是只有马赛克一种，另外还有纯色效果（类似微信的涂鸦），poly 效果（类似马赛克），高斯模糊效果等等，它们实现的方法类似，都是对图片的遮挡，所以本文将这种效果称之为 涂鸦效果 ， 本项目实现的涂鸦效果模仿的是美图的实现，主要有以下特点： 支持纯色、马赛克、poly、高斯模糊和图片等效果，并具有扩展性。 手势支持 path(跟随手指的路径) 和 rect(跟随手指的矩形区域) 支持绘制和橡皮擦自由切换 支持多个涂鸦效果累加 写在前面]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weex 开发 [Weex]]]></title>
    <url>%2Farticle%2F41ed2d2f%2F</url>
    <content type="text"><![CDATA[前几天看知乎，Evan You 叫 Weex 作 Vue-Native😊 本文主要学习如何使用 Weex 常用组件进行开发工作，再根据开发过程中遇到的问题，完善补充。 Tips 不支持相对单位 em，rem 等，只能使用 px； 不支持 css 组合写法，只能设置一个属性值，如 border: 1 solid red; &lt;image&gt; 在 ios 平台 border 不支持设置不同的 radius； 不支持百分比 根布局必须是 &lt;div&gt;、&lt;scroller&gt; 事件最好定义成有意义的形式，不然有时会出问题，例如 @change=&quot;change&quot; 监听 change 事件没问题，但是 @scroll=&quot;scroll&quot; 就会出现监听不到的问题。 标签属性一定要写成标签属性的形式 porperty=value，不能用 css 属性代替，有些属性在 Android 上面支持，但是在 ios 那边不支持。 当不是根元素的 div 嵌套列表时，比如 list，列表在 ios 上无法显示出来，要显式的指定 div 的高度，有点类似两个可滑动的组件套在一起，无法测量高度的情况。 使用 :style 支持动态设置多个属性时，如果值带有单位，则一定要使用 &#39;&#39; 包含，中间以逗号分隔，如 :style=&quot;{width:&#39;750px&#39;,color:red,height:height+&#39;px&#39;}&quot; 盒模型 Weex 盒模型的 box-sizing 默认为 border-box，即盒子的宽高包含内容、内边距和边框的宽度，不包含外边距的宽度。 width/height - 指的是 content + padding + border 部分的尺寸 1234.frame&#123; width:100px; height:100px;&#125; padding - 内边距，content 和 border 之间的距离 12345.frame&#123; padding:100px; padding-top:100px; padding-xxxx:100px;&#125; margin - 外边距，元素与元素之间的距离 12345.frame&#123; margin:100px; margin-top:100px; margin-xxxx:100px;&#125; border - 边框 123456789101112.frame&#123; /* solid 直线，默认值；dashed 虚线；dotted 点线；*/ border-style: solid | dashed | dotted; border-xxxx-style: solid | dashed | dotted; border-color:#0f0f0f; border-xxxx-color:#0f0f0f; /* 先 top/bottom，后 left/right */ border-radius:10px; border-xxxx-yyyy-radius:10px;&#125; FlexBoxflexbox 是 CSS3.0 新的布局模式，Weex 对它进行了部分的支持。 flexbox 是唯一的默认的布局模式，不需要指定 display: flex;，默认所有的容器类元素都是 flex 容器。 布局方向 1234.frame&#123; /* row,左到右排列；column,上到下排列*/ flex-direction: row | column;&#125; 主轴方向元素的排列 12345678910.frame&#123; /* flex-start : 元素全部靠左 flex-end : 元素全部靠右 center : 元素居中 space-between : 元素之间间距相同，分散排列，两边不留白 space-arround : 元素之间间距相同，分散排列，两边留间距的一半 */ justify-content: flex-start | flex-end | center | space-between | space-arround;&#125; 侧轴方向元素的排列。 123456789.frame&#123; /* flex-start : 元素靠顶部对齐； flex-end : 元素靠底部对齐； center : 居中 stretch : 拉伸到 flex 容器大小 */ align-items : flex-start | flex-end | center | stretch;&#125; flex 成员项 flex 属性定义了 flex 成员项可以占用容器中剩余空间的大小。如果所有的成员项设置相同的值 flex: 1，它们将平均分配剩余空间. 如果一个成员项设置的值为 flex: 2，其它的成员项设置的值为 flex: 1，那么这个成员项所占用的剩余空间是其它成员项的 2 倍。 123.frame&#123; flex:2;&#125; pseudo主要支持 active，focus，enabled，disabled。所有组件支持 active，只有 input 和 textarea 支持 focus。 在客户端中，active 表示组件被按压时的状态，focus 表示组件获取到焦点时的状态，enabled 表示可用时的状态，disable 表示不可用时的状态。 在 ios 上，enable 没有效果。 优先级： 1234active &gt; focus &gt; enableactive &gt; disabled disabled 是一种消极状态，disabled 和 focus、enable 这类积极的状态不会冲突。 div不可嵌套层级过深，控制在 10 层以内，避免性能问题； 不能在 div 中直接写文字，需要使用 &lt;text&gt; 组件； 即使高度超出范围 div 也不能滑动； web不支持 click 和 longpress 事件 标签属性 12// 加载的地址src = "https://m.alibaba.com" 事件，event 里面内容很多 12345678// 页面开始加载@pagestart// 页面加载完成@pagefinish// 加载出现错误@error video内部只能包含 &lt;text&gt; 标签 标签属性 12345678// 播放地址src="url"// 播放状态，控制这个值可以控制播放和暂停play-status="play|pause"// 加载完成后自动播放auto-play = true 事件 1234567891011// 每次开始播放，自动播放或者暂停后播放都会触发@start// 暂停时触发@pause// 播放完成时触发@finish// 播放失败时触发@fail switch标签属性 12checked = true // 是否选中disabled = false // 是否不可用 文档中提到，下面的样式不能使用，测试发现，width／height、margin、border 这些属性都是可以使用的，不过确实有部分属性在 ios 上面没有效果。 1234567widthheightmin-widthmin-heightmarginpaddingborder 事件 123456// 状态切换时触发@changeevent =&gt; value &#123;boolean&#125; : 选中否 timestamp : 时间戳 A它是一个容器类的标签，看 Android 这边的源码，是继承自 div 标签，a 和 html 里面的 a 标签差不多，但是不能包含文本，如果要有文本需要使用 &lt;text&gt; 标签。 点击之后会调用一个名为 event 的 module 的 openURL 方法，这个 module 需要我们来注入到 sdk 中，参数就是 href。 123&lt;a class="button" href="http://g.tbcdn.cn/ali-wireless-h5/res/0.0.16/hello.js"&gt; &lt;text class="text"&gt;Jump&lt;/text&gt;&lt;/a&gt; image「image」标签用来显示图片，必须指定 width 和 height，否则无法显示，不能包含子组件， 标签属性 1234567891011// 显示的图片地址src = "http://www.abc.com/xxx.jpg" // 图片下载时的默认图，没有找到方法测试 placeholder = ".."// 显示模式// stretch 是默认值，拉伸图片填充，fitXY// cover 将会放大图片然后裁剪，centerCrop// contain 长边填充满，短边按比例，保证图片比例不被破坏，fitCenterresize = stretch | cover | contain 事件 1234567// 图片加载成功监听@load = "loadImageOver"result =&gt; success &#123;boolean&#125;: 是否加载成功 size =&gt; 图片原始宽高 naturalWidth &#123;number&#125; naturalHeight &#123;number&#125; 方法 12345678910// 将图片保存到本地save(callback(result))result =&gt; success &#123;boolean&#125;: 是否保存成功 errorDesc &#123;string&#125;: 错误信息，success为false时返回eg:var el = this.$refs.image_ref;el.save(result =&gt; this.logt("save image " + result.success)); text + input + textarea文本样式汇总 1234567891011.mytext &#123; lines: 2; /* 文本行数，默认0不限制 */ color: red; /* 文本颜色*/ font-size: 40px; /* 文字大小 ios,h5默认32,android分设备不同*/ font-style: italic; /* normal正常，italic斜体 */ font-weight: bold; /* 值必须为整百的数字,normal(400)bold(700),ios支持100-900,android支持normal和bold，也就是400，700，lighter和bolder不支持 */ text-decoration: underline; /* underline(下划线) line-through(横划线) none(无，默认) */ text-align: center; /* left center right 默认值为 left，目前暂不支持 justify, justify-all */ text-overflow: ellipsis; /* 文字超出后截断样式，clip 直接截断，ellipsis 显示省略号 */ font-family: "iconfont2";&#125; 「text-decoration」，已经支持前后带有空格显示，当带有空格时，如果加了 decoration，在 android 上面空格的地方也会有装饰，ios 只会在文字的地方有。 「font-family」，在生命周期方法 beforeCreate 为页面加载一套字体 12345678beforeCreate() &#123; var domModule = weex.requireModule("dom"); // 目前支持ttf、woff文件，不支持svg、eot类型,moreItem at http://www.iconfont.cn/ domModule.addRule("fontFace", &#123; fontFamily: "iconfont2", src: "url('http://at.alicdn.com/t/font_1469606063_76593.ttf')" &#125;);&#125; text组件 text 具有 value 属性，用来表示显示的值，当 value 和内容都指定时，将会显示内容的值。 1&lt;text class='mytext' value="test1"&gt; test2 &lt;/text&gt; input组件 input 标签属性，需要注意的是如果标签中间写了文案，会显示在组件下方。 12345678910111213141516maxlength = 10 // 可以输入的最长长度return-key-type = 'done' // default,done,search,send,go,next 回车键的样式disabled = false // 是否可以输入，默认false,为true时不可以输入autofocus = true // 自动获得焦点，弹出键盘placeholder = '请输入' // 输入提示文案type = "number" // 输入类型，text,password,url,email,tel,number 约束不是强约束，用户一样可以切换键盘样式。value = "默认文案" // 默认填充的文字&lt;input class='myinput' maxlength=10 return-key-type='done' disabled=false autofocus=true placeholder='hint' type="number" value="11"&gt; 这里的文案会显示在组件下面 &lt;/input&gt; 伪类 123456789101112.myinput:active &#123; color: purple; /* press时的状态，*/&#125;.myinput:focus &#123; color: green; /* 获得焦点的状态*/&#125;.myinput:enabled &#123; color: orange; /* 可用时的状态，ios 无效果*/&#125;.myinput:disabled &#123; color: sienna; /* 不可用时的状态*/&#125; 支持的 css 属性 123456同样支持 color,font-size,fone-weight,font-style,text-align 属性.myinput &#123; /*提示文案的颜色*/ placeholder-color: blue;&#125; 事件 1234567891011121314151617181920212223242526@input 输入监听，每次输入内容变化，会调event =&gt; value &#123;string&#125; : 文本内容 timestamp : 时间戳@focus 获得焦点监听event =&gt; timestamp : 时间戳 @blur 失去焦点监听event =&gt; timestamp : 时间戳 @change 输入完成且内容发生改变监听，发生在 blur 之后event =&gt; value &#123;string&#125; : 文本内容 timestamp : 时间戳@return 键盘回车键监听event=&gt; returnKeyType &#123;string&#125; : 设置的return-key-type value &#123;string&#125; : 文本内容 方法，为 input 组件设置 ref=&quot;input_ref&quot; 1234567891011121314151617181920212223242526var el = this.$refs["input_ref"];使 input 获取焦点，弹出键盘focus() eg:el.focus();使 input 失去焦点，隐藏键盘blur() eg:el.blur();设置选中区域setSelectionRange(start,end)eg:el.setSelectionRange(0,el.attr.value.length);获取选中区域， ios 不支持getSelectionRange(event&#123;selectionStart,selectionEnd&#125;)eg:el.getSelectionRange(event =&gt; &#123; this.logt(event.selectionStart + " | " + event.selectionEnd);&#125;); textarea多行文本输入 textarea 和 input 基本类似， 他们俩的差别： 事件上，textarea 不支持 @return 事件 方法上， 均支持 标签属性上，增加了 rows 属性，不支持 return-key-type，max-length，type，支持的属性汇总如下： 12345rows = 3 // 指定组件的高度，默认2disabled = false // 是否可以输入，默认false,为true时不可以输入autofocus = true // 自动获得焦点，弹出键盘placeholder = '请输入' // 输入提示文案value = "默认文案" // 默认填充的文字 slider + indicatorslider 默认高度会占满屏幕，所以必须为 slider 指定一个高度，而 indicator 也会继承这个高度。 123456&lt;slider class="slider" interval=3000 auto-play=true infinite=true @change="changePage" @scroll="scrollSlider "&gt; &lt;div v-for="(img,index) in imagelist"&gt; &lt;image class='image' :src="img"&gt;&lt;/image&gt; &lt;/div&gt; &lt;indicator class="indicator"&gt;&lt;/indicator&gt;&lt;/slider&gt; slider 标签属性 1234interval = 3000; // 播放时间间隔 auto-play = true; // 自动播放infinite = true; // 无限循环offset-x-accuracy = 20px; // 控制onscroll事件触发的频率，默认值为10,越小的话 onscroll 触发越频繁，可能降低性能 slider css 属性 1234.slider&#123; height:400px; /* 高度，需要指定 */ scrollable:false; /* 可不可以手势滑动 */&#125; indicator 常用属性 123456789.indicator&#123; width:750px; height:400px; position:absolute; top:150px; /* 绝对定位距离顶部的距离 */ item-color:#eeeeee; /* 没有选中的颜色 */ item-selected-color:#ff0000; /* 选中的颜色 */ item-size:20; /* 指示标记大小 */&#125; 事件 123456789// change 事件，当页面滑动到下一页时触发@change = 'changePage'event =&gt; index &#123;number&#125; 滑动到的索引// scroll 事件，每一页的移动都会触发，触发频率取决于 offset-x-accuracy@scroll 滑动监听event =&gt; offsetXRatio &#123;number&#125; 偏移量，[-1,1]，负值表示向左滚动，表示当前有每一页的 offsetXRatio 滚动到了页面外 scroller对客户端来说是不可复用元素的列表 滑动方向 - 可以垂直或者水平滑动，flex 和 scroll 的方向必须一致。 1234567891011两者方向必须一致flex-direction 默认值 row scroll-direction 默认值 vertical如果是垂直滑动，flex-direction:column;scroll-direction = vertical如果水平滑动flex-direction:row;scroll-direction = horizontal 实现一个 tab 导航 1234567&lt;scroller class="scroller" scroll-direction=horizontal @scroll='scrollerScroll'&gt; &lt;div class="tab-group" v-for="(item,index) in tablist" @click="changeTab(index)" :ref="'tab'+index"&gt; &lt;text class="tab-item"&gt; &#123;&#123;item&#125;&#125; &lt;/text&gt; &lt;text&gt; 抢购中 &lt;/text&gt; &lt;div class="tab-line" v-if="index == current_tab"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/scroller&gt; 常用标签属性，同样支持一些列表统一的标签属性 列表标签属性 12// 滑动方向，默认 verticalscroll-direction = vertical|horizontal 支持 loadmore 事件，见 列表 loadmore 支持 scroll 事件，见 列表 scroll 支持 resetLoadmore，见 列表 resetLoadmore 支持 scrollToElement，见 列表 scrollToElement list + waterfall + cell + header把他们放在一起是因为他们一起完成了一个列表的显示，其实 waterfall 和 list 是一样的， 类似 Android 上面当年的 ListView 和 GridView，当然现在都已经被 RecyclerView 代替了，他们表现的都是一个 垂直列表，而 waterfall 支持多列的显示， 使用 cell 生成列表的每一项，header 其实是 cell 的子类，它可以在滑动出屏幕时，固定在屏幕顶端，实现悬挂的效果。 列表中只支持 cell 、header、refresh、loading 和 使用 fix 定位的组件，其他组件不能正确渲染。 实现一个简单的列表显示，需要格外注意的是，v-for 的语句要写在 cell 上面，这样才能保证生成多个 cell，开始的时候我写在了 div 上面，其实是在一个 cell 里面生成了多个 div，这样就无法实现回收和复用。 1234567&lt;list style="height:500px;" @loadmore="loadmorelist"&gt; &lt;cell v-for="(item,index) in product_list"&gt; &lt;div class="product-group" @click="clickProduct(item,index)"&gt; &lt;text class="origin-price"&gt; ¥ &#123;&#123;item.origin_price&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/cell&gt;&lt;/list&gt; header这个 header 用起来坑比较多，汇总一下： 在 list 里面用 header，默认是一样悬挂效果，就是当 header 向上将要被滑出屏幕时会固定在屏幕顶端，但是向下滑出时不会固定在底端。 list 里面 header 上面的 cell 不能全部使用 v-for 生成，如果是的话，对 header 没有挤压效果，header 会一直在顶部，就好像 v-for 生成的那些 cell 没有压在 header 上面，但是一旦有一个不是 v-for 生成的，就好了，这应该是个bug; waterfall 里面使用 header 时，默认是没有悬挂效果的，会像普通的 cell 一样跟着整个列表一起走，这样可以实现单列和多列并存的效果。 如果希望 waterfall 里面有悬挂效果，要对 header 设置 position:sticky;，使用这个属性，他不会滑出屏幕，不管上面还是下面都会挂住。 在 list 中使用 sticky 没什么效果，在 waterfall 中一方面可以使用 sticky 对 header 做悬挂效果，另一方面 cell 如果设置了 sticky 会变成跨越正行，类似 header 使用 header 标签实现悬挂效果 &lt;header/&gt; 标签是 list 可以渲染的标签之一，当 header 到达顶部时，会吸附在屏幕顶部，&lt;header/&gt; 不一定要在顶部，可以在列表的任何位置，当这一项，被滑动到顶端时，会吸附在顶部，不会划出屏幕。 ps：同样的效果，如果在 cell 上面使用 position:fixed; 在 Android 可以正确显示，但是在 ios 没有任何效果 使用方法很简单，只需要将某一项使用 &lt;header&gt; 包含即可。 123456&lt;list&gt; &lt;cell&gt;&lt;/cell&gt; &lt;cell&gt;&lt;/cell&gt; &lt;header&gt;&lt;/header&gt; &lt;cell&gt;&lt;/cell&gt;&lt;/list&gt; waterfall👮如果是一个 list 套在 div 里面显示没问题，但是如果是 waterfall 就不行，看到有报错说无法解析 auto，当然设置成固定值也不行，解决方案是给 waterfall 一个固定的宽度，让他可以计算，就没问题了。 瀑布流 waterfall 支持多列显示，因此相比 list 多了一些属性，但是 list 的属性和事件他也是支持的。 「waterfall」 特有属性，column-width 和 column-count 不能同时指定为 auto 无法计算将无法显示。 12345678当某个属性指定为 auto 时，会使用下面的约束来计算 auto 对应的值。totalWidth = column-width * column-count + (column-count-1) * column-gapcolumn-width: 列宽，可以使用指定宽度，也可以使用 auto 表示根据其他属性来决定column-count: 列数，可以使用指定数字，也可以使用 auto 表示根据其他属性决定。column-gap: 间隔，可以使用指定宽度，也可以使用 normal 表示 32。 common「waterfall 和 list」 常用属性 - 支持列表统一的标签属性 列表标签属性 「waterfall 和 list」 支持 loadmore 事件，见 列表 loadmore 「waterfall 和 list」 支持 scroll 事件，见 列表 scroll 「waterfall 和 list」 支持 resetLoadmore，见 列表 resetLoadmore 「waterfall 和 list」 支持 scrollToElement，见 列表 scrollToElement 列表 在 weex 指的就是 scroller 和 list 了，这里汇总一些公共的属性和方法，方便管理和对比。 类似 scroller 和 list 都属于列表，他们有一些通用的属性和方法，提取出来统一介绍，⚠️ 不允许相同方向的列表互相嵌套 列表标签属性123456// 屏幕底部到页面底部的距离，用来触发 loadmore，默认 0loadmoreoffset = 20 // 触发 scroll 的频率，默认 10pxoffset-accuracy = 20px// 显示滚动条，默认true，但是发现在 android 默认是不显示的，但是 ios 显示show-scrollbar = false 列表事件123456789101112@loadmore 加载更多事件，横向滑动时，`loadmore` 不能触发没有参数@scroll 滑动监听event =&gt; contentSize &#123;Object&#125; 列表的尺寸，宽度和高度是总的长度，如 150px * 10 = 1500px - width &#123;number&#125; - height &#123;number&#125; contentOffset &#123;Object&#125; 列表偏移尺寸，整个列表总共被滑动的 px 数，是一个负值，越往右|下滑动，绝对值越大 - x &#123;number&#125; - y &#123;number&#125; 方法 resetLoadmore(node,options) 重置 loadmore，如果进行过一次 loadmore 之后，列表内容没有发生变更，则再次滑动到末尾时，不会触发 loadmore 事件，需要使用 resetLoadmore() 来重置状态。 12345678910111213scroller.resetLoadmore(node,options)node &#123;node&#125; 指的是节点，暂时不知道做什么用的，传任何节点都可以起作用options &#123;object&#125; - offset &#123;number&#125; 一个到其可见位置的偏移距离，默认 0eg:// 设置 scroller 的 ref 为 sv// 在加载更多的事件中，重置状态，让他可以一直触发 loadmore 事件loadmoreScroll()&#123; const el = this.$refs.sv el.resetLoadmore(el,&#123;offset:20&#125;)&#125; scrollToElement(node,options) 使得列表滑动到指定的 node，需要使用 dom module 来操作 ps：使用过程中发现 waterfall 组件的 scrollToElement 在 andorid 上是将指定项滚动到屏幕底部，ios 是滚动到顶部，list 和 scroller 正常，都是到顶部。 123456scrollToElement(node,options)node &#123;node&#125; 列表的子节点，将会滑动到这个节点options &#123;object&#125; - offset &#123;number&#125; 指定的子节点滑动后距离左边的距离的负值 - animated &#123;boolean&#125; 动画效果，默认 true 示例，对一个横向列表进行操作，使得点击的那个子元素自动滑动到居中显示 12345&lt;scroller class="scroller" scroll-direction='horizontal'&gt; &lt;div class="tab-group" v-for="(item,index) in tablist" @click="changeTab(index)" :ref="'tab'+index"&gt; &lt;text class="tab-item"&gt; &#123;&#123;item&#125;&#125; &lt;/text&gt; &lt;/div&gt;&lt;/scroller&gt; 在 click 事件中，滑动 scroller 由于我每一个子项的宽度设置为了 150px，而 weex 默认屏幕是 750px，一次屏幕内正好可以放置 5 个子项，距离左边 300px 即可居中。 123456changeTab(index)&#123; const dom = weex.requireModule('dom') this.current_tab = index; const el = this.$refs['tab'+index][0]; dom.scrollToElement(el,&#123;offset:-300&#125;);&#125;, refresh + loading使用 refresh 和 loading 实现加载数据的效果，refresh 是下拉刷新数据，loading 是上拉加载更多数据，他们只有在被 list 和 scroller 包含时才能正确渲染，接下来将会以 list 为例简单学习一下使用方法，在 scroller 是一样的。在用法上，refresh 和 loading 也基本相同，只是显示的位置不同和一些事件名字不同。 「diaplay」属性来决定组件的展示和隐藏，display 值为 show 或 hide。仅隐藏 &lt;indicator&gt;，&lt;loading&gt; 其他子组件依然可见，loading 事件仍会被触发，因此我们要实现刷新的效果需要动态的修改 display 的值。 1&lt;refresh :display="isRefreshing?'show':'hide'"&gt;&lt;/refresh&gt; 「&lt;loading-indicator&gt;」 是内置一个组件，显示是一个带动画效果的圆形进度条，就是系统默认的加载动画，需要注意的是宽高必须指定，不然默认是0无法显示，可以使用 color 属性来更改进度条的颜色。 1&lt;loading-indicator style='color:red;width:40px;height:40px;'&gt;&lt;/loading-indicator&gt; 事件，&lt;refresh&gt; 有 @refresh 事件，&lt;loading&gt; 有 @loading 事件，他们都会在滑动距离超过整个组件的高度时被触发，可以在这里面做加载数据的操作。 另外 &lt;refresh&gt; 还有一个自己的事件，@pullingdown 事件会返回组件滑动过程中的一些数据，不过这个监听在 andorid 和 ios 上面的数据差别比较大。 12345678910event =&gt; dy : 每次移动的变化量，表达的是单位时间内滑动的距离，每次开始动值比较大，快停止时值变小。 pullingDistance : 总共滑动的距离； 当刷新头露出时，android 返回的值为正数，ios 返回的值为负数； 当刷新头隐藏时，列表滑动时，android 不会触发这个监听，但是 ios 会一直触发，并且 pullingDistance 变为正数，并且一直会变大。 viewHeight : 刷新组件的高度，滑动超过这个高度会触发刷新 event.type : 不变的字符串 pullingdown 完整的带有刷新和加载功能的代码 123456789101112131415&lt;list&gt; &lt;refresh class='load_part' :display="isRefreshing?'show':'hide'" @refresh='refreshList' @pullingdown='pullList'&gt; &lt;loading-indicator style='color:red;width:40px;height:40px;'&gt;&lt;/loading-indicator&gt; &lt;text style='text-align:center'&gt; 下拉开始刷新 &lt;/text&gt; &lt;/refresh&gt; &lt;cell v-for="(item,index) in product_list"&gt; ... &lt;/cell&gt; &lt;loading class='load_part' :display="isLoading?'show':'hide'" @loading='loadingList'&gt; &lt;loading-indicator style='color:red;width:40px;height:40px;'&gt;&lt;/loading-indicator&gt; &lt;text style='text-align:center'&gt; 上拉开始加载 &lt;/text&gt; &lt;/loading&gt;&lt;/list&gt; 默认 isFreshing 和 isLoading 自然都是 false，当刷新时，更改组件的状态为显示，开始加载数据,并且延时 1s 后将组件隐藏。 1234567891011121314refreshList()&#123; modal.toast(&#123;message:"refresh"&#125;) this.isRefreshing=true setTimeout(() =&gt; &#123; this.isRefreshing=false &#125;, 1000);&#125;,loadingList()&#123; modal.toast(&#123;message:"loading"&#125;) this.isLoading =true setTimeout(() =&gt; &#123; this.isLoading=false &#125;, 1000);&#125;, config文档说明使用 weex.config 获取，但是测试发现不行，需要使用 this.$getConfig() 获取到，调查发现 weex.config 需要 weex 版本 &gt;=0.9.5 才可以，而我使用官方的 playground 版本是 0.9.4。 默认以宽度为 750px 做适配渲染，要获得 750px 下的屏幕高度，可以通过 height = 750/deviceWidth*deviceHeight 公式获得，可以使用到 CSS 中，用来设置全屏尺寸。 数据结构： 123456789101112config bundleUrl &#123;string&#125; :js bundle 的 url env &#123;obj&#125; weexVersion &#123;string&#125; :Weex sdk 版本 appName &#123;string&#125; :应用名字 appVersion &#123;string&#125; :应用版本。 platform &#123;string&#125; :平台信息，是 iOS、Android 还是 Web osName &#123;string&#125; :iOS或者android，表示操作系统的名称 osVersion &#123;string&#125; :系统版本 deviceModel &#123;string&#125; :设备型号 (仅原生应用) deviceWidth &#123;number&#125; :设备宽度 deviceHeight &#123;number&#125; :设备高度]]></content>
      <categories>
        <category>weex</category>
      </categories>
      <tags>
        <tag>weex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bolts 更简单任务管理和线程切换 [源码]]]></title>
    <url>%2Farticle%2F1dbbedd%2F</url>
    <content type="text"><![CDATA[尤塞恩·圣利奥·博尔特 Usain St Leo Bolt，牙买加短跑运动员，男子100米、男子200米以及男子400米接力赛的世界纪录保持人，同时是以上三项赛事的连续三届奥运金牌得主。 使用 Bolts 可以将一个完整的操作拆分成多个子任务，这些子任务可以自由的拆分、组合和替换，每个任务作为整个任务链的一环可以运行在指定线程中，同时既能从上行任务中获取任务结果，又可以向下行任务发布当前任务的结果，而不必考虑线程之间的交互。 Bolts-Android Bolts 在 Android 下的实现Bolts-ObjC Bolts 在 OC 下的实现Bolts-Swift Bolts 在 Swift 下的实现 前言一个关于线程调度的简单需求，在子线程从网络下载图片，并返回下载的图片，在主线程使用该图片更新到 UI，同时返回当前 UI 的状态 json，在子线程将 json 数据保存到本地文件，完成后在主线程弹出提示，这中间涉及到了 4 次线程切换，同时后面的任务需要前面任务完成后的返回值作为参数。 使用 Thread + Handler 实现，线程调度很不灵活，代码可读性差，不美观，扩展性差，错误处理异常麻烦。 12345678910111213141516String url = "http://www.baidu.com";Handler handler = new Handler(Looper.getMainLooper());new Thread(() -&gt; &#123; // 下载 Bitmap bitmap = downloadBitmap(url); handler.post(() -&gt; &#123; // 更新 UI String json = updateUI(bitmap); new Thread(() -&gt; &#123; // 向存储写入UI状态 saveUIState(json); // 保存成功后，提示 handler.post(() -&gt; toastMsg("save finish.")); &#125;).start(); &#125;);&#125;).start(); 使用 RxJava 实现，线程调度非常灵活，链式调用，代码清晰，扩展性好，有统一的异常处理机制，不过 Rx 是一个很强大的库，如果只用来做线程调度的话，Rx 就显得有点太重了。 123456789101112131415Observable.just(URL) // 下载 .map(this::downloadBitmap) .subscribeOn(Schedulers.newThread()) // 更新UI .observeOn(AndroidSchedulers.mainThread()) .map(this::updateUI) // 存储 UI 状态 .observeOn(Schedulers.io()) .map(this::saveUIState) // 显示提示 .observeOn(AndroidSchedulers.mainThread()) .subscribe(rst -&gt; toastMsg("save to " + rst), // handle error Throwable::printStackTrace); 使用 bolts 实现，线程调度灵活，链式调用，代码清晰，具有良好的扩展性，具有统一的异常处理机制，虽然没有 Rx 那么丰富的操作符，但是胜在类库非常非常小，只有 38 KB。 123456789101112131415161718Task .forResult(URL) // 下载 .onSuccess(task -&gt; downloadBitmap(task.getResult()), Task.BACKGROUND_EXECUTOR) // 更新UI .onSuccess(task -&gt; updateUI(task.getResult()), Task.UI_THREAD_EXECUTOR) // 存储UI状态 .onSuccess(task -&gt; saveUIState(task.getResult()), Task.BACKGROUND_EXECUTOR) // 提示 .onSuccess(task -&gt; toastMsg("save to " + task.getResult()), Task.UI_THREAD_EXECUT // handle error .continueWith(task -&gt; &#123; if (task.isFaulted()) &#123; task.getError().printStackTrace(); return false; &#125; return true; &#125;); 线程调度器共有 4 种类型执行线程，将任务分发到指定线程执行，分别是 backgroud - 后台线程池，可以并发执行任务。 scheduled - 单线程池，只有一个线程，主要用来执行 delay 操作。 immediate - 即时线程，如果线程调用栈小于 15，则在当前线程执行，否则代理给 background。 uiThread - 针对 Android 设计，使用 Handler 发送到主线程执行。 backgroud主要用来在后台并发执行多任务 1public static final ExecutorService BACKGROUND_EXECUTOR = BoltsExecutors.background(); 在 Android 平台下根据 CPU 核数创建线程池，其他情况下，创建缓存线程池。 123background = !isAndroidRuntime() ? java.util.concurrent.Executors.newCachedThreadPool() : AndroidExecutors.newCachedThreadPool(); scheduled主要用于任务之间做 delay 操作，并不实际执行任务。 1scheduled = Executors.newSingleThreadScheduledExecutor(); immediate主要用来简化那些不指定运行线程的方法，默认在当前线程去执行任务，使用 ThreadLocal 保存每个线程调用栈的深度，如果深度不超过 15，则在当前线程执行，否则代理给 backgroud 执行。 12345678910111213141516private static final Executor IMMEDIATE_EXECUTOR = BoltsExecutors.immediate();// 关键方法@Overridepublic void execute(Runnable command) &#123; int depth = incrementDepth(); try &#123; if (depth &lt;= MAX_DEPTH) &#123; command.run(); &#125; else &#123; BoltsExecutors.background().execute(command) &#125; &#125; finally &#123; decrementDepth(); &#125;&#125; uiThread为 Android 专门设计，在主线程执行任务。 1public static final Executor UI_THREAD_EXECUTOR = AndroidExecutors.uiThread(); 123456private static class UIThreadExecutor implements Executor &#123; @Override public void execute(Runnable command) &#123; new Handler(Looper.getMainLooper()).post(command); &#125;&#125; 核心类Task，最核心的类，每个子任务都是一个 Task，它们负责自己需要执行的任务。每个 Task 具有 3 种状态 Result、Error 和 Cancel，分别代表成功、异常和取消。 Continuation，是一个接口，它就像链接子任务每一环的锁扣，把一个个独立的任务链接在一起。 通过 Task - Continuation - Task - Continuation … 的形式组成完整的任务链，顺序在各自线程执行。 创建 Task根据 Task 的 3 种状态，创建简单的 Task，会复用已有的任务对象 12345public static &lt;TResult&gt; Task&lt;TResult&gt; forResult(TResult value)public static &lt;TResult&gt; Task&lt;TResult&gt; forError(Exception error)public static &lt;TResult&gt; Task&lt;TResult&gt; cancelled() 使用 delay 方法，延时执行并创建 Task 123public static Task&lt;Void&gt; delay(long delay)public static Task&lt;Void&gt; delay(long delay, CancellationToken cancellationToken) 使用 whenAny 方法，执行多个任务，当任意任务返回结果时，保存这个结果 123public static &lt;TResult&gt; Task&lt;Task&lt;TResult&gt;&gt; whenAnyResult(Collection&lt;? extends Task&lt;TResult&gt;&gt; tasks)public static Task&lt;Task&lt;?&gt;&gt; whenAny(Collection&lt;? extends Task&lt;?&gt;&gt; tasks) 使用 whenAll 方法，执行多个任务，当全部任务执行完后，返回结果 123public static Task&lt;Void&gt; whenAll(Collection&lt;? extends Task&lt;?&gt;&gt; tasks) public static &lt;TResult&gt; Task&lt;List&lt;TResult&gt;&gt; whenAllResult(final Collection&lt;? extends Task&lt;TResult&gt;&gt; tasks) 使用 call 方法，执行一个任务，同时创建 Task 12public static &lt;TResult&gt; Task&lt;TResult&gt; call(final Callable&lt;TResult&gt; callable, Executor executor, final CancellationToken ct) 链接子任务使用 continueWith 方法，链接一个子任务，如果前行任务已经执行完成，则立即执行当前任务，否则加入队列中，等待。 123public &lt;TContinuationResult&gt; Task&lt;TContinuationResult&gt; continueWith( final Continuation&lt;TResult, TContinuationResult&gt; continuation, final Executor executor, final CancellationToken ct) 使用 continueWithTask 方法，在当前任务之后链接另一个任务链，这种做法是为了满足那种将部分任务组合在一起分离出去，作为公共任务的场景，他接受将另外一个完全独立的任务链，追加在当前执行的任务后面。 123public &lt;TContinuationResult&gt; Task&lt;TContinuationResult&gt; continueWithTask( final Continuation&lt;TResult, Task&lt;TContinuationResult&gt;&gt; continuation, final Executor executor, final CancellationToken ct) 使用 continueWhile 方法链接子任务，与 continueWith 区别在于，他有一个 predicate 表达式，只有当表达式成立时，才会追加子任务，这样做是在执行任务前可以做一个拦截操作，也是为了不破环链式调用的整体风格。 123public Task&lt;Void&gt; continueWhile(final Callable&lt;Boolean&gt; predicate, final Continuation&lt;Void, Task&lt;Void&gt;&gt; continuation, final Executor executor, final CancellationToken ct) 使用 onSuccess 和 onSuccessTask 链接单个任务个任务链，区别于 continueWith 在于，onSuccess 方法，前行任务如果失败了，后行的任务也会直接失败，不会再执行，但是 continueWith 的各个子任务之间没有关联，就算前行任务失败，后行任务也会执行。 123public &lt;TContinuationResult&gt; Task&lt;TContinuationResult&gt; onSuccess( final Continuation&lt;TResult, TContinuationResult&gt; continuation, Executor executor, final CancellationToken ct) 取消任务Task 没有 cancel 方法，而是使用了 CancellationToken 作为标记，任务执行之前会检查这个标记，如果标记为退出，则会直接退出任务。 1234567CancellationTokenSource cancellationTokenSource = new CancellationTokenSource();CancellationToken token = cancellationTokenSource.getToken();Task.call((Callable&lt;String&gt;) () -&gt; null, Task.BACKGROUND_EXECUTOR, token);// 取消任务cancellationTokenSource.cancel(); 异常的处理关于异常的处理，整个机制下来，每个任务作为一个独立的单位，异常会被统一捕捉，因此不必针对任务中的方法进行单独的处理。 如果使用了 continueWith 链接任务，那么当前任务的的异常信息，将会保存在当前 Task 中在下行任务中进行处理，下行任务也可以不处理这个异常，直接执行任务，那么这个异常就到这里停止了，不会再向下传递，也就是说，只有下行任务才知道当前任务的结果，不管是成功还是异常。 当然了，如果任务之间有关联，由于上行任务的异常极大可能造成当前任务的异常，那么当前任务异常的信息，又会向下传递，但是上行任务的异常就到这里为止了。 如果使用 onSuccess 之类的方法，如果上行任务异常了，那么下行任务根本不会执行，而是直接将异常往下面传递，直到被处理掉。 任务的分离和组合我们可以将一个完整的操作细分成多个任务，每个任务都遵循单一职责的原则而尽量简单，这样可以在任务之间再穿插新的任务，或者将部分任务分离出来组合到一起等。 扩展性我们可以在两个细分的任务之间添加一个新的操作，而不影响上行和下行任务，如我们给文章开头的需求中更新 UI 之前，将 Bitmap 先保存到本地。 123456789Task .forResult(URL) // 下载 .onSuccess(task -&gt; downloadBitmap(task.getResult()), Task.BACKGROUND_EXECUTOR) // 保存在本地 .onSuccess(task -&gt; saveBitmapToFile(task.getResult()),Task.BACKGROUND_EXECUTOR) // 更新UI .onSuccess(task -&gt; updateUI(task.getResult()), Task.UI_THREAD_EXECUTOR) ... 复用性对一些公共的操作，可以单独分离成新的任务，当需要做类似操作时，即可复用这部份功能，如可以将下载图片并更新 UI、保存状态并弹出提示 两块功能分离出来，作为公共的任务。 12345678910111213// 下载图片-&gt;更新UIpublic Continuation&lt;String, Task&lt;String&gt;&gt; downloadImageAndUpdateUI() &#123; return task -&gt; Task.call(() -&gt; downloadBitmap(task.getResult()), Task.BACKGROUND_EXECUTOR) .continueWith(taskWithBitmap -&gt; updateUI(taskWithBitmap.getResult()), Task.UI_THREAD_EXECUTOR);&#125;// 保存状态-&gt;提示信息public Continuation&lt;String, Task&lt;Boolean&gt;&gt; saveStateAndToast() &#123; return task -&gt; Task.call(() -&gt; saveUIState(task.getResult()), Task.BACKGROUND_EXECUTOR) .continueWith(taskWithPath -&gt; toastMsg("save to " + taskWithPath.getResult()));&#125; 使用分离的任务 12345Task .forResult(URL) .continueWithTask(downloadImageAndUpdateUI()) .continueWithTask(saveStateAndToast()) ... 总结在 Task 中有一个 continuations 是当前任务后面追加的任务列表，当当前任务成功、异常或者取消时，会去执行列表中的后续任务。 通常情况下，我们使用链式调用构建任务链，结果就是一条没有分支的任务链。 添加任务时 ：每次添加一个 Continuation，就会生成一个 Task，加到上行任务的 continuations 列表中，等待执行，同时返回当前的 Task，以便后面的任务可以链接到当前任务后面。 执行任务时 ：当前任务执行完之后，结果可能有 3 种，都会被保存到当前的 Task 中，然后检查 continuations 列表中的后续任务，而当前的 Task 就会作为参数，传递到后续链接的任务中，来让后面的任务得知上行任务的结果。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SourceCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建 Weex 开发环境和集成到 Android 平台 [Weex]]]></title>
    <url>%2Farticle%2F39fe7888%2F</url>
    <content type="text"><![CDATA[Weex 是阿里开源的一款跨平台移动开发工具，Weex 能够完美兼顾性能与动态性，让移动开发者通过简捷的前端语法写出 Native 级别的性能体验，并支持 IOS、android、 Web等多端部署。 对于移动开发者来说，Weex 主要解决了频繁发版和多端研发两大痛点，同时解决了前端语言性能差和显示效果受限的问题。 不足：布局上 UI 嵌套层级太深。 Weex GitHub Weex 官方教程 Mac 重装 Node Weex Android Dev Tools 环境安装解决 安装 weex-toolkit 出现 npm ERR! code ELIFECYCLE 错误。 12chmod -R 777 ~/.xtoolkitsudo chmod -R 777 ~/.xtoolkit 使用命令开启 watch 模式和静态服务器 1npm run dev &amp; npm run serve weex-toolkitWeexToolKit 教程 weex-toolkit 是官方提供的一个脚手架命令行工具，你可以使用它进行 Weex 项目的创建，调试以及打包等功能。 具体的安装和初始化流程可以参照官网文档，这里记录几个常用命令。 调试方面，更多特性参照文档。 123456789101112131415# 初始化项目weex init &#123;project&#125;weex init my_weex_project# 实时预览weex &#123;file.vue&#125;weex src/page.vue# 预览整个目录weex src --entry &#123;entry_file.vue&#125;weex src --entry src/entry_page.vue# 打包 weex 项目weex compile &#123;src_file/src_dir&#125; &#123;dst_dir&#125;weex compile src/foo.vue dist 调试 123456789101112weex debug [options] [file.vue/dir]# 开启调试服务器weex debug # 调试某个文件weex debug &#123;vue 文件&#125;weex debug test.vue# 调试文件夹weex debug &#123;文件夹&#125; -e &#123;入口文件&#125;weex debug test_dir -e src/index.vue Android 端简单集成配置 app/build.gralde 1234567891011121314151617181920212223android &#123; compileSdkVersion 25 // 23 以上 buildToolsVersion "26.0.2" // 23.0.1 以上 defaultConfig &#123; // ... ndk &#123; abiFilters "x86" abiFilters "armeabi" &#125; &#125; compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_7 targetCompatibility JavaVersion.VERSION_1_7 &#125;&#125;dependencies &#123; // ... compile 'com.android.support:appcompat-v7:25.3.1' compile 'com.android.support:recyclerview-v7:25.3.1' compile 'com.alibaba:fastjson:1.1.46.android' compile 'com.taobao.android:weex_sdk:0.10.0'&#125; 在 Application 中进行初始化，同时必须在 AndroidManifest.xml 文件中进行声明。 123456WXSDKEngine.initialize(this, new InitConfig.Builder().setImgAdapter(new IWXImgLoaderAdapter() &#123; @Override public void setImage(String url, ImageView view, WXImageQuality quality, WXImageStrategy strategy) &#125;&#125;).build()); 将编译完成的 js 文件拷贝到 assets 目录，加载本地 js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class MainActivity extends AppCompatActivity implements IWXRenderListener &#123; WXSDKInstance mWXSDKInstance; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mWXSDKInstance = new WXSDKInstance(this); mWXSDKInstance.registerRenderListener(this); /** * WXSample 可以替换成自定义的字符串，针对埋点有效。 * template 是.we transform 后的 js文件。 * option 可以为空，或者通过option传入 js需要的参数。例如bundle js的地址等。 * jsonInitData 可以为空。 * width 为-1 默认全屏，可以自己定制。 * height =-1 默认全屏，可以自己定制。 */ mWXSDKInstance.render("WXSample", WXFileUtils.loadAsset("index.js", this), null, null, WXRenderStrategy.APPEND_ASYNC); &#125; @Override public void onViewCreated(WXSDKInstance instance, View view) &#123; Log.e("chendong","onViewCreated"); setContentView(view); &#125; @Override public void onRenderSuccess(WXSDKInstance instance, int width, int height) &#123; Log.e("chendong","onRenderSuccess"); &#125; @Override public void onRefreshSuccess(WXSDKInstance instance, int width, int height) &#123; Log.e("chendong","onRefreshSuccess"); &#125; @Override public void onException(WXSDKInstance instance, String errCode, String msg) &#123; Log.e("chendong",msg + " " +errCode); &#125; @Override protected void onResume() &#123; super.onResume(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityResume(); &#125; &#125; @Override protected void onPause() &#123; super.onPause(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityPause(); &#125; &#125; @Override protected void onStop() &#123; super.onStop(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityStop(); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityDestroy(); &#125; &#125;&#125; 运行发现如下问题 123initWXBridge HackAssertionException com.taobao.weex.utils.WXHack$HackDeclaration$HackAssertionException: java.lang.ClassNotFoundException: com.taobao.weex.devtools.debug.DebugServerProxy 解决上述问题，在 app/build.gradle 中加入 debug 依赖 1compile 'com.taobao.android:weex_inspector:0.0.8.5']]></content>
      <categories>
        <category>weex</category>
      </categories>
      <tags>
        <tag>weex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 学习汇总]]></title>
    <url>%2Farticle%2Fbbab636a%2F</url>
    <content type="text"><![CDATA[Kotlin 系列文章的一个目录，共计 22 篇，主要涉及官方文档的基本语法及 Anko 的使用等。 本系列文档主要根据 Kotlin 官方文档，对基本的语法进行学习，后面会持续更新新的内容… Kotlin开发-1-新特性篇 Kotlin开发-2-基础 Kotlin开发-2-基础-可见度修饰符 Kotlin开发-2-基础-数据类型 Kotlin开发-2-基础-控制流 Kotlin开发-3-属性与域 Kotlin开发-4-接口 Kotlin开发-5-类与对象 Kotlin开发-6-扩展 Kotlin开发-7-特殊类 Kotlin开发-8-范型 Kotlin开发-9-object关键字 Kotlin开发-10-代理 Kotlin开发-11-函数 Kotlin开发-12-空值安全 Kotlin开发-13-集合 Kotlin开发-14-杂七杂八(解构，类型自动转换，Range，异常) Kotlin开发-15-操作符重载 Kotlin开发-16-反射 Kotlin开发-17-注解 Kotlin开发-18-协程 Kotlin开发-19-Anko]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于 Docker 环境搭建 Jenkins]]></title>
    <url>%2Farticle%2Ffa67563%2F</url>
    <content type="text"><![CDATA[一篇相当全面的文档 docker.com docker 加速官网下载 docker 速度很慢，可以前往 daocloud.io 下载 docker，我下载的是 docker for mac，速度很快，但是版本比较老，安装后再 check for updates 升级到新版本，速度会快一些。 安装好之后，下载镜像速度也很慢，可以使用打开 Preference-&gt;Daemon-&gt;Registry Mirrors 添加如下镜像，然后 apply&amp;restart 就可以生效； 可以使用 docker info 命令查看是否生效 12http://b5886426.m.daocloud.io/https://docker.mirrors.ustc.edu.cn/ docker command1docker pull jenkins:latest 以普通用户运行 bash 1docker exec -it mycontainer bash 以 root 用户运行 bash 1docker exec -u 0 -it mycontainer bash 使用镜像创建一个容器 1sudo docker run -d --name jenkins-node -p 49002:8080 -v /Users/march/docker/jenkins-node:/var/jenkins_home jenkins-android 解释一下这条命令 123456789-d =&gt; debug 模式，后台运行，不会占用终端，终端关闭也不会停止服务--name jenkins-node =&gt; 别名，否则会是一个随机别名，别名可以用来管理该容器-p 49002:8080 =&gt; 端口映射，将 8080 映射到 49002，后面使用 localhost:49002 访问-v /Users/march/docker/jenkins_node:/var/jenkins_home =&gt; 文件挂载，将 /var/jenkins_home 挂载到指定目录，如果不挂载，则jenkins所有log、用户配置文件都会在docker容器内，如果容器销毁，则jenkins得重新配置一遍。挂载出来方便jenkins迁移以及管理，/Users/march/docker/jenkins_node 是我的一个本地目录，在该目录下可以看到 jenkins 的相关文件，这个目录随意，注意权限问题。jenkins:latest =&gt; 镜像名称 linux安装 sudo 1apt-get install sudo 安装 nodejs、npm 123curl -sL https://deb.nodesource.com/setup_9.x | sudo -E bash -sudo apt-get install -y nodejssudo apt-get install -y npm sshssh-keygen -t rsa -b 4096 -C ‘email’ 本机存放 id_rsa，远端存放 id_rsa.pub 公钥 ssh-agent bash ssh-add id_rsa]]></content>
      <categories>
        <category>Docker</category>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My-Todo-List]]></title>
    <url>%2Farticle%2F5a0eb6a0%2F</url>
    <content type="text"><![CDATA[TODO [ ] Weex Cube [ ] Adapter Empty Layout [ ] React + Rax [ ] RN [ ] Flutter Book [ ] Js 小红书 [ ] 锋利的 Jq Blog [ ] 图片处理先整理一篇关于涂鸦的 [x] 优化系列、内存、UI优化 [ ] Handler 重新整理一下 [ ] HashMap 重新整理一下 Android Pro [x] 分享登录项目继续优化 [ ] 支付项目 [ ] Kotlin Secure Files 项目 [ ] 图片处理项目推进 [x] 适配器项目优化, 使用注解简化 [ ] 项目模块化 xhttp,webkit,uikit,common [ ] 二维码项目 zxing 模块 [x] weex cube 库 Knowlege [x] Https 相关 [ ] JVM 原理 [ ] 内存管理 Source Code [x] Glide 源码 [ ] OkHttp 源码 [ ] EventBus 源码 [ ] AsyncTask 源码 [ ] Handler,HashMap 重新梳理 [ ] weex sdk 源码 扩展 [ ] 小程序 [x] Weex 前端 [ ] Html 4+5 基础 - imooc,runoob [ ] Css 2+3 基础 - imooc,runoob [ ] JavaScript 基础 - 看书,imooc [ ] JQuery [ ] weex + vue - 文档、云盘视频 Future [ ] docker [ ] node [ ] python [ ] Angular [ ] React [ ] sass,less]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[借助 Vultr 科学上网]]></title>
    <url>%2Farticle%2Ff546dc07%2F</url>
    <content type="text"><![CDATA[作为一个开发人员，用惯了 Google 再回来用百度，特别难受，而且像 Android 的一些官方文档只能出去了才能看，为了能够流畅的访问 Google，一路走来尝试了很多不同的方式，也发现每个平台都各有利弊，最终选择了 Vultr.com，记录一下。 方案选择方案有很多，大致分为两种： 省事儿的，用人家做好的服务，只要交钱就好了，缺点是受制于人（动不动就涨价、还偶尔抽风不能用）。 费事儿的，自己买服务器搭建 ss，适合开发人员，这个服务器还可以用来挂一些自己的小服务，也可以练习部署服务的一些基本操作。 第三方服务 Lattern 是最开始使用的方法，有 500M 流量可以免费用，但是连接不稳定，网速又慢，好的时候只能浏览个网页。 vpn.so 这是一个三方的 vpn 网站，每年 200RMB 就可以获得一个节点，速度的话一般吧，好的时候可以看看视频，前段时间开会给封了，不知道最近好了没有。 自建 ss 服务通过服务器网站购买国外服务器，自建梯子，转发流量，这种方法相对复杂一些，不过购买后你获得的是一台服务器，你还可以利用这台服务器做很多事情。 国内有阿里云和腾讯云等服务商，但是服务器的价格实在太贵了，所以我们会选择一些小众的服务器代理商。 digitalocean 是我最先使用的一个平台，它可以允许你透支大约20美元的样子，不过缺点是操作界面太卡，而且仅支持 paypal 支付。 Vultr.com 是我最近刚开始使用的，之前 digitalocean 透支之后就没有再继续使用了。 vultr 的优势 操作界面相对清新 可以支持支付宝支付，不必绑定 paypal，对国内用户更友好 服务器选择更多一些 支持支付宝支付，对国内用户友好很多 按小时计费，你不用了可以暂停掉，不用担心一直计费 充值Vultr.com 按小时计费，但是首先需要充值，最少 10 美元，支持支付宝。 选择合适的服务配置服务器共有 7 个选项，按照顺序配置好即可。 Server Location =&gt; 建议选择 Chicago 和 Los Angeles，速度会好一些 Server Type =&gt; CentOS 7 * 64 Server Size =&gt; $5 / mo Startup Script =&gt; 删除原来的脚本，添加以下脚本进行工具的安装 123456yum install pythonyum -y install epel-releaseyum -y install python-pipyum clean allpip install --upgrade pippip install shadowsocks SSH Keys =&gt; 配置 SSH 1234ssh-keygen -t rsa -b 4096 -C 'your email'# 然后获取 ~/.ssh/id_rsa.pub (mac) 里面的内容配置到相应位置cat ~/.ssh/id_rsa.pub Server Hostname &amp; Label =&gt; 随便选一个你喜欢的 点击 Deploy Now 即可创建一个服务。 管理服务器 按照图中所示，点击查看 IP 地址和初始密码（随机字符串） 在本地打开 terminal 执行 ssh 命令连接到远程服务，此时会要求你输入 root 用户的密码，按照上面查看到的输入即可 1sudo ssh root@128.199.148.155 连接之后使用下面的命令更改 root 密码，随机密码用起来太麻烦了 1passwd 配置 SS目前我们已经连接到了远程服务器上，由于开始我们配置服务器时使用了启动脚本，那么目前所有的工具应该都是已经安装好的，检查一下对应的命令，如果没有就重新安装一下。 主要需要以下工具 python =&gt; 一般自带，使用 python -V 检查 pip =&gt; python 包管理工具 ssserver =&gt; shadowsocks 服务 vi、vim =&gt; 用于编辑配置文件 以上命令找不到的话，使用以下命令安装 1234567891011121314151617181920# 安装 pythonyum install python# 安装 pip# 首先安装epel扩展源：yum -y install epel-release# 更新完成之后，就可安装pip：yum -y install python-pip# 安装完成之后清除cache：yum clean all# 升级 pippip install --upgrade pip# 安装 ssserverpip install shadowsocks# 安装 vimrpm -qa|grep vimyum -y install vim-enhancedyum -y install vim-common 环境和工具安装好之后，新建并编辑 shadowsocks 配置文件 1234567891011121314vi /etc/shdowsocks.json# 输入 i, 进入 insert 模式，粘贴下面的内容&#123; "server": "0.0.0.0", "server_port": 8388, "local_address": "127.0.0.1", "local_port": 1080, "password": "你的密码", "timeout": 300, "method": "aes-256-cfb", "fast_open": false&#125; 开启 8388 端口 12firewall-cmd --zone=public --add-port=8388/tcp --permanentfirewall-cmd --reload 启动／终止服务 ss 服务 12ssserver -c /etc/shadowsocks.json -d startssserver -c /etc/shadowsocks.json -d stop ShadowSocks小飞机，代理软件，在 Mac 和 Android 都有对应的客户端，这里提供一个下载链接，下载安装后，配置服务器 配置好服务后，访问一下 www.google.com，尝试一下是否可以正常访问。 安装 bbr 加速安装 bbr 加速，速度可以提升接近一倍左右。 123wget –no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shchmod +x bbr.sh./bbr.sh 综上就目前来看，自建 ss 的方案各个服务商的价格基本一致，大约都在 $5 / mo，不过 Vultr.com 可以按小时计费要相对合理一些。 快去试试吧 =&gt; Vultr.com]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>Extensions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 系统通知相关]]></title>
    <url>%2Farticle%2Fd1a02c42%2F</url>
    <content type="text"><![CDATA[系统通知就是出现在手机通知面板上的消息，点击之后可以触发相应的操作，在接入推送、通知用户下载进度等情况下使用较多，但是通常情况下我们使用的也都是最简单的文字类通知，不过随着 Android 新版本的发布，系统通知也变得样式丰富起来。 本文主要记录 Android 发送系统通知的相关内容，如发送纯文本、进度条、自定义视图、添加按钮、多行文字模式、收件箱模式、大图模式等；适配 Android 7.0 进行通知的分组，避免大量通知占据通知面板；最后封装一个工具类，简化发送各种类型的通知的过程。 本文相关源码 GitHub 系统通知属性配置由于系统通知的相关配置很多，因此用一个类来管理所有的配置选项，并给大多数属性常用的默认值，来简化对通知复杂的配置操作。这样就可以不用再面对 SDK 中复杂的 API，只需要按照显示的需求来配置对象即可。 由于配置类型繁多，都在注释中体现，不再单独一个一个说了。 123456789101112131415161718192021222324252627282930313233343536373839404142public class NotifyModel &#123; // 通常使用自动递增的 id 来发送通知 // 但是有类似进度条这类通知，需要更新原来的通知，此时需要一个不变的 id private int notifyId = -1; // 通常使用 private String title; // 标题 private String content; // 通知的内容 private String ticker; // 滚动显示的提示信息 private int smallIcon; // 通知小图标资源 private Bitmap largeIcon; // 设置显示的大图 private PendingIntent activeIntent; // 点击通知激活的 intent private PendingIntent deleteIntent; // 删除通知时激活的 intent private boolean isOnGoing = false; // false 表示可以滑动删除 private boolean isAutoCancel = true; // true 表示点击之后自动删除 // 设置通知优先级别，使用 // NotificationCompat.PRIORITY_MAX // NotificationCompat.PRIORITY_HIGH // NotificationCompat.PRIORITY_DEFAULT // NotificationCompat.PRIORITY_MIN // NotificationCompat.PRIORITY_LOW private int priority = NotificationCompat.PRIORITY_MAX; // 设置提示的方式，响铃或者震动，使用参数 // Notification.DEFAULT_ALL：铃声、闪光、震动均系统默认。 // Notification.DEFAULT_SOUND：系统默认铃声。 // Notification.DEFAULT_VIBRATE：系统默认震动。 // Notification.DEFAULT_LIGHTS：系统默认闪光。 private int remindMode = NotificationCompat.DEFAULT_VIBRATE | Notification.DEFAULT_SOUND; private long[] vibrate = null; // 自定义振动频率 private int currentProgress; // 当前进度 private int totalProgress; // 总共进度 private boolean indeterminate; // 是否精确进度，false 为精确进度 private List&lt;NotificationCompat.Action&gt; actions; // 按钮列表，最多支持 3 个，多了不显示 private RemoteViews remoteViews; // 自定义视图 private NotificationCompat.Style notifyStyle; // 通知的风格，收件箱、大图、长文本等 private String notifyGroup = DevKit.getContext().getPackageName(); // 分组标记，唯一即可 private int summaryIfMoreThanCount = Integer.MAX_VALUE; // 超多多少条就分组显示&#125; 发送通知发送通知需要首先需要使用 NotificationCompat.Builder 来创建一个 Notification，然后借助 NotificationManager 来发送，根据 NotifyModel 中的对通知的配置来构建 Notification，至于创建哪种类型的通知也是根据 NotifyModel 中的参数来，后面会再详细说每种类型关键代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 根据初始化 NotifyModel 构建通知private static NotificationCompat.Builder initNotificationBuilder(Context context, NotifyModel model) &#123; NotificationCompat.Builder builder = new NotificationCompat.Builder(context.getApplicationContext()); // 设置小图标,这是必须的用于在通知栏进行显示，默认使用了软件的图标 builder.setSmallIcon(model.getSmallIcon()); // 设置显示的标题 builder.setContentTitle(model.getTitle()); // 设置内容 builder.setContentText(model.getContent()); // 设置滚动显示的提示信息 if (!TextUtils.isEmpty(model.getTicker())) builder.setTicker(model.getTicker()); // 设置大图 if (model.getLargeIcon() != null) builder.setLargeIcon(model.getLargeIcon()); // 设置优先级 builder.setPriority(model.getPriority()); // 设置通知铃声或者震动 builder.setDefaults(model.getRemindMode()); // 设置不可滑动删除 builder.setOngoing(model.isOnGoing()); // 设置自动删除通知 builder.setAutoCancel(model.isAutoCancel()); // 震动 if (model.getVibrate() != null) builder.setVibrate(model.getVibrate()); // 设置自定义视图 if (model.getRemoteViews() != null) &#123; builder.setContent(model.getRemoteViews()); // builder.setCustomHeadsUpContentView(model.getRemoteViews()); &#125; // 点击后发送事件 if (model.getActiveIntent() != null) builder.setContentIntent(model.getActiveIntent()); // 删除后发送事件 if (model.getDeleteIntent() != null) builder.setDeleteIntent(model.getDeleteIntent()); // 添加按钮及点击事件 if (model.getActions() != null) &#123; for (NotificationCompat.Action action : model.getActions()) &#123; builder.addAction(action); &#125; &#125; // 设置进度 if (model.getTotalProgress() != 0) &#123; builder.setProgress(model.getTotalProgress(), model.getCurrentProgress(), model.isIndeterminate()); &#125; // 通知栏风格 if (model.getNotifyStyle() != null) &#123; builder.setStyle(model.getNotifyStyle()); &#125; // 时间，通知栏会按照这个排序 builder.setWhen(System.currentTimeMillis()); // 通知分组 builder.setGroup(model.getNotifyGroup()); return builder;&#125; 发送通知，每条通知都有一个唯一的 notifyId，不同的 notifyId 的通知将会排列在通知面板上面，相同 notifyId 的通知，后面的会替换前面的， 也就是说面板上面相同 notifyId 的通知只能有一条。 12345678910111213public static int notifyNow(Context context, NotifyModel model) &#123; Notification notification = initNotificationBuilder(context, model).build(); // 获取通知管理者，并获得系统通知 的服务 NotificationManager manager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE); int notifyId; if (model.getNotifyId() != -1) notifyId = model.getNotifyId(); else notifyId = ++sNotificationId; manager.notify(notifyId, notification); // 兼容 7.0 通知分组 updateNotificationSummary(context, model); return notifyId;&#125; 简单的文本通知这也就是我们最常用的通知类型了，因为大多数的配置都有默认值，如果需要发送一条文本通知只要配置几个关键的属性即可。 123456789NotifyModel notifyModel = new NotifyModel();Intent intent = new Intent(mContext, HomeActivity.class);PendingIntent activeIntent = PendingIntent.getActivity(mContext, 100, intent, PendingIntent.FLAG_CANCEL_CURRENT);notifyModel.setActiveIntent(activeIntent);notifyModel.setSmallIcon(R.drawable.ic_launcher);notifyModel.setTitle("测试推送标题");notifyModel.setTicker("测试推送track");notifyModel.setContent("测试推送内容");NotifySender.notifyNow(mActivity, notifyModel); 进度条通知进度条的通知同样使用最基本的 API 就能实现，这里为了简化，借助 NotifyModel 来管理相关参数。 由于进度条类型的通知不能每次更新进度都出现新的通知，因此将 notifyId 单独设置成不变的，不然每次发送新的进度都会有一条。 12345678NotifyModel notifyModel = new NotifyModel();// 初始化类似简单文本通知一些通用基本属性// ...progress += 10;notifyModel.setProgress(0x123, progress, 100, false);NotifySender.notifyNow(mActivity, notifyModel); 在构建通知时，需要设置的有当前进度，进度最大值，是不是精确进度等参数，这些都保存在 NotifyModel 中。 1234// 设置进度if (model.getTotalProgress() != 0) &#123; builder.setProgress(model.getTotalProgress(), model.getCurrentProgress(), model.isIndeterminate());&#125; 带按钮的通知有时候我们需要在进度条上面添加按钮及其相应的触发事件，实现这种效果只需要借助 NotificationCompat.Action 即可，Builder 可以接受一个 Action 的列表，也就代表了多个按钮，测试过程中发现最大支持 3 个按钮。 下面我添加了 4 个按钮，实际上只能显示 3 个，另外需要注意的是创建按钮点击之后触发的 PendingIntent 时，request code 必须是不同的，否则将失去点击效果。 按钮点击之后，通知并不能自动消除掉，需要后续自己来处理。 1234567891011121314NotifyModel notifyModel = new NotifyModel();// 初始化类似简单文本通知一些通用基本属性// ...notifyModel.addAction(new NotificationCompat.Action(R.drawable.ic_launcher, "1", PendingIntent.getActivity(mContext, 101, intent, PendingIntent.FLAG_CANCEL_CURRENT))));notifyModel.addAction(new NotificationCompat.Action(R.drawable.ic_launcher, "2", PendingIntent.getActivity(mContext, 102, intent, PendingIntent.FLAG_CANCEL_CURRENT)));notifyModel.addAction(new NotificationCompat.Action(R.drawable.ic_launcher, "3", PendingIntent.getActivity(mContext, 103, intent, PendingIntent.FLAG_CANCEL_CURRENT)));notifyModel.addAction(new NotificationCompat.Action(R.drawable.ic_launcher, "4", PendingIntent.getActivity(mContext, 104, intent, PendingIntent.FLAG_CANCEL_CURRENT))); NotifySender.notifyNow(mActivity, notifyModel); 构建通知时 123456// 添加按钮及点击事件if (model.getActions() != null) &#123; for (NotificationCompat.Action action : model.getActions()) &#123; builder.addAction(action); &#125;&#125; 自定义视图通知有时仅仅添加按钮并不能满足我们的要求，需要自定义通知的 UI 显示，这一功能需要借助 RemoteViews 来实现。 RemoteViews 可以加载一个布局文件，不过里面控件相关的设置，都需要借助 RemoteViews 的 API 来实现，不过好在和控件的属性还是十分类似的。 12345678910111213141516NotifyModel notifyModel = new NotifyModel();// 初始化类似简单文本通知一些通用基本属性// ...RemoteViews remoteViews = new RemoteViews(mContext.getPackageName(), R.layout.item);// 设置文字remoteViews.setTextViewText(R.id.tv, "test");// 设置图片remoteViews.setImageViewResource(R.id.iv, R.drawable.ic_launcher);// 点击事件remoteViews.setOnClickPendingIntent(R.id.iv, PendingIntent.getActivity(mContext, 104, intent, PendingIntent.FLAG_CANCEL_CURRENT)); notifyModel.setRemoteViews(remoteViews);NotifySender.notifyNow(mActivity, notifyModel); 在构建通知时，只需要将 RemoteViews 作为通知的内容设置进去 12345// 设置自定义视图if (model.getRemoteViews() != null) &#123; builder.setContent(model.getRemoteViews()); // builder.setCustomHeadsUpContentView(model.getRemoteViews());&#125; 接下来的 3 种展示方式，需要我们关注 NotificationCompat.Style 这个类，它确定了通知的风格，比如多行文字风格、收件箱风格、大图片风格，设置方式也很简单只要 1234// 通知栏风格if (model.getNotifyStyle() != null) &#123; builder.setStyle(model.getNotifyStyle());&#125; 多行文字风格通知通常我们的通知只能显示一行，多了以后会隐藏显示，多行文字可以将所有文字显示出来，为了使用的方便，我将设置类型的方法隐藏在了 NotifyModel 类中。 1234// NotifyModel.javapublic void setBigTextStyle() &#123; notifyStyle = new NotificationCompat.BigTextStyle().bigText(content);&#125; 因此当发送通知时只需要 setBigTextStyle() 即可。 1234567NotifyModel notifyModel = new NotifyModel();// 初始化类似简单文本通知一些通用基本属性// ...notifyModel.setBigTextStyle();NotifySender.notifyNow(mActivity, notifyModel); 收件箱风格通知收件箱风格的通知经常出现在即时通讯类的软件中，比如对方发过来几条消息。 创建 InBoxStyle 123456789// NotifyModel.javapublic void setInBoxStyle(List&lt;String&gt; msgList, String msgDesc) &#123; NotificationCompat.InboxStyle inboxStyle = new NotificationCompat.InboxStyle(); for (String msg : msgList) &#123; inboxStyle.addLine(msg); &#125; inboxStyle.setSummaryText(msgDesc); notifyStyle = inboxStyle;&#125; 发送通知时 12345678NotifyModel notifyModel = new NotifyModel();// 初始化类似简单文本通知一些通用基本属性// ...List&lt;String&gt; msgList = LightConverter.listOf("1", "2", "3", "4", "5");notifyModel.setInBoxStyle(msgList, "测试 inbox 描述");NotifySender.notifyNow(mActivity, notifyModel); 大图风格通知这种风格的通知我们通常会在使用手机系统截图时出现在通知面板上面，通知上面会显示一张大图片。 创建 BigPictureStyle 1234// NotifyModel.javapublic void setBigImageStyle(Bitmap bigImage) &#123; notifyStyle = new NotificationCompat.BigPictureStyle().bigPicture(bigImage).bigLargeIcon(bigImage);&#125; 发送通知，注意不要放进去很大的图片。 1234567891011NotifyModel notifyModel = new NotifyModel();// 初始化类似简单文本通知一些通用基本属性// ...BitmapFactory.Options options = new BitmapFactory.Options();options.inSampleSize = 4;String path = new File(Environment.getExternalStorageDirectory(), "1.jpg").getAbsolutePath();Bitmap bitmap = BitmapFactory.decodeFile(path, options);notifyModel.setBigImageStyle(bitmap);NotifySender.notifyNow(mActivity, notifyModel); 对通知进行分组当一个软件发送了大量通知，而用户又没有去点击处理，就会堆积在通知面板上，最后被一键清除掉，自 Android N 之后支持对通知进行分组，点击分组才会显示全部的通知。 在发送通知时，给通知设置一个 Group，这是一个唯一字符串，他用来标记这个通知是属于这个分组的。 123// 通知分组if (model.getNotifyGroup() != null) builder.setGroup(model.getNotifyGroup()); 实际上，所谓的分组，也是一个特殊的通知，只是它在显示在通知面板上面的同时，会将具有相同 Group 的通知给收集到一起，如果这个特殊的通知被 cancel 掉了，原来的通知又会显示出来。因此我们在每次发送通知或者清除通知之后都去需要检测一下当前通知的数量，以及需要不需要再将通知收起。 检测当前应用通知数量，因为分组通知也是一条通知，因此计算数量时要过滤掉。 123456789101112131415private static int getNumberOfNotifications(Context context) &#123; if (AppUtils.isOver(Build.VERSION_CODES.M)) &#123; // 查询当前展示的所有通知的状态列表 final StatusBarNotification[] activeNotifications = getManager(context).getActiveNotifications(); // 获取当前通知栏里头，NOTIFICATION_GROUP_SUMMARY_ID归类id的组别 // 因为发送分组的通知也算一条通知，所以需要-1 for (StatusBarNotification notification : activeNotifications) &#123; if (notification.getId() == NOTIFICATION_GROUP_SUMMARY_ID) &#123; return activeNotifications.length - 1; &#125; &#125; return activeNotifications.length; &#125; return -1;&#125; 当发现通知数量超出限制时，我们就要额外发送一条通知，将所有通知分组收起。 12345678910111213141516171819202122232425private static final int NOTIFICATION_GROUP_SUMMARY_ID = 1;private static void updateNotificationSummary(Context context, NotifyModel model) &#123; if (!AppUtils.isOver(Build.VERSION_CODES.N)) return; int numberOfNotifications = getNumberOfNotifications(context); boolean onlyGroup = isOnlyGroup(context); NotificationManager manager = getManager(context); // 有多条自己的通知，当数量超过要求的限制 if (numberOfNotifications &gt;= model.getSummaryIfMoreThanCount()) &#123; NotificationCompat.Builder builder = new NotificationCompat.Builder(context); // 设置显示的标题 builder.setContentTitle(context.getString(R.string.app_name)); // 设置内容 builder.setContentText("通知已经收起，请查看"); builder .setSmallIcon(model.getSmallIcon()) .setGroup(model.getNotifyGroup()) //设置类组key，说明此条通知归属于哪一个归类 .setGroupSummary(true); //这句话必须和上面那句一起调用，否则不起作用 Notification notification = builder.build(); manager.notify(NOTIFICATION_GROUP_SUMMARY_ID, notification); &#125; else if (numberOfNotifications == 1) &#123; // 只有一条自己的通知 manager.cancel(NOTIFICATION_GROUP_SUMMARY_ID); &#125;&#125; 清除通知123456789101112private static NotificationManager getManager(Context context) &#123; return (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);&#125;// 清除指定通知public static void clearById(Context context, int id) &#123; NotificationManager manager = getManager(context); if (id != -1) manager.cancel(id); else manager.cancelAll();&#125; PendingIntent这是一个类似 Intent 的组件，也是一种 意图，不同的是它可以作为通知事件的触发事件，PendingIntent 可以在通知事件被触发时启动一个 Activity，或者发送一个 Broadcast，又或者启动一个 Service，这取决于如何构造 PendingIntent。 比较来说，使用开启 Activity 的 PendingIntent 比较简单，点击之后立刻就可以打开界面，缺点就是当通知发送出去时，触发事件已经无法更改，举个例子，比如当用户没有登录时需要打开登录界面，反之进入指定页面；再比如，想在通知被点击时触发网络请求进行数据统计，这些情况都最好选择 Broadcast 的 PendingIntent，它使得通知的事件触发之后，发送广播到指定接受者，我们可以后续再做更多操作，这样更灵活。 开启 Activity 12Intent intent = new Intent(mContext, HomeActivity.class);PendingIntent.getActivity(mContext, 104, intent, PendingIntent.FLAG_CANCEL_CURRENT) 发送 Broadcast 12345678class MyReceiver extends BroadcastReceiver&#123; @Override public void onReceive(Context context, Intent intent) &#123; &#125;&#125;Intent intent = new Intent(mContext,MyReceiver.class);PendingIntent.getBroadcast(mContext, 104, intent, PendingIntent.FLAG_CANCEL_CURRENT); 总结以上，是关于系统通知的内容，关于通知分组在 Android 7.0 上面的具体显示，因为没有手机测试，所以没有真的测试过，在 6.0 手机上可以将通知收起，但是却没办法再展开了，后面还需要更多的测试来慢慢研究这部分。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AndroidTips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为iPhone制作手机铃声 [Tips]]]></title>
    <url>%2Farticle%2Ff622e275%2F</url>
    <content type="text"><![CDATA[使用 iPhone 手机没法像 Android 那样简单的设置手机铃声，需要借助 iTunes。 我使用的 Mac 电脑，所以一些操作相对简单一些。 下载音乐拖放到 iTunes 列表中，在音乐上右键，查看 音乐信息 查看 选项，修改 开始 和 结束 的时间，最长不要超过 40s，点击播放，查看一下是不是想要截取的片段 点击菜单栏 -&gt; 文件 -&gt; 转换 -&gt; 创建 AAC 版本，在音乐上右键在文件夹显示出来，会发现多了一个 m4a 文件 将这个文件拷贝到别的地方备用，后缀改为 m4r，从音乐列表中删除原始的音乐文件 选择铃声类别，将 m4r 文件拖放到文件列表中 使用数据线连接手机，查看手机的音乐列表，点击手机的铃声类别，选择指定的铃声同步即可]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Learn About HTML]]></title>
    <url>%2Farticle%2Fef811326%2F</url>
    <content type="text"><![CDATA[从头开始系统的学习 Html 标签的用法，做好记录，加深记忆。 页面构成整个 html 页面主要由 &lt;html/&gt; 标签，&lt;head/&gt; 标签，&lt;body/&gt; 标签组成。 123456789101112&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; ...&lt;/head&gt;&lt;body&gt; ...&lt;/body&gt;&lt;/html&gt; \&lt;title&gt; 内容将显示在浏览器 tab 栏上。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin开发-19-Anko]]></title>
    <url>%2Farticle%2F49416638%2F</url>
    <content type="text"><![CDATA[下面是我抄的 Anko - GitHub 上面的描述 Anko is a Kotlin library which makes Android application development faster and easier. It makes your code clean and easy to read, and lets you forget about rough edges of the Android SDK for Java. Anko consists of several parts: 1234567Anko Commons: a lightweight library full of helpers for intents, dialogs, logging and so on;Anko Layouts: a fast and type-safe way to write dynamic Android layouts;Anko SQLite: a query DSL and parser collection for Android SQLite;Anko Coroutines: utilities based on the kotlinx.coroutines library. Commons1compile &quot;org.jetbrains.anko:anko-commons:$anko_version&quot; Commons 库就类似于我们的快速开发框架，在一些基础 API 的基础上进一步封装，达到更加简化的目的。 Intent对 Intent 的扩展，大大简化构造 Intent 的过程 123456789101112131415// 打开 ActivitystartActivity(intentFor&lt;HomeActivity&gt;())intentFor&lt;HomeActivity&gt;( "id" to 5, "name" to "chendong") intentFor&lt;HomeActivity&gt;( "id" to 5, "name" to "chendong").singleTop() intentFor&lt;HomeActivity&gt;( "id" to 5, "name" to "chendong") .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK) 针对一些 Intent 的常用操作，也做了封装 12345678910// 打电话-需要申请权限makeCall("13611301718")// 发邮件email("helloworld@gmail.com", "subject", "email-body")// 发短信sendSMS("13611301718", "msg-body")// 分享文字share("title", "msg-body")// 开启浏览器browse("http://www.baidu.com", true) UI Extension显示 Toast 123toast("toast msg")toast(R.string.msg)longToast("long toast msg") 显示 AlertDialog 12345678910111213alert(Appcompat, "message", "title") &#123; okButton &#123; it.dismiss() &#125; cancelButton &#123; it.dismiss() &#125;&#125;.show()alert &#123; customView &#123; editText() &#125;&#125;.show() 显示选择列表的 Dialog 1234selector("selector", listOf("1", "2", "3")) &#123; dialog, index -&gt; dialog.dismiss() toast("click $index")&#125; 显示 ProgressDialog 12345progressDialog("message", "title") &#123;&#125;indeterminateProgressDialog("message", "title") &#123;&#125; Log创建 log 打印 123456// tag 为 TestCommonsActivityval logger = AnkoLogger&lt;TestCommonsActivity&gt;()// tag 为 CustomTagval logger2 = AnkoLogger("CustomTag")// tag 为 Testval logger3 = AnkoLogger(Test::class.java) 输出日志，支持函数计算，这样可以在输出的再计算相关的值 12345678910111213141516logger.verbose &#123; "lazy calculate verbose msg" &#125;logger.verbose("verbose msg")logger.debug &#123; "lazy calculate debug msg" &#125;logger.debug("debug msg")logger.info &#123; "lazy calculate info msg" &#125;logger.info("info msg")logger.warn &#123; "lazy calculate warn msg" &#125;logger.warn("warn msg")logger.error &#123; "lazy calculate error msg" &#125;logger.error("error msg")logger.wtf("error", IllegalStateException("error")) Misc将颜色转化为非透明色，alpha 部分会被转换为 ff 10x00ff0000.opaque 灰化，将给的颜色单一色值进行灰化，红绿蓝三部分会变成相同的色值，但是最好使用一个色值的两位，它使用了移位运算，不然结果会有点混乱 1234// 将会返回 0xff9999990x99.gray.opaque // 将会返回 0xffffff990xff99.gray.opaque 尺寸转换 12345678// sp 转 pxsp(10)// dp 转 pxdip(10)// px 转 dppx2dip(10)// px 转 sppx2sp(10) 递归遍历所有 child view，这边需要结合一点 Layouts 框架的内容，用于最后对 View 进行设置 12345678verticalLayout &#123; button("log") &#123;&#125; button("color") &#123;&#125;&#125;.applyRecursively &#123; when (it) &#123; is Button -&gt; it.text = "$&#123;it.text&#125; add" &#125;&#125; 简化版本的 findViewById() 1234textView(R.string.app_name)&#123; textResource = R.string.app_name backgroundResource = R.mipmap.ic_launcher&#125; 在 Activity 和 Fragment 中可以直接使用 ctx 和 act 来访问上下文。 1234// context ctx// Activityact LayoutsLayouts 框架最大的亮点就是 DSL(Domain Specific Language)，领域专用语言，它提供了一种新的构建 UI 的方式，为什么要使用 DSL，下文摘自 GitHub 1234567By default, UI in Android is written using XML. That is inconvenient in the following ways:It is not typesafe;It is not null-safe;It forces you to write almost the same code for every layout you make;XML is parsed on the device wasting CPU time and battery;Most of all, it allows no code reuse. 使用传统的 xml 构建方式，使用起来真的很简单，还有实时预览，但是同样有很多缺点，比如类型安全，空安全，不能进行声明数据访问数据，xml 的解析浪费了大量性能等，而如果使用代码编写 UI，简直痛苦死，但是使用 DSL 可以避免这些问题，而且还有插件支持实时预览，还有什么理由拒绝呢？ 添加依赖，发现 com.google.android 无法下载，因此过滤掉，另外需要注意的是如果依赖了 kotlin 协程官方的扩展库，需要删除掉，否则版本不同可能会出问题。 12// 不需要重复依赖compile 'org.jetbrains.kotlinx:kotlinx-coroutines-core:0.18' 使用 Layouts 需要以下依赖 123456789101112131415// Anko Layouts // sdk15, sdk19, sdk21, sdk23 are also availablecompile("org.jetbrains.anko:anko-sdk25:$anko_version") &#123; exclude group: 'com.google.android', module: 'android'&#125;compile("org.jetbrains.anko:anko-appcompat-v7:$anko_version") &#123; exclude group: 'com.google.android', module: 'android'&#125;// Coroutine listeners for Anko Layoutscompile("org.jetbrains.anko:anko-sdk25-coroutines:$anko_version") &#123; exclude group: 'com.google.android', module: 'android'&#125;compile("org.jetbrains.anko:anko-appcompat-v7-coroutines:$anko_version") &#123; exclude group: 'com.google.android', module: 'android'&#125; Basics不再需要 setContentView() 12345678910override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) var view1 = find&lt;TextView&gt;(R.id.mTestTv) var view2 = findOptional&lt;TextView&gt;(R.id.mTestTv) // 直接声明布局 verticalLayout &#123; &#125;&#125; 使用 DSL 布局，用起来和 xml 相差不大，借助代码的缩进可以清晰的想象出布局的样式，支持 Android 所有的控件。 123456789101112131415verticalLayout &#123; // 垂直的 LinearLayout verticalLayout &#123; button &#123; &#125; progressBar &#123; &#125; &#125; // 水平的 LinearLayout linearLayout &#123;&#125; // RelativeLayout relativeLayout &#123;&#125; // FrameLayout frameLayout &#123;&#125; // AbsoluteLayout absoluteLayout &#123;&#125;&#125; 控件属性和 LayoutParams声明控件的属性，控制控件的绘制显示，在创建控件时会传入一个初始化函数，在该函数中可以进行控件属性的初始化，写过 xml 这些属性用起来其实没什么太大差别，学习成本不高，同样每个属性都会对应一个使用 resource 的方法，用来兼容使用 xml 声明的 string,color 等，来避免硬编码。 12345678910verticalLayout &#123; backgroundColor = 0xff.gray.opaque textView("textview") &#123; text = "i am tv" textColor = 0x00.gray.opaque textSize = 18f backgroundColor = Color.YELLOW gravity = Gravity.CENTER &#125;&#125; 设置 LayoutParams，他用来表示该控件在父布局中绘制显示 1234567891011121314151617181920textView("textview") &#123; // ... // 文字在控件内居中 gravity = Gravity.CENTER&#125;.lparams &#123; // 整个控件在父布局中靠右 gravity = Gravity.RIGHT width = matchParent height = dip(200) // margin margin = dip(10) horizontalMargin = dip(10) verticalMargin = dip(10) leftMargin = dip(10) // padding padding = dip(10) verticalPadding = dip(10) horizontalPadding = dip(10) leftPadding = dip(10)&#125; RelativeLayout别的布局不用多说，控件之间的依赖相对简单，针对 RelativeLayout 要复杂一些，在 Anko 中可以类似 xml 中一样，使用相似的语法依赖其他控件的 id，也可以直接依赖控件引用，当然里面的原理还是根据 id 依赖。 关于 id，无法像 xml 中可以自动生成，所以要么使用 val ID_VIEW = 100 这样的形式声明，要么使用 resources 的方式，推荐后面一种，如下： 123&lt;resources&gt; &lt;item name="test_tv" type="id"/&gt;&lt;/resources&gt; ps：就算是依赖控件的引用，也必须为控件声明 id，因为内部原理还是使用 id 依赖，没有 id 会异常。 使用 RelativeLayout 布局 1234567891011121314151617181920212223242526272829303132333435363738relativeLayout &#123; val tv = textView &#123; id = R.id.test_tv textColor = 0x00.gray.opaque text = "i am textview in relative layout" &#125; button &#123; text = "i am button below textview" &#125;.lparams &#123; // 支持 id rightOf(R.id.test_tv) // 支持 控件 rightOf(tv) rightOf(R.id.test_tv) leftOf(R.id.test_tv) above(R.id.test_tv) below(R.id.test_tv) centerInParent() centerVertically() centerHorizontally() alignParentTop() alignParentBottom() alignParentRight() alignParentLeft() sameLeft(R.id.test_tv) sameRight(R.id.test_tv) sameTop(R.id.test_tv) sameBottom(R.id.test_tv) alignStart(R.id.test_tv) alignEnd(R.id.test_tv) baselineOf(R.id.test_tv) &#125;&#125; Theme对每个控件都有一个 themedXXXX 的实现，支持使用 R.style.xxx 来初始化 1234&lt;style name="MyTv"&gt; &lt;item name="android:text"&gt;来自style的text&lt;/item&gt; &lt;item name="android:textColor"&gt;#000000&lt;/item&gt;&lt;/style&gt; 使用 theme 创建 123verticalLayout &#123; themedTextView(R.style.MyTv)&#125; Listeners为控件设置监听，所有监听默认支持协程，这意味着你可以在监听中直接执行异步任务，还有一个优势就是实现一个监听时不再要实现所有方法。 12345678910111213141516171819// 在监听之中直接执行耗时操作button("test") &#123; onClick &#123; // 耗时 val result = bg &#123; Thread.sleep(1000) System.currentTimeMillis().toString() &#125; textView.text = result.await() &#125;&#125;// 实现需要的监听editText &#123; textChangedListener &#123; afterTextChanged &#123; &#125; &#125;&#125; Extends在 DSL 中支持扩展使用自定义控件 12345class MyView(context: Context?) : TextView(context)inline fun ViewManager.myView(init: MyView.() -&gt; Unit): MyView &#123; return ankoView(&#123; MyView(it) &#125;, theme = 0, init = init)&#125; 这样在 DSL 中就可以使用 12345verticalLayout &#123; myView &#123; text = "自定义控件" &#125;&#125; Include包含 layout.xml 文件，使用 include，范型决定了在函数中你可以使用的类型 12345verticalLayout&#123; include&lt;TextView&gt;(R.layout.main_activity)&#123; text = "text" &#125;&#125; Convert转换 xml -&gt; DSL 1Code -&gt; Covert to Anko Layouts DSL Component使用 AnkoComponent 可以让我们将 UI 部分单独的独立出来，而不是挂在 Activity 生命周期方法中国，可以让代码更清晰 12345678910111213141516class SplashActivityUI : AnkoComponent&lt;SplashActivity&gt; &#123; override fun createView(ui: AnkoContext&lt;SplashActivity&gt;): View = with(ui) frameLayout &#123; backgroundResource = R.drawable.splash_bg_bitmap textView("Security Files") &#123; gravity = Gravity.CENTER backgroundColor = white textColor = black verticalPadding = dip(15) textSize = sp(16f).toFloat() &#125;.lparams(width = matchParent, height = wrapContent) &#123; gravity = Gravity.CENTER &#125; &#125; &#125;&#125; 然后在 Activity 的 onCreate() 方法中添加布局 1SplashActivityUI().setContentView(this) 使用 AnkoComponent 不止可以将 Activity 中的布局分离出来，他其实是一种对布局代码进行解耦复用的方法，我们也可以用它来加载 RecyclerView 的 item CoroutinesCoroutines 框架是基于 kotlinx-coroutine 框架的扩展，在此基础上针对 Android 做了简化。 1compile "org.jetbrains.anko:anko-coroutines:$anko_version" asReference这个主要用来避免如果你在一个不能取消的协程之中引用了上下文，由于协程可能被挂起，这一操作有可能导致内存泄漏，因此 anko 提供了 asReference 方法来获取当前上下文的弱引用，避免内存泄漏。 1234567891011private val ref: Ref&lt;TestAnkoCoroutineActivity&gt; = asReference()private val tv: TextView by lazy &#123; find&lt;TextView&gt;(R.id.test_tv)&#125;fun test() &#123; launch(UI) &#123; ref().tv.hide() &#125;&#125; bg用来快速的创建一个需要耗时的异步任务，并返回结果 123456789101112tv.setOnClickListener &#123; launch(UI) &#123; pb.show() val rst = bg &#123; Thread.sleep(1000) val index = time + (1..1000).sum() index &#125; tv.text = rst.await().toString() pb.hide() &#125;&#125; SQLite暂不研究]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin开发-18-协程]]></title>
    <url>%2Farticle%2F794b3d5f%2F</url>
    <content type="text"><![CDATA[协程 Coroutines，指各任务协作运行； 线程是操作系统层面的，由操作系统调度执行，我们可以开启一个线程，但无法知道线程什么时候执行，什么时候执行完，因此我们通常使用回调的形式在线程执行完之后接受执行的结果，线程的运行是抢占式的，后起的 B 线程可能抢占先起的 A 线程的资源，A 线程会被阻塞，从而造成资源的浪费。 协程是应用层面的，它由虚拟机进行调度，我们可以随意开启和终止协程的运行，协程是非抢占氏的，如果当前协程在运行，除非当前运行的协程主动 退让，挂起，否则其他协程不会抢占运行机会，由于各任务写作运行，就避免了创建大量的线程。 协程本身并不具备线程切换的功能，耗时操作等仍旧需要我们手动切换到子线程执行，但是协程的 API 设计使得我们可以像编写同步代码一样编写异步代码，避免使用回调，逻辑也更清晰。 本文中的代码没有真正的进行操作，使用输出 log 来代替 推荐阅读深入理解 Kotlin Coroutine 1 - 知乎 深入理解 Kotlin Coroutine 2 - 知乎 Kotlin Coroutines 使用回调进行异步使用回调接口获取异步结果，是在 Java 中常用的方法，在主线程进行 UI 操作，切换到子线程进行耗时操作，操作的结果返回到主线程更新 UI。 1234567891011121314151617181920212223// 线程池val pool: ExecutorService by lazy &#123; Executors.newCachedThreadPool()&#125;// 一个很忙的方法，回调返回值fun doLotsOfThingsWithCallBack(callback: (String) -&gt; Unit) &#123; pool.execute &#123; log("开始耗时") Thread.sleep(100) Handler(Looper.getMainLooper()).post &#123; callback.invoke("result") &#125; &#125;&#125;fun testCallback() &#123; log("开始先来个UI操作") doLotsOfThingsWithCallBack &#123; log("回调拿到结果了 -&gt; $it") log("再来个UI操作") &#125;&#125; 因为我们只有一层回调，加上 Kotlin 对 Lambda 表达式的支持，看起来代码还不是那么难看，这也是在 Java 中常用的方法，相对好理解一些，看一下输出结果： 1234E/Coroutine: main 开始先来个UI操作E/Coroutine: pool-1-thread-1 开始耗时E/Coroutine: main 回调拿到结果了 -&gt; resultE/Coroutine: main 再来个UI操作 使用协程实现协程借助 suspend 关键字实现，使用 suspend 关键字描述的函数，表示此函数可以被挂起。 介绍几个概念 CoroutineContext，协程上下文，很多框架都会有一个上下文对象，支持 + 操作符，因此它可以是多个上下文的累加结果，Kotlin 中实现了一个空的实现 EmptyCoroutineContext，用来占位。 Continuation，协程中的任务执行后的操作，它可以返回任务的结果或者异常。 同样使用协程来实现一个和上面类似的功能： 123456789101112131415161718192021222324252627282930313233343536fun testCoroutine() &#123; log("开始先来个UI操作") callCoroutine &#123; // 执行耗时操作，执行完之后会继续往下走 val result = doLotsOfThingsCanSuspend("test") log("拿到结果了 -&gt; $result") log("再来个UI操作") &#125;&#125;// 一个耗时的方法，可能被挂起suspend fun doLotsOfThingsCanSuspend(p: String): String = suspendCoroutine &#123; pool.execute &#123; log("开始耗时") Thread.sleep(100) log("耗时结束") if (p.isNotEmpty()) it.resume("succeed result") else it.resumeWithException(IllegalStateException("len &lt; 0")) &#125;&#125;// 开始协程fun callCoroutine(block: suspend () -&gt; Unit) &#123; block.startCoroutine(object : Continuation&lt;Unit&gt; &#123; override val context: CoroutineContext get() = EmptyCoroutineContext override fun resume(value: Unit) &#123; &#125; override fun resumeWithException(exception: Throwable) &#123; &#125; &#125;)&#125; 输出结果： 12345E/Coroutine: main 开始先来个UI操作E/Coroutine: pool-2-thread-1 开始耗时E/Coroutine: pool-2-thread-1 耗时结束E/Coroutine: pool-2-thread-1 拿到结果了 -&gt; succeed resultE/Coroutine: pool-2-thread-1 再来个UI操作 我们看到，最后结果的 UI 操作，还是在子线程跑的，这个是不允许的，但是从代码上面，最后打印结果的代码明明是在主线程，其实 var resule = xx 之后的代码就如同回调中的代码，它的运行环境取决于 Continuation 的 resume() 方法执行的环境，在这段协程的代码中，最关键的一句是 1val result = doLotsOfThingsCanSuspend("test") 它替代了原先的回调方法，也实现了类似原来回调的功能，当运行到这边时，函数会被挂起，等结果返回之后才会赋值并且进行后面的操作，避免了层层回调嵌套，另外虽然最后拿到结果的代码看起来是写在主线程，其实最后运行在了子线程，因此我们可以如下，修改代码，保证最后的结果被传递回主线程。 1234567891011121314// 一个耗时的方法，可能被挂起suspend fun doLotsOfThingsCanSuspend(p: String): String = suspendCoroutine &#123; pool.execute &#123; log("开始耗时") Thread.sleep(100) log("耗时结束") Handler(Looper.getMainLooper()).post &#123; if (p.isNotEmpty()) it.resume("succeed result") else it.resumeWithException(IllegalStateException("len &lt; 0")) &#125; &#125;&#125; 但是对于这个操作，借助 Continuation 和 CoroutineContext 可以有更优雅的实现。 将结果返回切换到主线程写一个 Continuation 的包装类 UIContinuation，这个很好理解，一个典型的包装者模式，他包装其他的 Continuation 在调用 resume() 方法时将结果返回主线程。 123456789101112131415class UIContinuation&lt;in T&gt;(val delegate: Continuation&lt;T&gt;) : Continuation&lt;T&gt; &#123; val handler by lazy &#123; Handler(Looper.getMainLooper()) &#125; override val context: CoroutineContext get() = delegate.context override fun resume(value: T) &#123; handler.post &#123; delegate.resume(value) &#125; &#125; override fun resumeWithException(exception: Throwable) &#123; handler.post &#123; delegate.resumeWithException(exception) &#125; &#125;&#125; 重写 CoroutineContext 自动完成 Continuation 的包装，需要一个接收外界设置的 CoroutineContext 的 Continuation，他其实什么也不需要做。 123456class ContextContinuation(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation&lt;Unit&gt; &#123; override fun resume(value: Unit) &#123; &#125; override fun resumeWithException(exception: Throwable) &#123; &#125;&#125; 重写 CoroutineContext 使用插值器的方式包装，这里使用了 ContinuationInterceptor，他也是 CoroutineContext 的子类，类似 okHttp 的 interceptor，他的作用就是，拦截旧的 Continuation 如果需要的话生成新的 Continuation. 1234567891011121314class AsyncCoroutineContext : AbstractCoroutineContextElement(ContinuationInterceptor.Key), ContinuationInterceptor &#123; override fun &lt;T&gt; interceptContinuation(continuation: Continuation&lt;T&gt;): Continuation&lt;T&gt; &#123; // 这里使用 fold 函数是为了兼容会有其他插值器想更改 Continuation 的操作，因此不能草率的直接返回 // 如果不好理解，也可以直接理解为 return UIContinuation() return UIContinuation(continuation.context.fold(continuation) &#123; con, element -&gt; if (element != this &amp;&amp; element is ContinuationInterceptor) &#123; element.interceptContinuation(con) &#125; else con &#125;) &#125;&#125; 此时，调用如下方法启动协程，配置可以将结果返回主线程的上下文，当结果返回时会自动返回主线程。 123fun callCoroutine(block: suspend () -&gt; Unit) &#123; block.startCoroutine(ContextContinuation(AsyncCoroutineContext()))&#125; 使用 CoroutineContext 传参首先，CoroutineContext 有一个不错的特性，就是重载了 + 操作符，因为我们可以对 CoroutineContext 进行加法操作返回新的 CoroutineContext 为了方便使用，我们将基础的方法进行提取，他们实现一个通用的功能，即切换后台线程执行耗时操作，然后在主线程接收结果更改UI。 12345678910111213141516171819// 开始协程，可以从外界接受上下文变量fun callCoroutine(context: CoroutineContext = EmptyCoroutineContext, block: suspend () -&gt; Unit) &#123; // 自动具备了将结果切换回主线程的功能 block.startCoroutine(ContextContinuation(AsyncCoroutineContext() + context))&#125;// 一个通用的执行耗时操作的方法，可能被挂起// 接受的参数是 CoroutineContext 的扩展函数，这样的写法好处在于可以在函数内使用 this 访问// 在参数 block 指向的函数中，是一个任意的耗时操作suspend fun &lt;T&gt; doLotsOfThingsCanSuspend(block: CoroutineContext.() -&gt; T): T = suspendCoroutine &#123; pool.execute &#123; try &#123; it.resume(block(it.context)) &#125; catch (e: Exception) &#123; e.printStackTrace() it.resumeWithException(e) &#125; &#125;&#125; 借助上面的抽象出来的两个方法可以开启协程，执行任意耗时操作，并将结果返回到主线程，接下来使用 ConroutineContext 进行参数的传递，从上面我们发现 block 函数是一个无参的函数，而各种耗时操作参数不一，怎么兼容这个问题，就需要使用 ConroutineContext ，他是一个上下文，是整个运行环境，借助它我们可以传递参数，定义一个携带参数的上下文，它仍旧是 AbstractCoroutineContextElement 的子类，并标记一个 Key 1234// 携带上下文的 contextclass ParamContext(val url: String) : AbstractCoroutineContextElement(Key) &#123; companion object Key : CoroutineContext.Key&lt;ParamContext&gt;&#125; 从上下文中获取参数，重点在于 this[ParamContext.Key]，也可以写作 this[ParamContext]，因为那个 Key 是一个伴生对象，能用下标访问是因为 CoroutineContext 重载了 [] 操作符，从而可以取出之前传递的 ParamContext 1234567891011121314fun testCoroutine() &#123; log("开始先来个UI操作") callCoroutine(ParamContext("test")) &#123; // 执行耗时操作，执行完之后会继续往下走 val result = doLotsOfThingsCanSuspend &#123; log("开始耗时") Thread.sleep(100) log("耗时结束") this[ParamContext.Key]?.url?.length.toString() &#125; log("拿到结果了 -&gt; $result") log("再来个UI操作") &#125;&#125; Sequence官方的一个例子 1234567891011121314151617val fibonacci = buildSequence &#123; yield(1) // 此处返回 1 并挂起 var cur = 1 var next = 1 while (true) &#123; yield(next) // 返回下一个值并挂起 val temp = cur + next cur = next next = temp &#125;&#125;for (i in fibonacci) &#123; log("$i") if (i &gt; 100) break&#125; 每次对 Sequence 迭代遍历下一个时，会执行协程到 yield 的位置返回值，并挂起，等待下一次迭代，这样就构造了一个懒序列，只有在需要的时候才会计算生成，而不是一次生成大量数据，除了第一次，他的每次被调起，都是从这次 yield 到下次 yield 总结使用 suspendCoroutine 构造一个可挂起的函数，在内部执行操作，通过 Continuation 的 resume() 方法将结果或者异常返回，你可以决定返回之前是不是要进行自己的处理，比如发到主线程。 Continuation 是一个接口，他是一个结果的接受处理者，这也是 Continuation 的含义，他将在任务完成之后被调用。 CoroutineContext 是一个上下文，表示一个运行时环境，它可以做很多事，比如传递参数等。 ContinuationInterceptor 是 Continuation 的插值器，提供一个更改原来的 Continuation 的机会，用来创建返回新的 Continuation。 从代码层面上面，可以跟回调的方法稍作比较，下面代码中，其实 var result = xxx 这里就相当于一个回调，但是并不是回调的形式，在这里执行 doLotsOfThingsCanSuspend() 时，函数会被挂起，等待结果返回，这不是一个阻塞的过程，异步线程的切换在挂起函数内进行，因此我们可以像写同步代码一样，书写异步代码，结果返回之后，后面的代码其实相当于回调里面的代码，此时才会继续执行，和回调一样，它的运行环境取决于挂起函数中调用 resume() 方法时的环境。 123456callCoroutine &#123; // 执行耗时操作，执行完之后会继续往下走 val result = doLotsOfThingsCanSuspend("test") log("拿到结果了 -&gt; $result") log("再来个UI操作")&#125; Kotlinx 官方协程扩展框架添加依赖 1compile 'org.jetbrains.kotlinx:kotlinx-coroutines-core:0.18' 借助 launch() 函数来开启一个协程，CommonPool 是内置的一个上下文，他将会在子线程执行任务。 1234567891011121314fun test1() &#123; var result = 0 // 开启协程 log(TAG, "开始协程") launch(CommonPool) &#123; log(TAG, "协程内开始") for (i in 1..1000) &#123; result += i &#125; log(TAG, "协程内结束") &#125; log(TAG, "结束协程") log(TAG, result.toString())&#125; 输出结果为 12345E/tag: main 开始协程E/tag: main 结束协程E/tag: main 0E/tag: ForkJoinPool.commonPool-worker-2 协程内开始E/tag: ForkJoinPool.commonPool-worker-2 协程内结束 结果就好像我们在子线程执行了一个任务，他并没有干预外面的代码运行，也没有获得预期的值，我们希望后面的任务在子线程的代码计算完成之后在执行，需要使用 join() 函数。 launch() 函数返回一个 Job 对象，同时 join() 函数需要在一个可挂起的函数内执行，使用 runBlocking() 函数使用 EmptyCoroutineContext 可以在当前位置开启协程； 这样就得到了预期的结果，同样我们可以调用 job.cancel() 来结束这个任务 1234567891011121314151617fun test2() &#123; runBlocking &#123; var result = 0 log(TAG, "开始协程") val job = launch(CommonPool) &#123; log(TAG, "协程内开始") for (i in 1..1000) &#123; delay(1) result += i &#125; log(TAG, "协程内结束") &#125; job.join() // 要求当前协程，等待该协程执行完再执行 log(TAG, "结束协程") log(TAG, result.toString()) &#125;&#125; 输出结果为 12345E/tag: main 开始协程E/tag: ForkJoinPool.commonPool-worker-2 协程内开始E/tag: ForkJoinPool.commonPool-worker-2 协程内结束E/tag: main 结束协程E/tag: main 500500 获取返回值，上面我们使用了变量的形式来存储计算的值，当我们需要一个任务的返回值时，最好还是让任务能够返回执行完的结果，使用 async() 函数可以返回一个 Deferred 对象，从里面可以取到执行结果 123456789101112launch(CommonPool) &#123; val deferred1 = async(CommonPool) &#123; delay(1000) "result" &#125; val deferred2 = async(CommonPool) &#123; delay(2000) 100 &#125; log(TAG, "$&#123;deferred1.await()&#125;,$&#123;deferred2.await()&#125;") log(TAG, "$&#123;deferred1.getCompleted()&#125;,$&#123;deferred2.getCompleted()&#125;")&#125; 输出结果 12E/tag: ForkJoinPool.commonPool-worker-1 result,100E/tag: ForkJoinPool.commonPool-worker-1 result,100 在子线程计算，在主线程更新，UI 是一个协程上下文，他使用 Handler 将结果分发到主线程。 123456789101112launch(UI) &#123; val deferred = async(CommonPool) &#123; var index = 1 for (i in 1..100) &#123; delay(10) Thread.sleep(10) index += i &#125; index &#125; mTestTv.text = deferred.await().toString()&#125;]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin开发-17-注解]]></title>
    <url>%2Farticle%2Fbc7a3f35%2F</url>
    <content type="text"><![CDATA[本文主要学习 Kotlin 注解的相关内容。 源注解@Target : 指定这个注解可被用于哪些元素(类, 函数, 属性, 表达式…) 1234567891011121314151617@Target( AnnotationTarget.ANNOTATION_CLASS, // 注解类 AnnotationTarget.CLASS, // 对象类，接口，也包括注解类 AnnotationTarget.CONSTRUCTOR, // 构造器，主构造器或次级构造器 AnnotationTarget.EXPRESSION, // 表达式 AnnotationTarget.FIELD, // 属性，包括 backing-field AnnotationTarget.FILE, // 文件 AnnotationTarget.FUNCTION, // 函数，也包括构造器 AnnotationTarget.LOCAL_VARIABLE, // 局部变量 AnnotationTarget.PROPERTY, // 属性 AnnotationTarget.PROPERTY_GETTER, // 属性 get 方法 AnnotationTarget.PROPERTY_SETTER, // 属性 set 方法 AnnotationTarget.TYPEALIAS, // 类型别名 AnnotationTarget.TYPE, // 类型 AnnotationTarget.TYPE_PARAMETER, // 范型参数类型 AnnotationTarget.VALUE_PARAMETER // 值类型参数) @Retention : 注解信息在 class 文件中的保存和访问限制 12345@Retention( AnnotationRetention.SOURCE // 注解信息不保存 class 文件，不能反射访问 // AnnotationRetention.BINARY // 注解信息保存 class 文件，不能反射访问 // AnnotationRetention.RUNTIME // 注解信息保存 class 文件，能反射访问) @Repeatable : 允许在一个元素上多次使用同一注解 @MustBeDocumented : 表示这个注解是公开 API 的一部分，在自动产生的 API 文档的类或者函数签名中，应该包含这个注解的信息。 注解和使用注解的声明使用 annotation 关键字，类似一个类的声明，在上面添加源注解对定义的注解进行描述。 12345@Target(AnnotationTarget.ANNOTATION_CLASS)@Retention(AnnotationRetention.SOURCE)@Repeatable@MustBeDocumentedannotation class AnnoSimple 使用注解，注解可以添加在很多地方，取决于声明 @Target 中支持的类型 1234567891011121314151617181920// 类注解@AnnoSimple class AnnoTestA// 构造器注解@AnnoSimple constructor(name: String) &#123; // 函数注解 @AnnoSimple fun test() &#123; // lambda 表达式注解 val f = @AnnoSimple &#123; log("test") &#125; &#125; // 属性注解 @AnnoSimple var property: Int = 100 // get 方法注解 @AnnoSimple get() = 10 // set 方法注解 @AnnoSimple set(value) &#123; field = value &#125;&#125; 注解参数注解可以添加参数，参数支持 基本数据类型，字符串，KClass，枚举，其他注解，由以上数据类型构成的数组。 123@Target(AnnotationTarget.CLASS,AnnotationTarget.FIELD)@Retention(AnnotationRetention.SOURCE)annotation class AnnoWithParam(val msg: String, val cls: KClass&lt;*&gt;) 注解同样可以作为注解的参数，如果一个注解被用作另一个注解的参数, 那么在它的名字之前不使用 @ 前缀 12annotation class AnnoWithAnotherAnno(val msg: String, val anno: AnnoWithParam = AnnoWithParam("test", Int::class)) 使用注解 1@AnnoWithParam("test", Int::class) class AnnoTestB 注解的使用目标当你对一个属性或一个主构造器的参数添加注解时，从一个 Kotlin 元素会产生出多个 Java 元素，因此在编译产生的 Java 字节码中，你的注解存在多个可能的适用目标。 支持的注解目标 123456789fileproperty (使用这个目标的注解, 在 Java 中无法访问)field (域变量)get (属性的 get 方法)set (属性的 set 方法)receiver (扩展函数或扩展属性的接受者参数)param (构造器的参数)setparam (属性 set 方法的参数)delegate (保存代理属性的代理对象实例的域变量) 为了明确指定注解应该使用在哪个元素上，可以使用以下语法： 12345class AnnoTestC( @field:AnnoSimple val name: String, // 对域变量注解 @param:AnnoSimple val age: Int, // 构造器参数注解 @get:AnnoSimple val cls: KClass&lt;*&gt; // get方法注解) 当对同一注解目标使用多个注解时，可以使用 @set[anno1 anno2] 的语法 123class AnnoTestD( @field:[AnnoSimple AnnoWithParam("test", Int::class)] val name: String) 对扩展函数使用注解 1fun @receiver:Fancy String.myExtension() &#123; &#125;]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DataBinding]]></title>
    <url>%2Farticle%2F83ba57f4%2F</url>
    <content type="text"><![CDATA[本文记录如何使用 Google 官方库 DataBinding 进行数据绑定。 平时编译使用 Freeline ，但是很遗憾的是 Freeline 在 DataBinding 的支持上还有些问题，希望早些解决。 另外 AndroidStudio 对 DataBinding 的语法支持的不是很好，很多官网文档的语法在项目的编译期都是报错的，后面应该会有改进。 开启 DataBinding在 AndroidStudio 开启 DataBinding 十分简单，只需要在 对应的 build.gradle 文件中声明 1234567android &#123; ... dataBinding &#123; enabled = true &#125; ...&#125; 开启之后即可使用，这里我遇到了异常如下，clean 项目仍不见效果，解决措施在去除下面提到的警告的前提下，由菜单 File-&gt;Invalidate Caches/ReStart，重启 IDE 即可。 1Generated class list does not exist /Users/march/AndroidPro/DevKitSample/devKit/build/intermediates/data-binding-info/release/_generated.txt 由于我使用 ButterKnife 等注解类框架，遇到 Warning，如下： 1Warning:Using incompatible plugins for the annotation processing: android-apt. This may result in an unexpected behavior. 这是因为 android-apt 的作者已经不再维护它了，解决方案是使用官方的处理器来代替他，即可去除警告信息。 1234567// 删除依赖路径classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'// 删除插件引用apply plugin: 'com.neenbedankt.android-apt'// 将 android-apt 替换为 annotationProcessor annotationProcessor rootProject.ext.support.butterknife840_processor layout 文件结构开启的过程还挺麻烦，查到的文章里都只提到了设置 build.gradle 文件，遇到的问题耽误了不少时间。 使用 DataBinding 时，主要是将数据直接绑定到视图中，对我们来说就是 layout.xml 文件了，样式有所更改，最外层需要使用新的 &lt;layout&gt; 标签，&lt;layout&gt; 标签中分为了 数据(Model) 和 视图(View) 两部分，View 部分自然还是原来的布局文件，在后面的描述中，我都会称他们为 xml 的 Model 部分和 View 部分。 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;!--数据部分--&gt; &lt;data&gt; &lt;import alias="User" type="com.march.commonlib.activity.DataBindingActivity.User"/&gt; &lt;variable name="name" type="String"/&gt; &lt;variable name="user" type="User"/&gt; &lt;/data&gt; &lt;!--原来的布局文件--&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:text="@&#123;name&#125;" android:textColor="@color/black" android:textSize="18sp"/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; DataBindingUtil在使用 DataBinding 时，我们需要一个 ViewDataBinding 对象，他是连接数据和视图的桥梁，DataBindingUtil 作为一个工具类，提供了创建 ViewDataBinding 的静态方法。 setContentView() 方法，用来替代 Activity 的 setContentView()，可以在设置视图的同时返回 ViewDataBinding 对象。 123public static &lt;T extends ViewDataBinding&gt; T setContentView(Activity activity, int layoutId) &#123; return setContentView(activity, layoutId, sDefaultComponent);&#125; inflate() 方法，用来代替 LayoutInflater 的 inflate() 方法，用来在加载一个布局时返回 ViewDataBinding 对象。 1234public static &lt;T extends ViewDataBinding&gt; T inflate(LayoutInflater inflater, int layoutId, @Nullable ViewGroup parent, boolean attachToParent) &#123; return inflate(inflater, layoutId, parent, attachToParent, sDefaultComponent);&#125; 关于 ViewDataBinding 对象，它由插件自动编译生成，类的名字取决于你的 layout.xml 文件的名字，例如布局文件名为 R.layout.activity_databinding 那么生成对应类则为 ActivityDatabindingBinding。 语法部分⬇️ 在 xml 文件中，我们可以在 View 部分使用任何在 Model 部分声明的数据，为此，DataBinding 提供了丰富而简便的语法支持。 由于 AndroidStudio 对 DataBinding 的语法支持的没有那么好，所以很多语法在编译期都是错误的，但是运行之后就可以使用，相信在不久的以后这些支持会更加全面。 Model 部分语法Model 部分被 &lt;data/&gt; 标签包含 声明一个数据，使用 variable 标签，type 声明的是类名，java.lang 包下面的类，可以不用写完整路径，但是其他的类，需要声明完整路径。 1234567&lt;variable name="name" type="String"/&gt; &lt;variable name="user" type="com.march.commonlib.activity.DataBindingActivity.User"/&gt; 导包，使用 import 标签， 然后在声明数据时，可以不用使用完整路径。 12345&lt;import type="com.march.commonlib.activity.DataBindingActivity.User"/&gt;&lt;variable name="user" type="User"/&gt; 别名，使用 import 标签时，可以指定导入类的别名，如果使用了别名，则声明数据时，type 必须指定为别名。 1234567&lt;import alias="Alias_User" type="com.march.commonlib.activity.DataBindingActivity.User"/&gt;&lt;variable name="user" type="Alias_User"/&gt; 当我们声明 List&lt;T&gt; 和 Map&lt;K,V&gt; 等数据类型时，在 xml 中 &lt;&gt; 是不允许使用的， 因为我们要使用转义字符 &amp;lt; 和 &amp;gt; 来表示，不得不说这种写法，可读性很差，而且在编译期是标红的，但是仍然可以运行，绑定成功。 123456789101112131415161718&lt;!--List--&gt;&lt;import type="java.util.List"/&gt;&lt;variable name="list" type="List&amp;lt;User&amp;gt;"/&gt; &lt;!--不导包直接使用也是可以的--&gt;&lt;variable name="list" type="java.util.List&amp;lt;User&amp;gt;"/&gt; &lt;!--Map--&gt;&lt;import type="java.util.Map"/&gt;&lt;variable name="map" type="Map&amp;lt;String,String&amp;gt;"/&gt; 自定义绑定生成的类名，编译生成绑定类的名称是根据 layout.xml 文件的名字来生成的，默认放置在 包名.databinding 包下，但是我们通常不希望使用那种很长很没有意义的类名，甚至希望自定义这个绑定类的具体的包名，使用 &lt;data/&gt; 标签的 class 属性来实现。 12345678&lt;!--指定绑定类的类名，默认放在 应用包名.databinding 包下--&gt;&lt;data class="DiyBinding"&gt;&lt;/data&gt;&lt;!--指定绑定类的类名，并放置在应用包名根目录下--&gt;&lt;data class=".DiyBinding"&gt;&lt;/data&gt;&lt;!--指定绑定类的类名，并指定包名--&gt;&lt;data class="com.example.DiyBinding"&gt;&lt;/data&gt; View 部分表达式语法数据绑定的本质其实是在 View 部分的 xml 中引用 Model 部分声明的数据，这样我们使用时只需要设置数据即可根据在 xml 中绑定的规则自动完成数据的设置，DataBinding 的优势在于它将这一过程使用自动编译生成的类来完成，而我们需要做的只是说明绑定的规则和设置数据即可。 在 xml 中绑定数据时使用 @{expression} 的形式，expression 指的是表达式，表达式中支持丰富的语法。 基本语法一个简单的绑定 123&lt;TextView style="@style/TvStyle" android:text='@&#123;desc&#125;'/&gt; 拼接字符串，在 xml 中可以使用 &quot; &quot; 和 &#39; &#39; 来声明值，如同多数的脚本语言一样，如果字符串中有 &quot; &quot;，那么外面就是用 &#39; &#39;，反之亦然。 123&lt;TextView style="@style/TvStyle" android:text='@&#123;"测试字符串拼接 [ name is " + user.name + "，age is " + user.age + "]"&#125;'/&gt; 同时也支持对特殊字符的转义，比如对 &quot; &quot; 和 &#39; &#39; 的转义，来解决多层引号嵌套的问题，比如我们从 Map 中取值。 1234&lt;TextView style="@style/TvStyle" android:text='@&#123;"map[\"key\"] = "+map["key"]&#125;' /&gt; 使用 default 关键字声明默认值，解决没有绑定数据时的默认显示和 xml 预览显示的问题。 1234&lt;TextView style="@style/TvStyle" android:text='@&#123;"带有默认值 - "+user.name,default="默认值"&#125;' /&gt; 支持 ?? 操作符，表达式 a??b，当 a 为 null 时将返回 b，这个操作符是 Java 不支持的，他用来为值为空时提供默认值显示。 1234&lt;TextView style="@style/TvStyle" android:text='@&#123;"非空判断 - "+user.nullAble??"空值"&#125;' /&gt; 支持简单的表达式计算，下面使用 VU 作为了 View 类的别名。 1234567891011&lt;data&gt; &lt;import alias="VU" type="android.view.View"/&gt;&lt;/data&gt; &lt;TextView style="@style/TvStyle" android:text='表达式计算' android:visibility="@&#123;user.age &gt; 10?VU.VISIBLE:VU.GONE&#125;" /&gt; 使用静态方法 1234567&lt;data&gt; &lt;import type="android.text.TextUtils"/&gt;&lt;/data&gt;&lt;TextView style="@style/TvStyle" android:text='@&#123;TextUtils.isEmpty("")?"empty":"have"&#125;'/&gt; 访问 map 和 list 12345678910111213141516171819202122&lt;data&gt; &lt;!--List--&gt; &lt;import type="java.util.List"/&gt; &lt;variable name="list" type="List&amp;lt;User&amp;gt;"/&gt; &lt;!--map--&gt; &lt;import type="java.util.Map"/&gt; &lt;variable name="map" type="Map&amp;lt;String,String&amp;gt;"/&gt;&lt;/data&gt;&lt;TextView style="@style/TvStyle" android:text='@&#123;"list[0] = " + list[0]&#125;'/&gt; &lt;TextView style="@style/TvStyle" android:text='@&#123;"map[\"key\"] = "+map["key"]&#125;' /&gt; 支持 Java 中大多数的运算符，如 数学计算 +,-,*,/,%，使用 + 进行字符串拼接，逻辑运算 &amp;&amp;，||，位运算 &amp;,|,^，单目运算 +,-,!,~，位移运算 &gt;&gt;,&gt;&gt;&gt;,&lt;&lt;,&lt;&lt;&lt;，比较运算 ==,&gt;,&lt;.&gt;=,&lt;=，instanceOf，三目运算 ?:，类型转换等。 1234567&lt;TextView style="@style/TvStyle" android:text='@&#123;"" instanceof String + ""&#125;'/&gt;&lt;TextView style="@style/TvStyle" android:text='判断并使用不同资源' android:textColor="@&#123;user.age%2==0?@color/black:@color/red&#125;"/&gt; 使用 android 资源使用资源，在表达式中使用 andorid 资源时，稍有不同 Type（类型） Normal Reference（普通引用） Expression Reference（表达式引用） String[] @array @stringArray int[] @array @intArray TypedArray @array @typedArray Animator @animator @animator StateListAnimator @animator @stateListAnimator color int @color @color ColorStateList @color @colorStateList 1234&lt;TextView style="@style/TvStyle" android:text='判断并使用不同资源' android:textColor="@&#123;user.age%2==0?@color/black:@color/red&#125;"/&gt; 支持 Includes在 DataBinding 中不支持 merge 节点，但是绑定的数据可以传递到 include 的布局中，在 include 布局文件中也需要声明数据 12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout&gt; &lt;data&gt; &lt;variable name="user" type="com.march.commonlib.activity.DataBindingActivity.User"/&gt; &lt;/data&gt; &lt;TextView xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="50dp" android:orientation="vertical" android:text="@&#123;user.name&#125;"/&gt;&lt;/layout&gt; 我们需要在宿主文件中将数据传递进去 1&lt;include layout="@layout/tv" app:user="@&#123;user&#125;"/&gt; 绑定方法和监听方法绑定，Method Reference，为控件绑定点击和长按事件，首先我们要先定义这些事件的处理方法，需要注意的是，方法的参数和返回值需要与 View 的事件匹配。 1234567891011public static class EventHandler &#123; public void clickView(View view) &#123; ToastUtils.show("click view"); &#125; public boolean longClickView(View view) &#123; ToastUtils.show("long click view"); return true; &#125;&#125; 在 xml 中进行方法的绑定，使用 xxx::methodName 的形式，通常在 xml 中是没有 onLongClick 属性的，但是在 DataBinding 环境下支持，虽然没有高亮显示，点击之后也不能跳转到指定的方法，但是编译可以通过，运行绑定也没有问题。 12345678910111213&lt;data&gt; &lt;variable name="handler" type="com.march.commonlib.activity.DataBindingActivity.EventHandler"/&gt;&lt;/data&gt;&lt;Button android:id="@+id/myBtn" android:layout_width="wrap_content" android:layout_height="wrap_content" android:onClick="@&#123;handler::clickView&#125;" android:onLongClick="@&#123;handler::longClickView&#125;" android:text="方法绑定"/&gt; 监听绑定，Listener Reference，在控件的被点击后，回调监听，这个和上面方法的绑定有些区别，上面的直接设置控件的事件，现在是控件被点击后回调绑定的方法。 1234567891011121314public static class EventHandler &#123; public void func1() &#123; ToastUtils.show("func1"); &#125; public void func2(View view, String name) &#123; ToastUtils.show("func2 " + name + " " + ((Button) view).getText()); &#125; public void func3(View view, Context context, String name) &#123; ToastUtils.show("func2 " + name + " " + ((Button) view).getText() + " " + context.getClass().getSimpleName()); &#125;&#125; 在 xml 中绑定监听，使用 Lambda 表达式的形式 1234567891011121314151617&lt;data&gt; &lt;variable name="handler" type="com.march.commonlib.activity.DataBindingActivity.EventHandler"/&gt;&lt;/data&gt;&lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:onClick="@&#123;()-&gt;handler.func1()&#125;" android:text="监听绑定1"/&gt;&lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:onClick="@&#123;(view)-&gt;handler.func2(view,user.name)&#125;" android:text="监听绑定2" /&gt; 绑定数据获取到 ViewDataBinding 类之后就可以进行数据的设置和绑定，使用编译生成的 ViewDataBinding 的子类，会对绑定的数据自动生成 getter/setter 方法， 直接调用即可。 绑定对象时，所有的属性都必须是 public 或者具有 public 的 getter/setter 方法。 另外 DataBinding 会将所有带有 id 的控件获取到，并转换为驼峰命名法，可以直接使用，不需要再进行 findViewById()。 1234567891011121314151617DiyBinding binding = getBinding();// 字符串binding.setDesc("简单使用");// 对象binding.setUser(new User("chendong", 9));// 方法和监听binding.setHandler(new EventHandler());// listList&lt;User&gt; list = new ArrayList&lt;&gt;();list.add(new User("test", 10));binding.setList(list);// mapMap&lt;String, String&gt; map = new HashMap&lt;&gt;();map.put("key", "value");binding.setMap(map);// 获取控件Button myBtn = binding.myBtn; 观察者对象当数据发生变动时，我们希望 UI 作同步的更改。 BaseObservable使对象类继承 BaseObservable 类，在对应属性声明处或者 getter/setter 方法处使用 @Bindable 注解，此时，当属性值发生改变时，调用 notifyPropertyChanged(BR.xxx) 即可同步 UI 更改。 12345678910111213141516171819202122public static class User extends BaseObservable&#123; @Bindable private String name; @Bindable public int age; public String nullAble; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; notifyPropertyChanged(BR.name); &#125; public User(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125; 在点击事件中更改数据，由于 age 属性没添加 setter 方法，我们可以在外面调用更新方法。 123456789public void clickView(View view) &#123; mUser.setName("newName");&#125;public boolean longClickView(View view) &#123; mUser.age = 1000; mUser.notifyPropertyChanged(BR.age); return true;&#125; 弊端也很明显，我们需要所有的对象都是继承 BaseObservable，需要手动添加注解，需要手动去调用数据更新的通知，使用 ObservableField 可以更方便的完成这个过程。 ObservableField定义对象类，并将每个属性都定义为 ObservableField 类型，则在属性状态发生更改时，视图会做对应更新； ObservableField 是一个使用范型来包装其他数据类型的类，这样看来我们如果需要一个 int 类型属性时，便不得不使用 ObservableField&lt;Integer&gt;，不过 DataBinding 已经为基本数据类型提供了专门的包装，如 ObservableInt 类型，其他基本数据类型也有对应包装。 使用这种方式更新数据时确实简化了很多操作，不过所有的属性都变成了 ObservableField 类型，当我们进行数据交互，json 转化等操作时，就变得不方便了，暂时不知道是如何解决这个问题。 1234public static class ObUser &#123; public ObservableField&lt;String&gt; name = new ObservableField&lt;&gt;(); public ObservableInt age = new ObservableInt();&#125; 创建 ObUser 类型的数据并将它绑定到视图中 1234ObUser obUser = new ObUser();obUser.name.set("chendong");obUser.age.set(12);binding.setObuser(obUser); 当我们更改数据的值时，会自动调用 notifyChange(); 方法，通知所有数据更新. 123public void clickView(View view) &#123; mObUser.name.set("newName");&#125; ObservableCollections使用 ObservableArrayList 和 ObservableArrayMap 创建客观察的 List 和 Map。 在 xml 引用数据 1234567891011121314151617&lt;data&gt; &lt;import type="android.databinding.ObservableArrayList"/&gt; &lt;import type="android.databinding.ObservableArrayMap"/&gt; &lt;variable name="obArrayList" type="ObservableArrayList&amp;lt;String&amp;gt;"/&gt; &lt;variable name="obArrayMap" type="ObservableArrayMap&amp;lt;String,String&amp;gt;"/&gt;&lt;/data&gt;&lt;TextView style="@style/TvStyle" android:text='@&#123;obArrayList[0]&#125;'/&gt;&lt;TextView style="@style/TvStyle" android:text='@&#123;obArrayMap.get("myKey")&#125;'/&gt; 创建数据并进行绑定 12345678ObservableArrayList&lt;String&gt; obArrayList = new ObservableArrayList&lt;&gt;();obArrayList.add("item");ObservableArrayMap&lt;String, String&gt; obArrayMap = new ObservableArrayMap&lt;&gt;();obArrayMap.put("myKey", "myValue");binding.setObArrayList(obArrayList);binding.setObArrayMap(obArrayMap); 当更改对应数据时，视图会得到同步更新 12mObArrayList.add(0, "newItem");mObArrayMap.put("myKey", "myNewValue"); 列表中进行数据绑定使用 DataBinding 可以大大简化列表的使用，再也不需要拿出来所有的控件挨个设置，此时需要使用 DataBindingUtil.inflate() 方法获取 Binding 对象。 定义 ViewHolder 类，持有 Binding 对象。 1234567private class BindHolder extends RecyclerView.ViewHolder &#123; private ItemBindBinding mItemBindBinding; public BindHolder(ItemBindBinding itemBindBinding) &#123; super(itemBindBinding.getRoot()); mItemBindBinding = itemBindBinding; &#125;&#125; 定义 Adapter 12345678910111213141516private class BindAdapter extends RecyclerView.Adapter&lt;BindHolder&gt; &#123; ... @Override public BindHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; ItemBindBinding itemBindBinding = DataBindingUtil.inflate(LayoutInflater.from(mContext), R.layout.item_bind, parent, false); return new BindHolder(itemBindBinding); &#125; @Override public void onBindViewHolder(BindHolder holder, int position) &#123; holder.mItemBindBinding.setUser(mUserList.get(position)); &#125; ...&#125; 任意属性的 setter在 xml 使用 DataBinding 语法进行数据绑定时，会自动查找对应的 setter，这一过程和命名空间没有关系，也就是说 app:text=&quot;xx&quot; 和 android:text=&quot;xx&quot; 是一样的，他们都会去查找这个控件中的 setText(String text) 方法调用，由于这一点的支持，我们可以使用很多 xml 文件中原先不支持的属性。 比如我们可以如下的语法，设置文字和长按监听事件 1234567&lt;TextView xmlns:app="http://schemas.android.com/apk/res-auto" android:id="@+id/tv" style="@style/TvStyle" android:layout_height="50dp" app:onLongClickListener="@&#123;handler::longClickView&#125;" app:text='@&#123;user.name + " " + user.age&#125;'/&gt; 简化自定义属性通常我们自定义控件时，需要写 declare-styleable，这样我们才能在 xml 使用自定义的属性，同时还要在自定义控件来获取这些属性，整个过程很繁琐，使用 DataBinding 自定义属性就变得很简单了，直接写一个 setXXX() 的方法即可，不过缺点就是代码高亮等都不支持了。 定义一个 TextView，它有 setFormatText(String text) 和 setMySize(int size) 方法，这两个方法没什么意义，只是用来测试。 123456789101112131415161718192021222324252627public class MyTv extends android.support.v7.widget.AppCompatTextView &#123; public MyTv(Context context) &#123; super(context); &#125; public MyTv(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public MyTv(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; public void setFormatText(String text) &#123; setText(String.format(Locale.CHINA, "FormatText = %s", text)); &#125; public void setMySize(final int mySize) &#123; setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; ToastUtils.show("设置的size= " + mySize); &#125; &#125;); &#125;&#125; 在 xml 中就可以像普通属性一样使用这两个 setter 方法对应的属性。 123456&lt;com.march.commonlib.widget.MyTv android:id="@+id/tv" style="@style/TvStyle" android:layout_height="50dp" app:formatText="@&#123;user.name&#125;" app:mySize="@&#123;user.age&#125;"/&gt; BindingMethods不是所有的方法都能刚好是 setter 方法的格式，又或者把一个 setter 方法转换成 xml 属性变得很长很难看，DataBinding 提供了将 setter 方法和 xml 属性映射的方法，使用注解 BindingMethods 实现。 还是在自定义控件中，添加方法 testBindingMethod() 方法，这不是一个标准的 setter 方法，自然无法映射到对应的 xml 属性，为了能在 xml 中使用，需要使用 BindingMethods 注解，BindingMethods 是注解在类上的。 下面的代码意味着，对于 TextView 的 my_bind_method 属性会对应调用 testBindingMethod() 方法。 1234567891011121314151617@BindingMethods( @BindingMethod(type = TextView.class, attribute = "my_bind_method", method = "testBindingMethod"))public class MyTv extends android.support.v7.widget.AppCompatTextView &#123; public void testBindingMethod(final String text) &#123; setOnLongClickListener(new OnLongClickListener() &#123; @Override public boolean onLongClick(View v) &#123; ToastUtils.show("setTestBindingMethod = " + text); return true; &#125; &#125;); &#125;&#125; BindingAdapter有时我们需要给已经存在的控件设置新的 xml 属性， 甚至更改原来属性的运作方式，此时需要使用 @BindingAdapter 注解，这个注解的作用是将属性和方法绑定到一起，当在对应控件中使用对应属性时，会调用该方法。 方法是静态的，如果是 android 原先的属性，则需要添加 android:xxx 命名空间，其他不需要，可以直接写属性名即可，参数大致分为以下几种类型： 注解为一个属性时，第一个参数是对应控件，如果另外只有一个参数，第二个参数为值； 注解为一个属性时，第一个参数是对应控件，如果另外有两个参数，则第二个参数为原来的值，第三个参数为新值； 注解为多个属性时，第一个参数是对应控件，后面的参数分别为不同属性的值，多个属性时意味着必须当这个控件同时声明了注解中所有的注解属性才会绑定到该方法； 我们可以更改已存在属性的运作方式，如下，当对 TextView 使用 android:text 属性时，会调用该方法。 123456public class AttrAdapter &#123; @BindingAdapter("android:text") public static void test1(TextView tv, String text) &#123; tv.setText(String.format(Locale.CHINA, "test1 - %s", text)); &#125;&#125; 定义一个新的属性 1234@BindingAdapter("myTest2")public static void test2(TextView tv, String text) &#123; tv.setText(String.format(Locale.CHINA, "test2 - %s", text));&#125; 同时绑定两个属性，只有当该控件同时声明这两个属性时才会绑定到该方法 123456789@BindingAdapter(&#123;"android:text", "myTest3"&#125;)public static void test3(TextView tv, String text, String text2) &#123; tv.setText(String.format(Locale.CHINA, "test3 - %s - %s", text, text2));&#125;@BindingAdapter(&#123;"myTest2", "myTest3"&#125;)public static void test4(TextView tv, String text, String text2) &#123; tv.setText(String.format(Locale.CHINA, "test4 - %s - %s", text, text2));&#125; 当一个属性，三个参数时，可以获得该属性的旧值和新值。 1234@BindingAdapter("myTest4")public static void test5(TextView tv, String oldText, String newText) &#123; tv.setText(String.format(Locale.CHINA, "test5 - %s - %s", oldText, newText));&#125; 这些方法都声明在类 AttrAdapter 里面，如果要在 xml 中使用，需要导入该类。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto"&gt; &lt;data&gt; &lt;variable name="user" type="com.march.commonlib.activity.DataBindingActivity.User"/&gt; &lt;import type="com.march.commonlib.activity.DataBindingActivity.AttrAdapter"/&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical"&gt; &lt;TextView style="@style/TvStyle" android:text="@&#123;user.name&#125;"/&gt; &lt;TextView style="@style/TvStyle" app:myTest2="@&#123;user.name&#125;"/&gt; &lt;TextView style="@style/TvStyle" android:text="@&#123;user.name&#125;" app:myTest3="@&#123;user.name&#125;"/&gt; &lt;TextView style="@style/TvStyle" app:myTest2="@&#123;user.name&#125;" app:myTest3="@&#123;user.name&#125;"/&gt; &lt;TextView style="@style/TvStyle" app:myTest4="@&#123;user.name&#125;"/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>DataBinding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin开发-16-反射]]></title>
    <url>%2Farticle%2F2650e1c8%2F</url>
    <content type="text"><![CDATA[本文介绍 Kotlin 反射的用法。 在 Java 中也有反射的相关用法，不过因为运行时反射效率差，而且 java 中的反射使用起来相对麻烦，在实际开发中反射的使用还是很少的。不过在 Kotlin 中的反射使用起来十分简单。 反射，我们平常访问对象的属性和函数，是针对对象来说的，总是访问他们的 “值”，比如一个属性的具体值，或者执行某个函数，都是使用对象来调用，这都是访问 “值” 的操作，而反射，是针对类来说的，也就是不必有类实体，而是访问类的属性和函数本身，不再在乎值到底是什么，而是真正的把这个属性或函数拿出来，当我们想要这个属性的值或函数的执行结果，我们就需要用拿到的属性和函数本身去调用一个对象，这个过程就反过来了，不是对象调用属性和函数，而是属性和函数本身调用对象。 在 Kotlin 中使用反射需要借助 :: 操作符。 Class Reference获取某个类的引用 1234// 获取 kotlin classvar kClass = ReflectTest::class// 获取 java classvar clazz = ReflectTest::class.java 从 KClass 类型的变量中可以获取类的的属性 12345678kClass.constructorskClass.isAbstractkClass.isDatakClass.isFinalkClass.isCompanionkClass.isInnerkClass.isOpen... Function Reference反射获取函数引用，非类成员函数时可以直接使用 ::funcName 的形式获取函数， 123456789101112131415161718192021// top level 级别函数fun funcInTopLevel(str: String) = str.lengthclass ReflectFunTest() &#123; // 成员函数 fun funcInClass(str: String) = str.length fun test() &#123; // 局部函数 fun funcInLocal(str: String) = str.length // ok val f1: (String) -&gt; Int = ::funcInTopLevel // error val f2: (String) -&gt; Int = ::funcInClass // ok，局部函数 val f3: (String) -&gt; Int = ::funcInLocal &#125;&#125; 对于类成员函数反射返回的结果其实是 类名.(参数)-&gt;返回值 类型的函数，因此上面是编译错误的。 1234567val f4: ReflectFunTest.(String) -&gt; Int = ReflectFunTest::funcInClass``` 也可以获取 `String` 类的成员函数```javaval f3: String.() -&gt; CharArray = String::toCharArrayval f4: String.(Int, Int) -&gt; CharSequence = String::subSequence 执行函数，对于非类成员函数可以直接执行，而对于类成员函数则需要依赖类的实例来执行。 12345val f1: (String) -&gt; Int = ::funcInTopLevelval f4: ReflectFunTest.(String) -&gt; Int = ReflectFunTest::funcInClassf1.invoke("test")f4.invoke(ReflectFunTest(), "test") Property Reference反射获取属性引用，支持类属性和扩展属性。 1234567891011121314151617181920212223242526272829303132// 扩展属性val ReflectPropertyTest.extensionProperty: Int get() = 200class ReflectPropertyTest &#123; // 成员属性 var myProperty = 10 fun test() &#123; val model = ReflectPropertyTest() // 反射属性 val kPropertyForMyProperty = ReflectPropertyTest::myProperty // 从 model 中取出该属性的值 var myPropertyValue = kPropertyForMyProperty.get(model) // 向 model 中设置该属性的值 kPropertyForMyProperty.set(model, 100) // 反射扩展属性 val kPropertyForExtensionProperty = ReflectPropertyTest::extensionProperty // 从 model 中取出该属性的值 var extensionPropertyValue = kPropertyForExtensionProperty.get(model) // 反射其他类属性 val lengthProperty = String::length lengthProperty.get("test") &#125;&#125; Constructor Reference反射获取构造器引用 123456789101112131415161718192021222324class ReflectConstructorTest() &#123; constructor(age: Int) : this() constructor(age: Int, name: String) : this(age) fun test() &#123; testConstructor1(::ReflectConstructorTest) testConstructor2(::ReflectConstructorTest) testConstructor3(::ReflectConstructorTest) &#125; fun testConstructor1(factory: () -&gt; ReflectConstructorTest): ReflectConstructorTest &#123; return factory.invoke() &#125; fun testConstructor2(factory: (Int) -&gt; ReflectConstructorTest): ReflectConstructorTest &#123; return factory.invoke(12) &#125; fun testConstructor3(factory: (Int, String) -&gt; ReflectConstructorTest): ReflectConstructorTest &#123; return factory.invoke(12, "chen") &#125;&#125;]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin开发-15-操作符重载]]></title>
    <url>%2Farticle%2F75caba4c%2F</url>
    <content type="text"><![CDATA[在 Kotlin 中允许对操作符进行重载，并提供了简单友好的方式来支持这个特性，这样的好处就是我们可以对一些原本不支持操作符的类型使用操作符，简化代码，举个例子，Kotlin 中的集合类型是支持操作符的，而 Java 中不支持，对比一下使用和不使用操作符对集合增减元素的操作。 1234567891011// 使用操作符val a = list + "1"val b = list + destListval c = list - "2"val d = list - destList// 不使用操作符val e = list.add("1")val f = list.addAll(destList)val g = list.remove("2")val h = list.removeAll(destList) 操作符重载的基本原理就是每种操作符都有其对应的函数名，这是一一对应的，当对某个类型的对象使用操作符时，编译器便会查找该类型下，是否存在该名称的函数，并使用 operator 关键字标记，可以是成员函数也可以是扩展函数，如果有的话，匹配相应的参数，调用该函数。 操作符函数一览表 操作符 函数 描述 +a unaryPlus() -a unaryMinus() !a not() a++/++a inc() a- -/- -a dec() a+b plus(b) a-b minus(b) a*b times(b) a/b div(b) a%b rem(b) a+=b plusAssign(b) 不能有返回值 a-=b minusAssign(b) 不能有返回值 a*=b timesAssign(b) 不能有返回值 a/=b divAssign(b) 不能有返回值 a%=b remAssign(b) 不能有返回值 a[i][j] get(i,j) a[i][j=b] set(i,j,b) 至少有一个参数为b a(p) invoke(p) a..b rangeTo(b) b in a contains(b) a==b equals(b) a&gt;b compareTo(b) 一元操作符主要包括 +a,-a,!a,a++,a--,++a,--a 等一元操作符运算。 1234567891011121314151617181920212223242526272829303132333435363738class MyData(var myName: String, var myAge: Int):Comparable&lt;MyData&gt; &#123; var desc = "" override fun toString(): String &#123; return "name $myName,age $myAge $desc" &#125; // +a operator fun unaryPlus(): MyData &#123; desc = "执行了 +a " return this &#125; // -a operator fun unaryMinus(): MyData &#123; desc = "执行了 -a " return this &#125; // !a operator fun not(): MyData &#123; desc = "执行了 !a " return this &#125; // a++/++a operator fun inc(): MyData &#123; desc = "执行了 a++" return this &#125; // a--/--a operator fun dec(): MyData &#123; desc = "执行了 a--" return this &#125;&#125; 调用 12345678var data = MyData("chendong", 11)log((+data).toString())log((-data).toString())log((!data).toString())log((data++).toString())log((data--).toString())log((++data).toString())log((--data).toString()) 四则运算与模运算这类运算符使得任何类型的对象都可以进行 + - * / % 的运算，当然这些运算的具体实现细节是由我们自己实现的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class MyData(var myName: String, var myAge: Int):Comparable&lt;MyData&gt; &#123; var desc = "" override fun toString(): String &#123; return "name $myName,age $myAge $desc" &#125; // 二元操作符 // a + b operator fun plus(p: MyData): MyData &#123; desc = "执行了 a+b" myAge += p.myAge return this &#125; // a - b operator fun minus(p: MyData): MyData &#123; desc = "执行了 a-b" myAge -= p.myAge return this &#125; // a * b operator fun times(p: MyData): MyData &#123; desc = "执行了 a*b" myAge *= p.myAge return this &#125; // a / b operator fun div(p: MyData): MyData &#123; desc = "执行了 a/b" myAge /= p.myAge return this &#125; // a % b operator fun rem(p: MyData): MyData &#123; desc = "执行了 a%b" myAge %= p.myAge return this &#125; // a += b operator fun plusAssign(p: String) &#123; desc = "执行了 a+=b" &#125; // a -= b operator fun minusAssign(p: String) &#123; desc = "执行了 a-=b" &#125; // a *= b operator fun timesAssign(p: String) &#123; desc = "执行了 a*b" &#125; // a /= b operator fun divAssign(p: String) &#123; desc = "执行了 a/=b" &#125; // a %= b operator fun remAssign(p: String) &#123; desc = "执行了 a%b" &#125;&#125; 调用 1234567891011121314151617var data = MyData("chendong", 11)var data2 = MyData("new", 10)log((data + data2).toString())log((data - data2).toString())log((data * data2).toString())log((data / data2).toString())log((data % data2).toString())data += "test"log(data.toString())data -= "test"log(data.toString())data *= "test"log(data.toString())data /= "test"log(data.toString())data %= "test"log(data.toString()) 下标访问这类匀速符使对象可以如同数组一样使用 a[i][j].. 的形式访问。 1234567891011121314151617181920212223242526272829303132class MyData(var myName: String, var myAge: Int):Comparable&lt;MyData&gt; &#123; var desc = "" override fun toString(): String &#123; return "name $myName,age $myAge $desc" &#125; // a[i] operator fun get(i: Int): MyData &#123; desc = "执行了 a[$i]" return this &#125; // a[i][j] operator fun get(i: Int, j: Int): MyData &#123; desc = "执行了 a[$i][$j]" return this &#125; // a[i] = "test" operator fun set(i: Int, value: String): MyData &#123; desc = "执行了 a[$i]= $value" return this &#125; // a[i][j] = "test" operator fun set(i: Int, j: Int, value: String): MyData &#123; desc = "执行了 a[$i][$j]= $value" return this &#125;&#125; 调用 1234567var data = MyData("chendong", 11)log(data[0])log(data[1][2])data[0] = "test"log(data.toString())data[1][2] = "test"log(data.toString()) 函数调用这个操作符使得我们可以像函数一样直接使用对象后面添加括号，如 a() 来调用这个对象的 invike() 函数。 123456789101112131415161718192021class MyData(var myName: String, var myAge: Int):Comparable&lt;MyData&gt; &#123; var desc = "" override fun toString(): String &#123; return "name $myName,age $myAge $desc" &#125; // a() operator fun invoke(): MyData &#123; desc = "执行了 a()" return this &#125; // a("test") operator fun invoke(p: String): MyData &#123; desc = "执行了 a(\'$p\')" return this &#125;&#125; 调用 12345var data = MyData("chendong", 11)var data2 = MyData("new", 10)log(data().toString())log(data("test").toString()) 其他操作符使用 .. 操作符 12345// a .. boperator fun rangeTo(p: MyData): MyData &#123; desc = "执行了 a..b" return this&#125; 使用 in 操作符 12345// b in aoperator fun contains(p: MyData): Boolean &#123; desc = "执行了 b in a" return true&#125; 使用 == 操作符 1234override fun equals(other: Any?): Boolean &#123; desc = "执行了 ==" return super.equals(other)&#125; 使用 &lt;,&gt;,&lt;=,&gt;= 操作符 1234override fun compareTo(other: MyData): Int &#123; desc = "执行了 比较操作 " return 0&#125; 调用 1234567891011121314var data = MyData("chendong", 11)var data2 = MyData("new", 10) data == data2log(data.toString())data &gt; data2log(data.toString())log((data..data2).toString())if (data.contains(data2)) &#123; log(data.toString())&#125;]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thinker 热修复]]></title>
    <url>%2Farticle%2F9852c6f8%2F</url>
    <content type="text"><![CDATA[Tinker 是微信官方的 Android 热补丁解决方案，它支持动态下发代码、So 库以及资源，让应用能够在不需要重新安装的情况下实现更新。当然，你也可以使用 Tinker 来更新你的插件。 Thinker GitHub Thinker 文档 简书 热修复框架 Tinker]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AndroidTips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Walle 多渠道打包]]></title>
    <url>%2Farticle%2F317ee1ad%2F</url>
    <content type="text"><![CDATA[Walle 是 APK Signature Scheme v2 下新的多渠道打包方案，速度快，也支持 360 加固，下面是本文相关链接。 Android Signature V2 Scheme 介绍 美团 Walle 多渠道打包 原理介绍 项目地址 Meituan-Dianping/Walle 与 360 加固配合使用 GitHub Python脚本 多渠道打包+360加固 Walle 命令行使用 使用 Walle参考 GitHub-Walle 进行配置，下面是项目最基本的配置，更多的使用方法参照 Meituan-Dianping/Walle README 123456789101112131415161718192021222324252627282930313233343536373839404142buildscript &#123; repositories &#123; jcenter() mavenCentral() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.3.2' // walle 多渠道打包 classpath 'com.meituan.android.walle:plugin:1.1.5' &#125;&#125;// walle 多渠道打包apply plugin: 'walle'android&#123;...&#125;dependencies &#123; // compile 'com.meituan.android.walle:library:1.1.5'&#125;walle &#123; // 指定渠道包的输出路径 apkOutputFolder = new File("$&#123;project.buildDir&#125;/outputs/channels"); // 定制渠道包的APK的文件名称，支持如下属性 // projectName - 项目名字 // appName - App模块名字 // packageName - applicationId (App包名packageName) // buildType - buildType (release/debug等) // channel - channel名称 (对应渠道打包中的渠道名字) // versionName - versionName (显示用的版本号) // versionCode - versionCode (内部版本号) // buildTime - buildTime (编译构建日期时间) // fileSHA1 - fileSHA1 (最终APK文件的SHA1哈希值) // flavorName - 编译构建 productFlavors 名 apkFileNameFormat = '$&#123;appName&#125;-$&#123;packageName&#125;-$&#123;channel&#125;-$&#123;buildType&#125;-v$&#123;versionName&#125;-$&#123;versionCode&#125;-$&#123;buildTime&#125;.apk'; // 渠道配置文件 channelFile = new File("$&#123;project.getProjectDir()&#125;/channel")&#125; 生成渠道包 123./gradlew clean assembleReleaseChannels// 支持 productFlavors ./gradlew clean assembleMeituanReleaseChannels 360 加固 + 多渠道打包使用 360 加固网页版 上传 apk，加固完成后下载没有签名的 apk。 对齐优化对下载的 apk 使用 apkalign 工具进行对齐优化，zipalign 工具位于 Android SDK/build-tools/25.x.x 下。 1234zipalign -v 4 [源apk地址] [目标apk地址]eg:zipalign -v 4 /Users/march/Downloads/walle/app-release.encrypted.align.apk 对齐完成后，对 apk 进行检测是否对齐成功。 1234zipalign -c -v 4 [目标apk地址]eg:zipalign -c -v 4 /Users/march/Downloads/walle/app-release.encrypted.align.apk 二次签名对齐成功后，使用 apksigner 工具对 apk 进行签名，apksigner 也位于 Android SDK/build-tools/25.x.x 下，但是版本需要在 25.x.x 以上，才能支持 v2 签名。 1234apksigner sign --ks [密钥地址] [apk 地址]eg:apksigner sign --ks /Users/march/AndroidPro/DevKitSample/app/march.keystore /Users/march/Downloads/walle/app-release.encrypted.align.apk 渠道写入签名完成后，检测是否签名成功和是否是 v2 签名，检查需要使用 CheckAndroidV2Signature.jar 文件，下载地址 1234java -jar CheckAndroidV2Signature.jar [apk 地址]eg:java -jar /Users/march/Downloads/CheckAndroidV2Signature.jar /Users/march/Downloads/walle/app-release.encrypted.align.apk 将会返回类似下面的结果 1&#123;&quot;ret&quot;:0,&quot;msg&quot;:&quot;ok&quot;,&quot;isV2&quot;:true,&quot;isV2OK&quot;:true&#125; 使用 Walle 写入渠道信息，需要借助 walle-cli-all.jar 来执行，下载地址 这一块更多的可以参照 Walle 命令行使用 1234java -jar walle-cli-all.jar put -c [渠道名称] [源 apk 地址] [目标 apk 地址]eg:java -jar /Users/march/Downloads/walle-cli-all.jar put -c meituan /Users/march/Downloads/walle/app-release.encrypted.align.apk /Users/march/Downloads/walle/app-release.encrypted.align.meituan.apk 同样也支持多渠道同时打包 1234java -jar walle-cli-all.jar batch -f [channel文件] [签名后的apk路径] [生成渠道app的文件夹路径]eg:java -jar /Users/march/Downloads/walle-cli-all.jar batch -f /Users/march/AndroidPro/DevKitSample/app/channel /Users/march/Downloads/walle/app-release.encrypted.align.apk /Users/march/Downloads/walle/channel 最后检查渠道是否写入成功 1234java -jar walle-cli-all.jar show [apk路径]eg:java -jar /Users/march/Downloads/walle-cli-all.jar show /Users/march/Downloads/walle/app-release.encrypted.align.meituan.apk]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AndroidTips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 命令]]></title>
    <url>%2Farticle%2Fb51d9f8e%2F</url>
    <content type="text"><![CDATA[Git 日常命令收集，对平常使用的 git 命令及版本管理中遇到的问题进行梳理。 文中 { } 包含的部分表示变量参数，如 {git-url} 指的是远程 git 地址，[ ] 包含的部分指的是这部分命令是可以省略的。 撤销操作在 git add 之前，文件未进入暂存区时，（撤销工作区修改） 1$ git checkout -- filename.txt 在 git commit 之前，文件未到达远端时，（撤销暂存区修改） 1234# 将文件放回工作区$ git reset HEAD filename.txt# 撤销工作区修改$ git checkout -- filename.txt git config 用户配置查看及更改1234567# 查看git config user.namegit config email# 配置git config --global user.name = 'test'git config --global user.email = 'test@qq.com' git init123456git initgit remote add origin git@github.com:chendongMarch/xxxx.gitgit add fileNamegit add -Agit commit -m "first commit"git push -u origin master git clone1234git clone [-b &#123;branch-name&#125;] &#123;git-url&#125; [&#123;dest-dir&#125;] [--depth 1]# 只 clone 最近一次 commit，防止提交太多 clone 很慢git clone &#123;git-url&#125; --depth 1 git remote 查看和更改远程123456789101112# 查看远程仓库名git remote -v# 添加 origin 仓库# git remote add 命令是为了在添加之后可以使用远程仓库名称来进行访问，而不是使用 git url 的形式，它更像一个注册表git remote add origin &#123;git-url&#125;# 删除 orgin 仓库git remote rm origin# 重置 orign 指向的仓库git remote set-url origin &#123;git-url&#125; git branch 分支12345678# 删除分支git branch -d &#123;branch-name&#125;# 新建分支git branch &#123;branch-name&#125;# 切换分支git checkout &#123;branch-name&#125; git tag 标签1234567891011121314151617181920212223# 显示所有 tag$ git tag# 过滤显示 tag$ git tag -l '2.*'# 打一个 tag$ git tag v1.0.0# 在某个 commit 打一个 tag$ git tag v1.0.0 [commitId]# 显示某个 tag 的信息$ git show v1.0.0# 删除标签$ git tag -d v1.0.0# 提交所有 tag$ git push origin –-tags# 提交指定 tag$ git push origin v1.0.0 git stash 暂存暂存已经 add 的修改，可以选择在其他合适的时机，将暂存提取应用到当前分支 123456789git add -A # 首先应该执行 add 命令，才能执行 stashgit stash # 暂存当前的修改git stash list # 查看已经存在的暂存 # 展示结果如下# stash@&#123;1&#125;: WIP on master: 8d983f6 ...git stash apply stash@\&#123;0\&#125; # 应用暂存 git log 查看日志123git reflog # 查看命令历史git log test.file # 查看单个文件的日志 git reset 重置12345git reset --hard HEAD^ # 重置到上一次提交git reset --hard HEAD~10 # 重置到之前的10次提交git reset --hard &#123;commitId&#125; # 重置到这次 commit git rm删除远程文件夹 123git rm -r --cached &#123;dirname&#125;git commit -m &#123;msg&#125;git push origin master 更改 .gitignore 后无法生效的问题，原因是 .gitignore 只能忽略那些原来没有被 track 的文件，如果某些文件已经被纳入了版本管理中，则修改 .gitignore 是无效的。那么解决方法就是先把本地缓存删除，改变成未 track 状态，然后再提交 123git rm -r --cached .git add .git commit -m 'update .gitignore' git gc 仓库清理12git gcgit gc --aggressive git subtree 子模块管理使用 git subtree 命令适合管理那些迭代较为频繁的子模块，效果就是开发过程中协作中的其他人可以完全透明的跟原来一样进行提交和拉取，在这部分协作者看来子模块并没有自己的 git 管理，而只有子模块的管理者会定期将子模块的修改同步到子模块的仓库中。 在命令开始之前，我们假设我们在一个 git 项目中，我们称之为主项目，现在要添加一个公用的子模块，它既要加入到当前项目的 git 仓库中，又能独立更新自己所在的远程仓库。 123456789101112131415161718192021222324# 首先添加仓库别名git remote add showjoy-wx-cube git@git.showjoy.net:cardandroid/weex-cube.git# subtree 模式引入子模块git subtree add --prefix=[相对目录名称] [源/上面添加的源] [子模块的分支]git subtree add --prefix=weex-cube showjoy-wx-cube master# 此时模块已经引入，可以和平时一样操作主项目，完全没有影响git add -Agit commit =m 'msg'git push git pull# 子模块管理者想要更新本项目中的子模块git subtree pull --prefix=[相对目录名称] [源/上面添加的源] [子模块的分支]git subtree pull --prefix=weex-cube showjoy-wx-cube master# 子模块管理者想要将本地更新提交到子模块的仓库中git subtree push --prefix=[相对目录名称] [源/上面添加的源] [子模块的分支]git subtree push --prefix=weex-cube showjoy-wx-cube master# 为子模块添加多个源，我不只要更新子模块仓库，我子模块还有多个源，比如一个 github 公开的仓库，一个公司的私有仓库git remote add zfy-wx-cube git@github.com:chendongMarch/weex-cube.gitgit subtree push --prefix=weex-cube zfy-wx-cube master Fix解决 fix fatal: cannot do a partial commit during a merge. 的问题，这个问题是出现在合并代码时出现问题，分支一直处于 merging 状态无法提交的问题。 1git commit -i * -m "message" 解决 Unable to create &#39;.git/index.lock&#39;: File exists 问题，删除 lock 文件 1rm -f ./.git/index.lock]]></content>
      <categories>
        <category>bash</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin开发-14-杂七杂八(解构，类型自动转换，Range，异常)]]></title>
    <url>%2Farticle%2F578c5201%2F</url>
    <content type="text"><![CDATA[汇总一些杂七杂八的点，不值得单独开一篇整理了。 主要内容包括 解构声明 生成数列的 Range 类型转换 异常处理等 解构声明我们创建对象时通常会使用构造函数，他是将一些变量，构造成一个对象，解构就是构造的反操作，解构声明(Destructuring Declaration) 指的是可以将一个对象解构成多个变量。 对象的解构主要依赖于类的 componentN() 函数，函数需要使用 operator 注解标记，这不是一种强制实现，更像是一种约定声明。 之前介绍数据类时说道，数据类中会默认实现 componentN() 函数，因此我们对数据类对象可以直接进行如下操作： 1234data class DataUser(val name: String, val age: Int)// 数据类默认声明 ComponentN 函数val (name, age) = DataUser("chendong", 12) 借助数据类的这种特性，我们可以从函数中返回多个值，其实本质上，还是借助了数据类可以自动解构的特性。 ps:Pair 类也是数据类。 12345678910// 从函数中返回多个值fun returnMultiFunc():DataUser&#123; return DataUser("chendong",12)&#125;fun returnPairFunc():Pair&lt;String,Int&gt;&#123; return Pair("chendong",12)&#125;val (name2,age2) = returnMultiFunc()val (name3,age3) = returnPairFunc() 那么对于我们自己创建的类，他不是数据类，如何进行解构，解决方法还是声明 componentN() 函数。 在 componentN() 函数中返回指定的属性，会自动匹配到解构的接受者中，name1 对应的 component1() 的返回值，age1 对应 component2() 返回值。 123456789101112class MyUser(val name: String, val age: Int) &#123; operator fun component1(): String &#123; return "my name = $name" &#125; operator fun component2(): Int &#123; return age + 10 &#125;&#125;// 接下来就可以直接进行解构val myUser = MyUser("chendong", 12)val (name1, age1) = myUser 借助 Map 类的遍历，看一个解构声明的具体应用。 123for ((key, value) in map) &#123; // 使用 key 和 value 执行某种操作&#125; 要想实现遍历操作，首先需要实现 iterator 1operator fun &lt;K, V&gt; Map&lt;K, V&gt;.iterator(): Iterator&lt;Map.Entry&lt;K, V&gt;&gt; = entrySet().iterator() 返回一个 Map.Entry&lt;K, V&gt; 的集合，此时需要将 Map.Entry 的 key 和 value 进行解构声明。 12operator fun &lt;K, V&gt; Map.Entry&lt;K, V&gt;.component1() = getKey()operator fun &lt;K, V&gt; Map.Entry&lt;K, V&gt;.component2() = getValue() Range 数列可以使用 .. 运算符生成一个数列，对于 Char，Int，Long 类型数列由 CharProgression，IntProgression，LongProgression 实现，而 Float 和 Double 类型由 ClosedFloatingPointRange&lt;T&gt; 实现，因此在支持性上有所不同。 使用简单的 .. 运算符生成 IntRange 对象 使用运算符 a..b 生成的数列的范围是 [a,b] 1val range = 1..10 遍历数列，构造数列时，后面的范围要比前面的大，所以下面 4..1 是不会有任何结果的。 12345678for (i in 1..4) &#123; Log.e(TAG, "test 1..4 i = " + i)&#125;// 不打印结果for (i in 4..1) &#123; Log.e(TAG, "test 4..1 i = " + i)&#125; 使用 .. 并不能构造一个递减数列，此时需要使用 downTo() 函数，构造递减数列。 123for (i in 4 downTo 1) &#123; Log.e(TAG, "test downTo i = " + i)&#125; 使用 step() 函数指定步长，表示在构造数列时的间隔，默认是 1。 1234// 步长for (i in 1..4 step 2) &#123; Log.e(TAG, "test 1..4 step 2 i = " + i)&#125; 输出结果为，每隔两个会获取一个，所以最后一个数将会是 3 ，因为下一个数是 5，不在范围内，类似的 (1..4 step 2).last 的结果也会是 3。 12testRange: test 1..4 step 2 i = 1testRange: test 1..4 step 2 i = 3 使用 until 函数构造一个前闭后开的区间，比如下面的代码将会创建一个 [1,4) 区间的数列。 123for (i in 1 until 4) &#123; Log.e(TAG, "test 1 until 4 i = " + i)&#125; 反转数列 121.rangeTo(10).reversed()(1..10).reversed() 所有的基本类型在生成数列的实现方式不同，但是都支持 .. 运算符生成数列，另外 Byte，Short，Int，Long 在生成数列时都是可以自动转换的。 123456789101112// byte(0b1..0b11)// char('a'..'z')// int(1..10)// long(1L..10L)// float(1f..2.2f)// double(1.1..2.2) 运算符 .. 对应的 rangeTo() 函数，其中 Float 和 Double 的 rangeTo() 函数使用扩展函数，其他为成员函数。 123456789101112// byte0b1.rangeTo(0b111)// char'a'.rangeTo('z')// int1.rangeTo(10)// long1L.rangeTo(10L)// double1.1.rangeTo(2.2)// float1.1f.rangeTo(2.2f) 函数 downTo()，Float 和 Double 不支持 downTo() 123456789101112// byte0b11.downTo(0b1)// int1.downTo(10)// char'a'.downTo('z')// long1L.downTo(10L)// double error// 1.1.downTo(2.2)// float error// 1.1f.downTo(2.2f) 函数 step()，Float 和 Double 不支持 step() 123456789101112131415161718// byte0b1.rangeTo(11L).step(2)// int1.rangeTo(10).step(2)// char'a'.rangeTo('z').step(2)// long1L.rangeTo(10L).step(2)// double error// 1.1.rangeTo(2.2).step(2)// float error// 1.1f.rangeTo(2.2f).step(2)// int1.downTo(10).step(2)// char'a'.downTo('z').step(2)// long1L.downTo(10L).step(2) 类型转换使用 is 关键字进行类型的检测，使用 as 关键字进行类型转换。 12345678val str = "100"val isString = str is Stringval notString = str !is String// Intval num = str as Int// Int?val num2:Int? = str as? Int 类型自动转换当使用 is 关键字进行了类型判断，那么一定作用域内，类型将被自动转换。 比如在判断结构当中 12345678910111213val myNum: Any = 100if (myNum is String) &#123; // 自动转换为 String myNum.length&#125;// error// myNum.lengthif (myNum !is String) return// 在此之后将被自动转换为 String myNum.length 在 || 和 &amp;&amp; 因为遵循短路判断，因此类型也将会被自动转换。 12345if (myNum is String &amp;&amp; myNum.length &gt; 10) &#123;&#125;if (myNum !is String || myNum.length &gt; 10) &#123;&#125; 在 when 结构中进行了类型判断 12345when (myNum) &#123; is Int -&gt; myNum.rangeTo(10) is String -&gt; myNum.length is IntArray -&gt; myNum.size&#125; 并不是所有的属性都可以进行自动的类型转换，需要满足以下条件： 局部的 val 变量 - 永远有效 。 val 属性 - 如果属性是 private 或 internal 的，或者类型检查处理与属性定义出现在同一个模块内，那么智能类型转换是有效的。对于 open 属性， 或存在自定义 get 方法的属性， 智能类型转换是无效的。 局部的 var 变量 - 如果在类型检查语句与变量使用语句之间，变量没有被改变, 而且它没有被 Lambda 表达式捕获并在 Lambda 表达式内修改它，那么智能类型转换是有效的。 var属性 - 永远无效(因为其他代码随时可能改变变量值)。 异常处理在 Kotlin 中与 Java 大致相同，有几个特别的地方。 try{} 可以作为一个表达式，并返回值。 1234567val result = try &#123; Integer.parseInt("10")&#125; catch (e: Exception) &#123; 0&#125;finally &#123; &#125; 不支持函数声明时抛出异常，这项改进主要是避免代码中出现大量的异常捕捉代码块。 在 Java 中可以在方法声明时抛出异常，来告知外界使用该函数可能会有异常 123public static void test() throws IllegalStateException&#123;&#125; 在 Kotlin 中这种语法是不支持的。 1234// errorfun test() throws IllegalStateException&#123; &#125;]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin开发-13-集合]]></title>
    <url>%2Farticle%2F4c59f5f5%2F</url>
    <content type="text"><![CDATA[在 Java 中集合类型也是很重要的数据结构，它可以用来存储一组同类型的数据； 在 Kotlin 中将集合明确分为了可变的集合和不可变的结合，List&lt;out T&gt; 是一个只读的接口，只能执行的 get()，size() 等读取方法，如果想要更改集合的数据，需要使用 MutableList&lt;T&gt;，从而区分可辨与不可变集合。Set&lt;out T&gt; 和 MutableSet&lt;T&gt;、Map&lt;K,out V&gt; 和 MutableMap&lt;K,V&gt; 也是同样的模式。 相比 Java，Kotlin 中的集合除了包含 Java 中的集合的相关方法，还扩展了很多简化集合操作的函数，结合 Lambda 表达式，把一些对集合的操作变的相当相当方便。 本文主要是对集合类的各种函数进行尝试和整理。 创建和访问在 Kotlin 中，List&lt;out T&gt; 是只读的，因此只能访问它的 get() 方法，如果需要改变元素的值，需要使用 MutableList&lt;out T&gt;，Kotlin 中列表的元素可以像数组那样使用 list[index] 的形式访问。 1234// 创建一个可变列表val mutableList = mutableListOf(1,3,4)// 创建一个只读列表val readOnlyList = listOf(1,2,3) 读写元素 12345val item = list[0]// mutablelist[0] = "1" 在 Kotlin 中也针对元素的读写扩展了很多简化的方法 123456789// index 在范围内返回值，否则返回 lambda 表达式的结果list.getOrElse(1) &#123; "$it" &#125;// index 在范围内返回值，否则返回 nulllist.getOrNull(1)// 一些类似的函数list.elementAt(2)list.elementAtOrNull(2)list.elementAtOrElse(2) &#123; "$it" &#125; 获取下标 1234567891011// 该元素出现的最后一次的下标list.lastIndexOf("10")// 该元素出现的第一次的下标list.indexOf("10")// 从开始第一个开始满足条件的下标list.indexOfFirst &#123; it.length &gt; 10 &#125;// 从最后一个开始满足条件的下标list.indexOfLast &#123; it.length &gt; 10 &#125; 查找第一个满足条件的元素 123456// 查找第一个满足条件的，找不到就抛异常list.first &#123; it.length &gt; 10 &#125;// 如果列表为空返回 null,否则返回第 0 项list.firstOrNull()// 查找第一个满足条件的，找不到返回 nulllist.firstOrNull &#123; it.length &gt; 10 &#125; 从后向前查找第一个满足条件的元素 123456// 从后向前查找第一个满足条件的，找不到就抛异常list.last &#123; it.length &gt; 10 &#125;// 如果列表为空返回 null,否则返回第 size-1 项list.lastOrNull()// 从后向前查找第一个满足条件的，找不到返回 nulllist.lastOrNull &#123; it.length &gt; 10 &#125; 遍历集合的遍历是个老话题，Kotlin 中集合的遍历更优雅，更强大。 forEach 循环 12345678// 只关注 valuelist.forEach &#123; Log.e("test", "value is $it") &#125;// 带有下标的遍历list.forEachIndexed &#123; index, value -&gt; Log.e("test", "index is $index value is $value")&#125; 迭代器遍历，相当于使用 Java 中的 Iterate 进行遍历。 123456789// 迭代器遍历for (value in list.listIterator()) &#123; Log.e("test", "value is $value")&#125;// 从第 n 个开始for (value in list.listIterator(10)) &#123; Log.e("test", "value is $value")&#125; for…in 循环 1234567891011121314// 遍历下标for (i in list.indices) &#123; Log.e("test", "value is $&#123;list[i]&#125;")&#125;// 遍历值for (value in list) &#123; Log.e("test", "value is $value")&#125;// 值和下标同时遍历for ((index, value) in list.withIndex()) &#123; Log.e("test", "index is $index value is $value")&#125; 遍历一个列表时，如果该列表是基于数组结构的，那么会具有数组的特点，访问容易但是插入相对困难，如果列表是基于链表结构的，那么会具有链表的特点，访问困难但是插入相对容易；遍历数组时可以根据此特点进行优化。 1234567if (list is RandomAccess) &#123; for (index in list.indices) Log.e("test", "value is $&#123;list[index]&#125;")&#125; else &#123; for (value in list.listIterator()) Log.e("test", "value is $value")&#125; 检测元素这部分函数主要用来简化我们需要遍历集合得到一个 boolean 结果的情况，在 Java 中我们通常需要写一个循环然后挨个判断每个元素达到结果。在 Kotlin 中借助 Lambda 表达式，我们可以像操作一个整形变量一样操作集合。 1234567891011// 如果全都不满足条件返回 trueif (list.none &#123; it.length &gt; 10 &#125;) &#123;&#125;// 如果全部满足条件返回 true,否则 falseif (list.all &#123; it.length &gt; 10 &#125;) &#123;&#125;// 如果有一个满足条件就返回 trueif (list.any &#123; it.length &gt; 10 &#125;) &#123;&#125; filter 操作列表的 filter 操作是指按照一定的条件对列表元素进行过滤，返回包含过滤后元素的新列表。 在进行这部分函数设计时，总会有 xxxx() 和 xxxxTo(list:MutableCollection&lt;T&gt;) 这样的函数组合，前者将会返回一个 List&lt;out T&gt; 类型的集合，也就是只读的，而后者将会返回参数中传递的 MutableCollection&lt;T&gt;，他是可变的，下面将不再赘述。 12345678val destList = mutableListOf&lt;String&gt;()// 根据 lambda 表达式返回结果过滤元素，返回 List&lt;out T&gt;list.filter &#123; it.length in 2..3 &#125;// 根据 lambda 表达式返回结果过滤元素，返回可变集合list.filterTo(destList) &#123; it.length in 2..3&#125; 带有下标的的过滤 12345678910// 与 filter 函数相似，但是函数中会有 index 参数，返回 List&lt;out T&gt;list.filterIndexed &#123; index, value -&gt; value.length in 2..3 &amp;&amp; index in 3..5&#125;// 与 filter 函数相似，但是函数中会有 index 参数，返回可变集合list.filterIndexedTo(destList) &#123; index, value -&gt; value.length in 2..3 &amp;&amp; index in 3..5&#125; 过滤属于某个类型的元素 1234567// 使用 reified 关键字，因此不需要使用 classlist.filterIsInstance&lt;String&gt;()list.filterIsInstanceTo(destList)// 使用 classlist.filterIsInstance(String::class.java)list.filterIsInstanceTo(destList, String::class.java) filterNot 1234567// 过滤不满足的条件的元素，与 filter 函数的功能相反，存储到新的列表中list.filterNot &#123; it.length &gt; 10 &#125;list.filterNotTo(destList) &#123; it.length &gt; 10 &#125;// 是 filterNot 的一种扩展，过滤 null 数据list.filterNotNull()list.filterNotNullTo(destList) 搜索从列表中按照条件搜索元素 12345// 查找第一个满足条件的值，返回 T？类型，查找不到将会为 nulllist.find &#123; it.length &gt; 10 &#125;// 查找最后一个满足条件的值，返回 T？类型，查找不到将会为 nulllist.findLast &#123; it.length &gt; 10 &#125; 二分搜索，使用 binarySearch 之前，列表应被排为升序，否则结果是不确定的 1234567891011121314151617// 根据传入的 lambda 表达式参数判断查找的值是否合适，返回负数表示，查找到的值过小，正数表示查找到的值过大，0 表示查找到// 下面的写法可能相对复杂，只是为了体现如果告知当前查找结果的正确性。list.binarySearch(fromIndex = 2, toIndex = 10) &#123; if (it.length &gt; 10) 1 else if (it.length &lt; 10) -1 else 0&#125;// 另一个重载方法，使用 Comparator 来进行数据的比较，参数都是可选的。list.binarySearch( element = "10", fromIndex = 0, toIndex = 2, comparator = Comparator&lt;String&gt; &#123; o1, o2 -&gt; o1.length - o2.length &#125;)list.binarySearch(element = "10", fromIndex = 0, toIndex = 2)list.binarySearch(element = "10") 排序对于 List&lt;out T&gt; 类型来说，排序之后仍然只能返回只读列表，注意，返回的列表将是一个新的列表，与原来的列表没有关系，为啥呢？因为原来的列表是不可变的啊。 123456789101112// 范型 T 对应的类型要是 Comparable 的子类list.sorted()// 不必是 Comparable 的子类 但是 lambda 表达式返回值需要是 Comparable 的子类，即将一个不可比较的类型映射到一个可比较的类型list.sortedBy &#123; it.length &#125;// 使用指定比较器排序list.sortedWith(comparator = Comparator &#123; o1, o2 -&gt; o1.length - o2.length &#125;)// 降序排序list.sortedDescending()list.sortedByDescending &#123; it.length &#125; 对于 MutableCollection&lt;T&gt; 类型来说，内部使用的是 Collection.sort() 方法来排序，这是一个在 java 中就使用的方法，函数的返回值是 Unit，这意味着函数不会返回一个新的列表，排序后的列表与原来的列表是同一个，当然他也可以使用上面的函数排序返回一个不可变列表，但是一个不可变列表是无法使用下面的函数排序的。 函数声明与上面的函数类似，但是没有 ed 后缀。 12345list.sort()list.sortBy &#123; it.length &#125;list.sortWith(comparator = Comparator &#123; o1, o2 -&gt; o1.length - o2.length &#125;)list.sortDescending()list.sortByDescending &#123; it.length &#125; 删除一般来说，List&lt;out T&gt; 类型是不可变的，但是可以使用 drop() 函数从列表中删除元素，但是此时删除后返回的列表是一个全新的列表。 12345678// 去除前 n 个返回列表list.drop(10)// 去掉后面10个，返回列表list.dropLast(10)// 删除满足条件的元素list.dropWhile &#123; it.length &gt; 10 &#125;// 从后向前删除满足条件的元素list.dropLastWhile &#123; it.length &gt; 10 &#125; 对于可变列表，可以使用 remove() 函数删除元素 12345678910// 删除元素，返回是否删除成功list.remove("")// 删除指定下标的元素，返回删除的这个元素list.removeAt(0)if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123; // 按照条件删除，内部使用迭代器实现 list.removeIf &#123; it.length &gt; 10 &#125;&#125;// 按条件删除list.removeAll &#123; it.length &gt; 10 &#125; 转换类似 RxJava 中的操作符，使用操作符可以将列表转换为其他类型。主要有 map，flapMap，associate 等。 map使用 Lambda 表达式将每一项 map 到新的数据 12345678// 返回新的 List&lt;out Int&gt;list.map &#123; it.length &#125;// 返回传入的 MutableList&lt;T&gt;list.mapTo(mutableListOf&lt;Int&gt;()) &#123; it.length &#125;// 与上面类似，只是 lambda 表达式参数有 indexlist.mapIndexed &#123; index, value -&gt; index + value.length &#125;list.mapIndexedTo(mutableListOf&lt;Int&gt;()) &#123; index, value -&gt; index + value.length &#125; 使用 mapNotNull 将集合中的非空数据进行 map，与上面的函数是类似的。 12345list.mapNotNull &#123; it.length &#125;list.mapNotNullTo(mutableListOf&lt;Int&gt;()) &#123; it.length &#125;list.mapIndexedNotNull &#123; index, s -&gt; index + s.length &#125;list.mapIndexedNotNullTo(mutableListOf()) &#123; index, s -&gt; index + s.length &#125; flatmap使用 flatmap 对集合中每一项都转换成一个集合，最后在一个存储在一个集合中。 123// 对每一项映射返回一个集合list.flatMap &#123; mutableListOf(it.length) &#125;list.flatMapTo(mutableListOf()) &#123; mutableListOf(it.length) &#125; associate这个操作主要用来将列表转换成对应的 Map。 以 Pair 的形式返回键值对，将 List&lt;T&gt; 类型转换为 Map&lt;K,V&gt;，返回的 Map 类型取决于返回 Pair 类型。 123list.associate &#123; Pair(it, it.length) &#125;list.associateTo(mutableMapOf()) &#123; Pair(it, it.length) &#125; 只接受一个 keySelector 参数用来映射生成最终 Map 的 key，将 List&lt;T&gt; 类型转换为 Map&lt;K,T&gt; 123list.associateBy &#123; it &#125;list.associateByTo(mutableMapOf()) &#123; it &#125; 接受一个 keySelector 和 valueTransform 作为参数，映射生成 key-value，将 List&lt;T&gt; 类型转换为 Map&lt;K,V&gt;； 123list.associateBy(keySelector = &#123; it &#125;, valueTransform = &#123; it.length &#125;)list.associateByTo(mutableMapOf(), keySelector = &#123; it &#125;, valueTransform = &#123; it.length &#125;) 最大值最小值用于查找整个列表中的最大值最小值 123456789101112// 范型对应的的类 需要是 Comparable 的子类list.min()// 使用 lambda 表达式将列表元素转换为可比较类型list.minBy &#123; it.length &#125;// 自定义比较器list.minWith(Comparator &#123; o1, o2 -&gt; o1.length - o2.length &#125;)// max 同理list.max()list.maxBy &#123; it.length &#125;list.maxWith(Comparator &#123; o1, o2 -&gt; o1.length - o2.length &#125;) 运算符列表支持直接使用运算符操作； 从列表中减去一个元素，或者加上一个元素，我们可以使用如下函数 12345// 函数，减法操作list.minusElement("1")// 函数，加法操作list.plusElement("1") 也有相同功能的 operator 函数，返回值为一个新的 List&lt;out T&gt; 123456789// operator，减法，接受一个元素list.minus("1")// operator，减法，接受一个列表list.minus(destList)// operator，加法，接受一个元素list.plus("1")// operator，加法，接受一个列表list.plus(destList) 由于上面的函数使用了 operator 注解标记，我们可以直接使用 + 和 - 代替使用函数。 1234val a = list + "1"val b = list + destListval c = list - "2"val d = list - destList 同样，可变列表也支持 += 和 -= 运算符，但是不可变列表无法使用这些函数，操作符对应的函数如下，返回值为 Unit，新的更改将作用于当前的列表。 12345678// operator,-= 操作，接受一个元素list.minusAssign("1")// operator,-= 操作，接受一个集合list.minusAssign(destList)// operator,+= 操作，接受一个元素list.plusAssign("1")// operator,+= 操作，接受一个集合list.plusAssign(destList) 也可以直接使用 += 和 -= 运算符 1234list += "1"list += destListlist -= "1"list -= destList 累积累积是我自己起的名字，是说遍历整个列表做一个累积操作，相关的函数有 sum，reduce，fold 等。 sum函数 sum() 是对列表每一项使用 Lambda 表达式转换为数字类型数据然后求和的操作； 12345// 对列表求和,返回 intlist.sumBy &#123; it.length &#125;// 对列表求和,返回 double 类型list.sumByDouble &#123; it.length.toDouble() &#125; reduce函数 reduce() 将列表的第一项作为初始值，然后对列表每一项使用 Lambda 表达式转换，然后累积，由于使用了列表的第一项作为初始值，所以 reduce() 的返回值与列表范型类型相同。 下面函数中 index 表示元素下标，acc 表示累积的结果，next 表示下一个元素。 123456789101112131415161718list.reduce &#123; acc, next -&gt; acc + next&#125;// 从右边开始累积list.reduceRight &#123; acc, next -&gt; acc + next&#125;// 带下标list.reduceIndexed &#123; index, acc, next -&gt; acc + index + next&#125;list.reduceRightIndexed &#123; index, next, acc -&gt; acc + index + next&#125; fold函数 fold() 与 reduce() 有些类似，但是 fold() 函数不是以列表的第一项作为初始值进行累积，而是可以指定一个初始值，也就是说，fold() 函数可以返回任意类型的累积结果。 12345678910111213141516171819list.fold(10) &#123; acc, next -&gt; acc + next.length&#125;// 从右到左list.foldRight(10) &#123; next, acc -&gt; acc + next.length&#125;// 带有下标的从左到右list.foldIndexed(10) &#123; index, acc, next -&gt; acc + index + next.length&#125;// 带有下标的从右到左list.foldRightIndexed(10) &#123; index, next, acc -&gt; acc + index + next.length&#125; take使用 take() 函数可以从列表中取出指定的部分值组成新的列表 1234567891011121314// 返回此时的列表的前 n 项，新的列表list.take(10)// 从后面返回 n 项，顺序还是原来的顺序list.takeLast(10)// 从前面取，直到满足条件，停止list.takeWhile &#123; it.length &gt; 10 &#125;// 从后面取，直到满足条件，终止list.takeLastWhile &#123; it.length &gt; 10 &#125;// 如果此列表满足条件，返回列表，否则返回 nulllist.takeIf &#123; it.size &gt; 10 &#125;// 如果此列表不满足条件，返回列表，否则返回 nulllist.takeUnless &#123; it.size &gt; 10 &#125; 分组和切片对列表进行分组和切片操作。 使用 group() 函数对列表分组，返回结果是 Map&lt;K,List&lt;T&gt;&gt; 类型，key 的类型由 Lambda 表达式的返回值决定。 12345678list.groupBy &#123; it.length&#125;list.groupByTo(mutableMapOf()) &#123; it.length &#125;// 返回 grouping 对象， since kt 1.1list.groupingBy &#123; it.length &#125; 使用 partition() 函数，根据 Lambda 表达式返回 true/false 将列表分成两个列表，返回值为 Pair&lt;List&lt;T&gt;,List&lt;T&gt;&gt; 1list.partition &#123; it.length &gt; 10 &#125; 对列表进行切片，返回切片后的新列表 123list.subList(0, 2)list.slice(IntRange(1, 3)) 其他另外一些无法归类的函数 使用 contains() 函数判断列表是否包含某个或某些元素 12list.contains("")list.containsAll(mutableListOf("1", "2")) 判空 1234// 如果 list 为空，返回一个新列表list.orEmpty()list.isEmpty()list.isNotEmpty() 使用 reverse() 函数反转列表，不可变列表可以使用 asReversed() 函数，这个函数将返回一个反转后的新的列表； 可变列表使用 reverse() 函数，返回值为 Unit，列表的反转将作用在自己身上，内部使用 Java 的 Collection. reverse() 实现，不可变列表不能调用该函数。 123list.reverse()list.asReversed() 使用 distinct() 对列表进行去重 1234list.distinct()// lambda 表达式返回比较的 keylist.distinctBy &#123; it.length &#125; 使用 count() 函数，获取列表长度 1234// 元素个数list.count()// 满足条件的元素个数list.count &#123; it.length &gt; 10 &#125; 使用 replaceAll() 函数替换全部数据 123if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123; list.replaceAll &#123; "$&#123;it.length&#125;" &#125;&#125; 使用 join() 函数，对每一项进行拼接，接受一个 Appendable 对象作为参数，可以设置拼接的前缀，后缀，分隔符等 12345list.joinTo(StringBuilder(), "-", "#", "*", 4) &#123; "$&#123;it.length&#125;"&#125;list.joinToString("-", "#", "*", 4) &#123; "$&#123;it.length&#125;" &#125; 使用 single() 函数，当列表只有一个元素时获取这个元素 123456// 当只有一个元素时返回该元素，否则异常list.single()// 当只有一个元素时返回该元素，否则返回 nulllist.singleOrNull()// 查找符合条件的一个，否则返回 nulllist.singleOrNull &#123; it.length &gt; 10 &#125; 使用 union() 函数，返回两个列表的非重复集合 1list.union(destList) 使用 zip() 函数压合两个列表，返回值为 List&lt;Pair&lt;T,R&gt;&gt;，列表长度等于较短的一个 123val list2 = listOf(4, 5, 6)var zip = list.zip(list2) 使用 subtract() 函数从列表中剔除部分元素 1list.subtract(destList) 使用 retainAll() 函数对两个列表取交集。 123456list.retainAll(destList)// 保留符合条件的元素if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123; list.retainAll &#123; it.length &gt; 10 &#125;&#125;]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin开发-12-空值安全]]></title>
    <url>%2Farticle%2Fc5b3d729%2F</url>
    <content type="text"><![CDATA[在进行属性的初始化时能够感受到 Kotlin 在编译时对 null 值的控制，正是因为 Kotlin 的这些特性，使得 Kotlin 成为一种 空安全(Null Safaty) 的语言，遵循 Kotlin 的规范将有效的避免程序中的 NPE。 其实遵循 Kotlin 的变量的声明和初始化方式基本可以避免 NPE 的出现，Kotlin 不允许给一个 变量 null 值，但是你可以使用 Type? 的形式(例如 String? )声明这是一个可以为 null 的变量，他就可以被初始化为 null。 除此之外，kotlin 提供了丰富的运算符在运行时进行 空值检测 ，简化代码逻辑。 安全调用 (?.)安全调用即 safe calls，使用?.操作符。 当我们访问一个变量的属性或者方法时，为了避免 NPE 我们通常要在前期做严密的空值判断确保调用的对象不为空时才能放心调用，safe calls 的机制大大简化了这个过程。 safe calls 只有当引用不为 null 时才进行调用，否则直接返回 null，如下情况中 b 的类型为 Int?，因为 a 可能为 null，调用 a 的 length 属性，如果 a 不为 null，则返回 Int 类型的长度，反之返回 null，因此 b 为 Int?，即可能为 null 的 Int 类型。 12val a: String? = nullval b = a?.length 一个使用 safe calls 简化调用的实例 123456789val myParam1:Student? = null// java 中，在使用之前，我们通常会做一系列判空操作if(myParam1!=null &amp;&amp; myParam1.myCls!=null)&#123; Log.e(TAG,"$&#123;myParam1.myCls.length&#125;")&#125;// Kotlin safe callsLog.e(TAG,"$&#123;myParam1?.myCls?.length&#125;") 有时我们在判空之后会执行一系列的操作，此时就可以结合 let 关键字，使用 ?.let{} 来确保变量不为空时执行方法，同时在 let 方法体内，可以使用 it 关键字访问变量。 1234val a: String? = nullval b = a?.length// b不为null时进行打印b?.let &#123; log("$it") &#125; Elvis 操作符 (?:)Elvis 操作符 即 ?: 操作符。当使用 ?. 操作符进行安全调用时，如果遇到 null 则会直接返回 null，那如果当为 null 时返回其他值时如何操作呢？Elvis 操作符 就是用来解决这个问题的。 如果 ?: 左侧的表达式值不是 null, Elvis 操作符 就会返回它的值, 否则, 返回右侧表达式的值. 注意, 只有在左侧表达式值为 null 时, 才会计算右侧表达式。 1234// 原始版本，使用 if...elseval l: Int = if (b != null) b.length else -1// 使用 ?: 操作符val l = b?.length ?: -1 由于在 Kotlin 中 throw 和 return 都是表达式, 因此它们也可以用在 Elvis 操作符 s的右侧. 这种用法可以带来很大的方便, 比如, 可以用来检查函数参数值是否合法: 12345fun foo(node: Node): String? &#123; val parent = node.getParent() ?: return null val name = node.getName() ?: throw IllegalArgumentException("name expected") // ...&#125; !! 操作符如果你确实清楚此时可以抛出一个 NPE，那么你可以使用 !! 操作符。 对于 b 不为 null 的情况, 这个表达式将会返回这个非 null 的值, 如果 b 是 null, 这个表达式就会抛出一个 NPE。 1val l = b!!.length as? 操作符如果对象不是我们期望的目标类型, 那么通常的类型转换就会导致 ClassCastException 。 使用 as? 进行安全的类型转换, 如果转换不成功, 它将会返回 null。 1val aInt: Int? = a as? Int]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin开发-11-函数]]></title>
    <url>%2Farticle%2Facb7c552%2F</url>
    <content type="text"><![CDATA[本文学习 Kotlin 函数的相关用法。主要包括 ： 函数的声明和使用，函数的参数和返回值，单表达式函数的使用，使用不定长参数。 局部函数，尾递归函数，高阶函数，内联函数等。 Lambda 表达式，匿名函数和闭包。 其他如，reifeid 关键字，非局部返回及带有接受者的函数字面值。 函数在 Kotlin 函数是一等公民，它的地位和对象一样，所以不要对函数特别看待，就把它当作对象看就行了，这样很多东西会好理解的多。 声明和使用函数声明的一般形式为 123fun functionName(param1:Type,param2:Type...)[:ReturnType]&#123;&#125; 如果是 top-level 级别的函数可以直接使用函数名调用，如果是一个类函数，需要拿到类实例，使用点号标记法调用。 1234567fun simpleFunction(param:String):Int&#123; return param.length&#125;// 调用simpleFunction("100")Engineer().test() Kotlin 支持中缀标记法调用函数，如果需要支持中缀标记法调用，需要满足条件： 是一个类函数或扩展函数，使用 infix 关键字声明，只有一个参数 12345678910infix fun Int.cross(another: Int): Int &#123; return this * another&#125;class Engineer(var name: String = "", var age: Int = 0)&#123; // together 函数 infix fun together(e: Engineer): Int &#123; return this.age + e.age &#125;&#125; 它使得函数可以像运算符那样使用 123456789val x = 100val result = x cross 10// 相当于val result2 = x.cross(10)val e = Engineer()var newEngineer = e together Engineer(name = "new")// 相当于var newEngineer2 = e.together(Engineer(name = "new")) 参数和返回值在 Kotlin 中，参数使用 param:Type 的形式声明，每个参数必须声明数据类型；返回值在函数的最后，函数体之前，使用 :returnType 的形式声明，如果没有返回值，可以使用 :Unit 或者不写返回值的形式来表示。 参数支持 默认值 和 参数名指定参数 调用，简化函数的重载。主要体现在： 具有默认值的参数我们在调用过程中可以不传该参数，将会使用参数的默认值，另外我们可以使用参数名指定某些参数，也就是只传部分参数，当然没有默认值的参数是必须传的。 使用函数的默认值进行函数重载时，需要注意参数是从第一个参数开始往后面匹配的，因此无默认值的参数要往前面放，如下函数： 另外，由于如果最后一个参数是一个函数，那么可以将这个函数放在 () 之外，使用 Lambda 表达式传参，因此，如果有这样的函数参数，建议放在最后。 1234567891011fun testDefParam(p1: String = "", p2: Int = 10, p3: Int = 1, p4: String) &#123;&#125;// 我们如此调用是不可以的testDefParam("", "") // error// 我们需要将无默认值的参数提到前面，才能自动匹配上fun testDefParam(p4: String, p1: String = "", p2: Int = 10, p3: Int = 1) &#123;&#125; 使用默认值调用时，当参数过多时，默认匹配的方式也多，而且我们必须将没有默认值的参数提前，会导致代码阅读性变差，不容易维护，因此相对更推荐使用参数名指定参数的方式，代码会更清晰，参数列表也没有任何限制，但是如果没有默认值的参数是必须传值的。 12345fun testNamedParam(p1: String = "", p2: Int = 10, p3: Int = 1,p4: String) &#123;&#125;// p4 参数是必须传的testNamedParam(p2 = 11,p4 = "test") 类函数在继承时，子类不可以声明默认值，不论父类中同函数参数有没有默认值都不可以。 1234567891011open class ATest &#123; open fun test(p1: Int, p2: String = "") &#123; &#125;&#125;class BTest : ATest() &#123; // p1 p2 参数都不能再声明默认值 override fun test(p1: Int, p2: String) &#123; super.test(p1, p2) &#125;&#125; 虽然在子类中我们不能声明参数默认值，但是父类中的参数默认值在子类中同样生效，如上面的代码我们可以如下调用： 12ATest().test(1)BTest().test(1) 函数的参数中的基本数据类型都是 val 类型的变量，也就是在函数体内无法改变其值 1234fun testFuncParamVal(index:Int,user:User)&#123; index = 100 // error. val can not be reassigned user.name = "" // error. val can not be reassigned&#125; 单表达式函数(Single-Expression)单表达式函数 (Single-Expression function) 如果函数可以直接使用一条简单的表达式表示，可以省略函数体，直接在 = 之后声明，如果函数的返回类型可以通过类型推断得到，那么返回类型也可以省略。 123fun singleExpressionFunc(): Int = 12 * 10// 省略返回类型fun singleExpressionFunc() = 12 * 10 不定长参数(varargs)类似 java 中的 ... ，kotlin 使用 varargs 来表示不定长参数，varargs 声明的参数的类型实际上是一个 Array&lt;out T&gt; 类型的值，因此可以使用下标访问每一个参数 12345678910fun asList(vararg args: String): List&lt;String&gt; &#123; val list = ArrayList&lt;String&gt;() for (arg in args) &#123; list.add(arg) &#125; return list&#125;// 简单调用 asList("1","@","3") 通常情况下 varargs 类型的参数应该是最后一个参数，因为由于 varargs 类型的参数接受的是一个数组，后面的参数将无法识别，不过好在 kotlin 有使用参数名指定参数的传参方法。 12345678fun asList(vararg args: String,count:Int): List&lt;String&gt; &#123; val list = ArrayList&lt;String&gt;() list += args return list&#125;// testasList("1","@","3",count = 1) 当我们已经有一个数组时，希望将这个数组作为参数直接传递给函数，此时是无法传参的，因为它会将整个 Array 作为一项，如下面的代码中，会提示类型不对，这种情况可以使用 展开操作符(*)，将数组展开 1234567val strings = arrayOf("1", "2", "3")// error. Required:String,Found:Array&lt;String&gt;asList(strings,count = 1) // 正确姿势val strings = arrayOf("1", "2", "3")asList(*strings,count = 1) 几种函数类型顶级函数：函数可以声明为 top-level 级别，我们不需要单独定义一个类来容纳这个函数，顶级函数可以访问公开的类和属性。 局部函数：指的是声明在函数内部的函数，局部函数可以访问外部函数的局部变量。 12345678910111213141516// MainActivity 中的变量val valueInMainActivity = 100// 外部函数fun localFunctionOutter()&#123; // 外部函数的局部变量 val valueInLocalFunctionOuter = 10 // 局部函数 fun localFunctionInner()&#123; // 局部函数的局部变量 val valueInLocalFunctionInner = 1 // 局部函数可以访问外部函数的局部变量 log("$valueInMainActivity $valueInLocalFunctionOuter $valueInLocalFunctionInner") &#125; // 调用局部函数 localFunctionInner()&#125; 成员函数：声明在类和对象中的函数，它作为类的成员可以访问其他成员。 范型函数：函数中可以带有范型，关于范型的相关问题在 kotlin-范型 会有更细致的描述。 123fun &lt;T&gt; test2(t:T) where T : Box&lt;T&gt;, T : Cloneable&#123;&#125; 扩展函数：对已有类进行扩展，关于扩展函数的相关问题在 kotlin-扩展 会有更细致的描述。 12345fun &lt;E&gt; MutableList&lt;E&gt;.swap(index1: Int, index2: Int) &#123; val temp = this[index1] this[index1] = this[index2] this[index2] = temp&#125; 尾递归函数(tailrec)我们在 Java 中使用递归函数时，如果递归的次数太多，具体能够承载的递归次数与函数的复杂程度有关，会导致堆栈溢出，kotlin 对递归函数做了优化，使用 tailrec 关键字声明尾递归函数，并且满足要求的形式，在编译时，会消除函数的递归调用，产生一段基于循环的代码，避免嵌套过深导致堆栈溢出。 要符合 tailrec 修饰符的要求，函数必须在它执行的所有操作的最后一步，递归调用它自身。如果在这个递归调用之后还存在其他代码，那么你不能使用尾递归，而且你不能将尾递归用在 try/catch/finally 结构内。 尾递归函数和我们平常的递归函数没有很大差别，使用 tailrec 关键字声明，参照官网上面的例子。 12tailrec fun findFixPoint(x: Double = 1.0): Double = if (Math.cos(x) == x) x else findFixPoint(Math.cos(x)) 在编译时，他将会生成类似如下的结构 12345678private fun findFixPoint(): Double &#123; var x = 1.0 while (true) &#123; val y = Math.cos(x) if (x == y) return y x = y &#125;&#125; 高阶函数在 kotlin 中函数和属性一样可以作为另一个函数的参数或返回值，这类函数被称为高阶函数，它使得函数可以如同对象一样进行传递。 如同字符串类型是 String，整型的类型是 Int，函数具有自己的类型，函数的类型使用 (p1:Type1,p2:Type2...) -&gt; returnType，其中参数的名称 p1,p2 是可以省略的，但是参数列表的 () 不能省略，需要注意的是即使函数返回值是 Unit 也无法省略，因为编译器将无法识别 (Type) 是一个什么类型。 1234567891011121314151617// 声明函数的类型val fun1: (String, Int) -&gt; Int = &#123; p1, p2 -&gt; p1.length + p2&#125;// 带有参数名val fun2: (p1: Int) -&gt; Int = &#123; p1 -&gt; p1&#125;// 返回值为 Unitval fun3: (String) -&gt; Unit = &#123;&#125;// error. 不能省略 Unitval fun4: (String) = &#123;&#125; 函数作为返回值函数可以作为返回值，作为返回值时，需要使用 Lambda 表达式的方式书写。 123456789101112// 函数作为返回值fun testReturnFunction(): (String, Int) -&gt; Int &#123; // 返回一个 参数为 (String,Int) 返回值为 Int 的函数 return &#123; p1: String, p2: Int -&gt; p1.length + p2 &#125;&#125;// 我们可以使用该函数获取内部返回的函数val returnFunction = testReturnFunction()var value = returnFunction("2", 1) 函数作为参数函数可以作为函数参数，声明函数时可以像普通对象那样对待函数类型的参数 1234// 函数作为参数fun testParamFunction(inFun: (String, Int) -&gt; Int): Int &#123; return inFun("1", 1)&#125; 我们可以使用一个 Lambda 表达式创建一个函数作为参数，当函数 A 的最后一个参数也是函数时，可以在函数 A 后面直接用 {} 声明函数体。 12345678// 普通用法testParamFunction(inFun = &#123; s, i -&gt; s.length + i&#125;)// 简单用法testParamFunction &#123; s, i -&gt; s.length + i &#125; 如果该函数还有其他参数，那就必须使用 () 来放置这些参数，如下： 123456789101112// 函数作为参数fun testParamFunction(count:Int,inFun: (String, Int) -&gt; Int): Int &#123; return inFun("1", 1)&#125;// 普通用法testParamFunction(1,inFun = &#123; s, i -&gt; s.length + i&#125;)// 简单用法testParamFunction(1) &#123; s, i -&gt; s.length + i &#125; 使用 :: 操作符，可以将一个定义好的参数作为参数传递，这边还涉及了一点反射的内容，暂时不去深究。 1234567891011121314151617181920212223242526272829303132class FunParamTest() &#123; fun isYes(str: String): Int &#123; return str.length &#125; fun test1(param:String) &#123; // 直接定义一个函数 val p1: (String) -&gt; Int = &#123; 100 &#125; test2(p1) // 一个局部函数 fun isOdd(str: String): Int &#123; return str.length &#125; // 用一个局部变量接受这个函数，并调用他 val p2 = ::isOdd p2("") // 直接传递该函数作为参数 test2(::isOdd) // error，暂时不知道为什么，只有局部函数可以使用 :: 操作符传递 test2(::isYes) &#125; fun test2(f: (String) -&gt; Int) &#123; &#125;&#125; 融会贯通，让函数如同对象一样自由的传递，我们以上面的两种函数为例 12345678910111213141516171819202122232425// 声明一个函数val fun1: (String, Int) -&gt; Int = &#123; p1, p2 -&gt; p1.length + p2&#125;testParamFunction(1, inFun = fun1)// 从另一个函数中返回一个函数val fun5: (String, Int) -&gt; Int = testReturnFunction()testParamFunction(1, inFun = fun5)// 使用 lambda 表达式创建一个函数testParamFunction(1, inFun = &#123; p1, p2 -&gt; p1.length + p2 &#125;)// 使用声明好的函数 fun fun6(p1:String,p2:Int):Int&#123; return p1.length + p2&#125;testParamFunction(1, inFun = ::fun6) Lambda 表达式在 Kotlin 中使用 Lambda 表达式，Lambda 表达式使用如下方式。 1234&#123; param1,param2 -&gt; ...函数体...&#125; 当某个参数我们不用时，可以使用 _ 代替，如函数 1234567891011121314fun testLambda(inFun: (String, Int) -&gt; Int): Int &#123; return inFun("1", 1)&#125;testLambda&#123; p1,p2 -&gt; p1.length + p2&#125;// 不使用 p2 参数testLambda&#123; p1, _ -&gt; p1.length&#125; 当只有一个参数时，如果没有用到这个参数可以直接不用声明，也可以使用单一参数的隐含名称 it 代替。 12345678910111213fun testLambda(inFun: (String) -&gt; Int): Int &#123; return inFun("1")&#125;// 当不使用参数时，可以不用声明testLambda &#123; 0&#125;// 隐含参数 ittestLambda &#123; it.length&#125; 默认函数体的最后一条语句将会作为函数的返回值，但是不需要显式使用 return 关键字。如果想在其他位置返回值，需要使用带有后缀的 return 语句。 123456789101112// 最后一句将作为返回值testLambda &#123; it.length&#125;// 使用带后缀的 return 语句返回指定值testLambda &#123; if (it.length &gt; 100) return@testLambda it.length else return@testLambda 100&#125; 匿名函数匿名函数与普通函数类似，但是不需要指定函数名，支持单单表达式函数，也支持多行函数。 匿名函数必须使用 () 传递，对 Lambda 表达式支持的一些使用方式，对匿名函数并不支持。 Lambda 表达式与匿名函数之间的另一个区别是，它们的 非局部返回(non-local return) 的行为不同。不使用标签的 return 语句总是从 fun 关键字定义的函数中返回。也就是说，Lambda 表达式内的 return 将会从包含这个 Lambda 表达式的函数中返回，而匿名函数内的 return 只会从匿名函数本身返回。 12345testParamFunction(1, inFun = (fun(p1, p2) = p1.length + p2))testParamFunction(1, inFun = (fun(p1, p2): Int &#123; return p1.length + p2&#125;)) 函数的闭包Lambda 表达式和匿名函数可以访问外部变量，因此会形成闭包。 函数 和 函数能访问到的变量(环境) 的总和 就形成了一个闭包。也就是说，当一个内部函数访问了外部函数的变量，此时会形成一个闭包。 使用闭包的目的是隐藏一些变量，这些变量只在外部函数中声明，但是不需要声明为全局属性。 如下函数声明，在 MainActivity 中和外部函数中分别都有变量，内部函数访问这些变量。 123456789101112131415161718// MainActivity 中的变量val valueInMainActivity = 100// 外部函数fun localFunctionOuter(): () -&gt; Unit &#123; // 外部函数的局部变量 val valueInLocalFunctionOuter = 10 // 局部函数 fun localFunctionInner() &#123; // 局部函数的局部变量 val valueInLocalFunctionInner = 1 // 局部函数可以访问外部函数的局部变量 log("valueInMainActivity = $valueInMainActivity " + ",valueInLocalFunctionOuter = $valueInLocalFunctionOuter " + ",valueInLocalFunctionInner = $valueInLocalFunctionInner") &#125; // 调用局部函数 return ::localFunctionInner&#125; 在下面的调用中，虽然 localFunctionOuter() 函数已经结束了， 但是仍然可以使用返回的函数访问 localFunctionOuter() 内部的变量，我们对外部隐藏了 valueInLocalFunctionOuter 这个变量。 12345val f = localFunctionOuter()f()// 输出MainActivity: valueInMainActivity = 100 ,valueInLocalFunctionOuter = 10 ,valueInLocalFunctionInner = 1 带有接受者的函数字面值带有接受者的函数字面值（Function Literals with Receiver） 这是一个类似于扩展函数一样的特性，我们借助官网的几个例子理解一下他的用法。 12val sum1 = fun Int.(other: Int): Int = this + other1.sum1(2) 这种声明方式和普通的函数有相似之处，他只是在参数前面追加了 Int 类型，来表示这个函数是 Int 类型可以直接调用的。 用一个类似的例子看一下与普通函数的对比，我加了些空格来对比，普通函数不能访问 this 变量，也不能直接使用 Int 类型调用函数。 12val sum1 = fun Int.(other: Int): Int = this + otherval sum2 = fun (other: Int): Int = other 对比一下，这种函数和扩展函数的差别，在使用和定义都没啥太大的差别，只是一个又函数名一个没有。 123456789val sum1 = fun Int.(other: Int): Int = this + otherfun Int.sum3(other: Int): Int &#123; return this + other&#125;1.sum1(2)1.sum3(2) 再来看一下官网的另一个例子，第一眼看上去是有些懵逼的，分析一下 123456789101112131415// 一个普通的类class HTML &#123; // 一个普通的函数 fun body() &#123; &#125;&#125;// 还是一个普通的函数，返回值为 HTML 对象// init 参数是一个无参无返回值的函数，// 由于使用了 (HTML.) 说明这个函数是一个可以被 HTML 对象直接调用的函数fun html(init: HTML.() -&gt; Unit): HTML &#123; val html = HTML() html.init() // 使用创建的 HTML 对象调用该函数 return html&#125; 调用，接受的参数是 HTML 类的一个无参无返回值的函数。 123456789html &#123; body() &#125;相当于html(&#123; body()&#125;) 内联函数(inline)使用高阶函数，每个函数都是一个对象，而且它还要捕获一个闭包，这些都会造成内存的损耗和运行效率的下降。使用内联函数可以将函数内联在函数调用处，而不用生成多余的对象再去调用他。 使用内联函数需要使用 inline 关键字声明，inline 关键字会影响函数本身，也会影响传递给他的表达式，这两者都会被内联到调用处。 123inline fun testInline(str:String,f: (String) -&gt; Int): Int &#123; return f(str)&#125; 如果函数有多个函数参数，可以使用 noinline 关键字声明那些不需要内联的函数 1234inline fun testInline(str: String, f1: (String) -&gt; Int, noinline f2: () -&gt; Unit): Int &#123; f2() return f1(str)&#125; 内联函数不能作为递归参数使用，对于内联函数中没有声明为 noinline 函数参数(它们都是内联的)，具有一些限制，这些参数 不能保存在域中，不能作为函数返回值返回，只能在内联函数内部调用，只能作为可以内联的函数参数传递给其他函数，我们通过一个例子说明： 12345678910111213141516171819202122232425// 一个内联函数inline fun testInline2(f1: (String) -&gt; Int)&#123;&#125;// 一个非内联函数fun testInline3(f1: (String) -&gt; Int)&#123;&#125;inline fun testInline(str: String, f1: (String) -&gt; Int, noinline f2: () -&gt; Unit): (String) -&gt; Int &#123; // error. inline 不可以保存在域内 // val localFun = f1 // error. 不能是递归的 // testInline(str,f1,f2) // yes. 内联的 lambda 表达式参数，可以作为其他内联函数的参数 testInline2(f1) // error. 内联的 lambda 表达式参数，不能作为非内联函数的参数 // testInline(f1) // error. inline 不可以作为返回值 // return f1&#125; 非局部返回(Non-local return)非局部返回（Non-local return） 在 Kotlin 中，使用不带标签的 return 语句只能返回使用 fun 关键字声明的函数，即普通的函数和匿名函数，在 Lambda 表达式是不允许使用不带标签的 return 语句的。 123456789fun testNonReturn(f: (String) -&gt; Int) &#123; log(f("test")) log("testNonReturn")&#125;testNonReturn &#123; // 不允许 return it.length&#125; 我们可以使用带有指定标签的 return 语句，用来返回不同条件下的结果，因为 Lambda 表达式总是将最后一句的结果作为返回值，带有标签的 return 语句只会从对应 Lambda 表达式返回，后面代码仍会执行。 12345678testNonReturn &#123; if (it.length &gt; 2) return@testNonReturn 100 else return@testNonReturn 1&#125;MainActivity: 100MainActivity: testNonReturn 对于内联函数，Lambda 表达式会被内联在调用处，那么可以使用 return 语句，此时 return 的作用是结束 Lambda 表达式作为参数的函数所在的那个函数，有点绕，借助下面的例子，testNonLocalReturn() 函数接受的 Lambda 参数将会结束 testNonLocalReturn() 函数所在的 foo() 函数，这种返回方式被称为 非局部返回（Non-local return）； 1234567891011121314inline fun testNonReturn(f: (String) -&gt; Int)&#123; f("test")&#125;fun foo():Boolean &#123; log("before testNonLocalReturn") testNonLocalReturn &#123; // 返回值为 boolean，将直接退出 foo 函数 log("invoke testNonLocalReturn") return true &#125; log("after testNonLocalReturn") return false&#125; 输出 12MainActivity: before testNonLocalReturnMainActivity: invoke testNonLocalReturn 有些时候 Lambda 表达式参数并不一定在函数内部执行，他可能通过一个局部对象或一个嵌套函数传递给其他执行环境调用，此时非局部返回也是被禁止的，为了明确这一点，我们使用 crossinline 关键字声明。 12345678910111213// 因为将会在另一个环境执行，使用 crossinline 标记inline fun testNonLocalReturnV2(crossinline f: () -&gt; Unit): Runnable &#123; val r = Runnable &#123; f() &#125; return r&#125;fun fooV2() &#123; testNonLocalReturnV2&#123; // error 使用 crossinline 标记，不能非局部返回 // return &#125; log("invoke fooV2")&#125; 实体化的类型参数(reified)实体化的类型参数(Reified type parameter) 主要用来解决范型参数无法像普通的类那样访问的问题。写一个函数，判断某个对象是不是属于某种类型。 123456fun &lt;T&gt; testReifiedType(p: Any, cls: Class&lt;T&gt;): Boolean &#123; return cls.isInstance(p)&#125;// 我们可以这样使用它testReifiedType("test", String::class.java) 这让我想起了 Gson 的使用方法，除了约定一个范型，我们还需要传递对应的 class 进去才能解析，kotlin 中内联函数支持 Reified type parameter，使用 reifeid 关键字注解范型，就可以像一个普通的类那样来访问范型类型了。 123456inline fun &lt;reified T&gt; testReifiedType(p: Any): Boolean &#123; return p is T&#125;// 调用testReifiedType&lt;String&gt;("") 需要注意的是，函数必须是 inline 类型才可以使用 reifeid 关键字注解。]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin开发-10-代理]]></title>
    <url>%2Farticle%2Fcc5968a9%2F</url>
    <content type="text"><![CDATA[本文主要学习 Kotlin 中的代理模式的实现以及属性代理的使用。 代理模式已被实践证明为类继承模式之外的另一种很好的替代方案，Kotlin 对代理模式做了很好的支持，我们可以非常简单的实现代理模式。 属性代理使得我们可以将具有共同性质的属性的初始化通过属性代理来实现，简化了数据的读取和存储，同时在 Kotlin 中还内置了很多标准代理，可以大大简化开发过程。 最后我们使用属性代理来实现一个完全的封闭的访问 SharePreference 进行数据存取的例子。 代理模式代理 (Delegate) 模式是一种常用的设计模式，Kotlin 对此作了很好的支持。 代理模式已被实践证明为类继承模式之外的另一种很好的替代方案，当我们已经抽象了部分功能出来，又想当前的对象具备这些功能，除了继承，我们可以使用代理模式，将当前对象需要的操作代理给别人做，实现复用。 使用官网的一个例子，并且进行了部分扩展，来理解代理模式的意义。 假设 BaseA 声明了 A 类逻辑，BaseAImpl 实现了这部分逻辑，BaseB 声明了 B 类逻辑，BaseBImpl 实现了这部分逻辑。此时我们的 Derived 需要同时具备 BaseA 和 BaseB 的功能，我们可以使用 Derived 再次实现 BaseA 和 BaseB 的相关功能但我们将无法复用在 BaseAImpl 和 BaseBImpl 中已经实现的逻辑代码。 使用代理模式，我们将 Derived 需要实现的功能分别代理给 BaseA 和 BaseB 的实现类，Derived 自己不做任何处理，使用代理去接收处理。事实上，我们会在 Derived 类中持有代理的对象，然后在对象的接口方法逻辑实现时转发给代理的相关方法，实现代理模式需要设计很多相关的接口代码，好在 Kotlin 已经为我们提供了代理模式的支持，我们只需要使用 by 关键字将功能的实现代理给指定对象即可。 12345678910111213141516171819202122interface BaseA &#123; fun printA()&#125;interface BaseB &#123; fun printB()&#125;class BaseAImpl(var x: Int) : BaseA &#123; override fun printA() &#123; log("BaseAImpl $x") &#125;&#125;class BaseBImpl(var x: Int) : BaseB &#123; override fun printB() &#123; log("BaseBImpl $x") &#125;&#125;// 将 BaseA 的逻辑代理给 ba, 将 BaseB 的逻辑代理给 bbclass Derived(ba: BaseA, bb: BaseB) : User(), BaseA by ba, BaseB by bb 1234567val derived = Derived(BaseAImpl(10), BaseBImpl(100))derived.printA()derived.printB()# 输出com.march.ktexample E/BaseAImpl: BaseAImpl 10com.march.ktexample E/BaseBImpl: BaseBImpl 100 属性代理我们可以使用代理属性的功能来初始化那些具有共性的属性，比如从 SharePerenferce 或者数据库中读取和存储，我们创建一个属性代理使用它来初始化这些具有共性的属性将会简单很多。 一个简单的代理实现使用一个简单的代理来初始化 value 属性 1234567891011121314151617var value: String by MyDelegate()class MyDelegate &#123; var temp = "test" operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String &#123; log(thisRef.toString()) log(property.toString()) log("invoke getValue") return temp &#125; operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) &#123; log("invoke setValue value is $value") temp = value &#125;&#125; 当我们读或写 value 属性时将会触发对应的代理方法 123log(value)value = "123"log(value) 12345678910// thisRef 的值MyDelegate: com.march.ktexample.MainActivity@445adf9// property 的值，操作的是 value 属性MyDelegate: property value (Kotlin reflection is not available)MyDelegate: invoke getValueMainActivity: testMyDelegate: invoke setValue value is 123MyDelegate: invoke getValueMainActivity: 123 代理属性的语法如下： by 关键字后面的表达式就是代理，他需要具有 getValue() 方法， 如果属性是 var 类型，那么还必须有 setValue() 方法。 1val/var &lt;propertyName&gt;:&lt;propertyType&gt; by &lt;expression&gt; getValue() 和 setValue()代理中的 getValue() 和 setValue() 方法没有类似接口的那种强制模板的实现，可能没有办法像接口那样声明统一的接口方法。 getValue() 和 setValue() 函数需要使用 operator 关键字标记，它们可以是委托类的成员函数，也可以是它的扩展函数。如果你需要将属性委托给一个对象，而这个对象本来没有提供这些函数，这时使用扩展函数会更便利一些。 参数列表和返回类型： 参数 thisRef:Any? 的类型必须与 属性所属的类 相同或者是它的基类(对于扩展属性 — 这个参数的类型必须与被扩展的类型相同或者是它的基类)。 参数 property: KProperty&lt;*&gt; 是被代理的属性，可以使用 property.name 查看属性名，这个参数的类型必须是 KProperty&lt;*&gt; 或者是它的基类。 对于 getValue() 函数来说返回值必须与被代理的属性的类型相同。 对于 setValue() 函数来说参数 value: Type 是属性的新值，他必须与属性的类型相同。另外需要将值进行存储，在 getValue() 函数中返回，否则将无法改变属性的值。 123456operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String &#123; return temp&#125;operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) &#123; temp = value&#125; Standard DelegatesKotlin 内置了一些标准代理。 Lazyby lazy 是属性代理在 kotlin 中的一个简化实现，使用 by lazy 可以延迟属性的加载，他接受一个 Lambda 表达式作为参数，返回一个 Lazy&lt;T&gt; 类型的实例。 只有 val 属性才能使用 by lazy 延迟初始化，因为 by lazy 只提供 getValue() 方法。 123@kotlin.jvm.JvmVersionpublic fun &lt;T&gt; lazy(initializer: () -&gt; T): Lazy&lt;T&gt; = SynchronizedLazyImpl(initializer) 使用 by lazy 只有在第一次获取值的时候回去计算 Lambda 表达式的值，后面再次访问，只会返回之前的值，不会再做计算。 12345678910111213val lazyValue: Int by lazy &#123; log("invoke by lazy") 100&#125;// 测试log(lazyValue)log(lazyValue)// 结果com.march.ktexample E/MainActivity: invoke by lazycom.march.ktexample E/MainActivity: 100com.march.ktexample E/MainActivity: 100 默认情况下，by lazy 的计算是 同步的(synchronized): 属性值只会在唯一一个线程内计算，然后所有线程都将得到同样的属性值。如果委托的初始化计算不需要同步，多个线程可以同时执行初始化计算，那么可以使用LazyThreadSafetyMode.PUBLICATION 参数。相反，如果你确信初期化计算只可能发生在一个线程内，那么可以使用 LazyThreadSafetyMode.NONE 模式，这种模式不会保持线程同步，因此不会带来这方面的性能损失。 Observable &amp; Vetoable可观察属性，Delegates.observable() 函数接受一个初始化值和一个属性值变化的响应器作为参数，可以用来观察属性的变化，当属性的值发生变化时会触发响应器。 123456789101112var observableValue: Int by Delegates.observable(1) &#123; property, oldValue, newValue -&gt; log("Delegates.observable - $&#123;property.name&#125; $oldValue $newValue")&#125;// 测试observableValue = 100observableValue = 200// 结果MainActivity: Delegates.observable - observableValue 1 100MainActivity: Delegates.observable - observableValue 100 200 如果想要在检测到属性变化时，截断赋值操作，需要使用 Delegates.vetoable()，如下，值等于 200 时，不做赋值操作。 1234567891011121314151617var vetoableValue: Int by Delegates.vetoable(1) &#123; property, oldValue, newValue -&gt; log("Delegates.vetoable - $&#123;property.name&#125; $oldValue $newValue") newValue != 200&#125;// 测试vetoableValue = 100log("(after set 100) $vetoableValue")vetoableValue = 200log("(after set 200) $vetoableValue")// 结果MainActivity: Delegates.vetoable - vetoableValue 1 100MainActivity: (after set 100) value is 100MainActivity: Delegates.vetoable - vetoableValue 100 200MainActivity: (after set 200) value is 100 NotNull使用非空代理 Delegates.notNull()，属性在声明时必须进行初始化，避免空指针的出现，Delegates.notNull() 类似于 lateinit 关键字，使你可以在后面初始化属性的值，在没有初始化之前如果使用了该属性，则会抛出异常 java.lang.IllegalStateException: Property notNullValue should be initialized before get. 1var notNullValue: String by Delegates.notNull&lt;String&gt;() Map使用 Map 存储属性的值，就可以从 Map 中获取对应属性的名称为 key 的值。 1234class MapUser(propertyMap: Map&lt;String, Any?&gt;) &#123; val name by propertyMap val age by propertyMap&#125; 使用 Map 初始化一个对象 12345678val mapUser = MapUser(mapOf( "name" to "myName", "age" to 25))log("name = $&#123;mapUser.name&#125; ,age = $&#123;mapUser.age&#125;")// 结果为MainActivity: name = myName ,age = 25 SharedPreferences 读写代理一个代理属性的例子。 以属性名为 key 从 SharedPreferences 读取数据，用来初始化属性的值，存储数据时同时写入 SharedPreferences； 123456789101112131415161718192021222324252627282930313233343536373839404142// 自定义 SharedPreferences 属性读写class SpDelegate&lt;T&gt;(val context: Context, val readName: String?, val defValue: T) : ReadWriteProperty&lt;Any?, T&gt; &#123; constructor(context: Context, defValue: T) : this(context, null, defValue) val KEY = "SharePreference" val mSharePreference: SharedPreferences by lazy &#123; context.getSharedPreferences(KEY, Context.MODE_PRIVATE) &#125; @Suppress("UNCHECKED_CAST") override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T &#123; val name = readName ?: property.name val result: Any = when (defValue) &#123; is Boolean -&gt; mSharePreference.getBoolean(name, defValue) is Int -&gt; mSharePreference.getInt(name, defValue) is Long -&gt; mSharePreference.getLong(name, defValue) is Float -&gt; mSharePreference.getFloat(name, defValue) is String -&gt; mSharePreference.getString(name, defValue) else -&gt; throw IllegalArgumentException("un support") &#125; log("getValue : result = " + result) return result as T &#125; override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) &#123; val editor = mSharePreference.edit() val name = readName ?: property.name when (value) &#123; is Boolean -&gt; editor.putBoolean(name, value) is Int -&gt; editor.putInt(name, value) is Long -&gt; editor.putLong(name, value) is Float -&gt; editor.putFloat(name, value) is String -&gt; editor.putString(name, value) else -&gt; throw IllegalArgumentException("un support") &#125; log("setValue : newValue = " + value) editor.apply() &#125;&#125; 测试属性的读取和写入 123456789var shareIntVar1: Int by SpDelegate(this, 1)var shareStringVar1: String by SpDelegate(this, "def String value")log(shareIntVar1)shareIntVar1 = 1000log(shareIntVar1)log(shareStringVar1)shareStringVar1 = "new String value"log(shareStringVar1) 结果 12345678910SpDelegate: getValue : result = 1MainActivity: 1SpDelegate: setValue : newValue = 1000SpDelegate: getValue : result = 1000MainActivity: 1000SpDelegate: getValue : result = def String valueMainActivity: def String valueSpDelegate: setValue : newValue = new String valueSpDelegate: getValue : result = new String valueMainActivity: new String value]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin开发-9-object关键字]]></title>
    <url>%2Farticle%2F40486d0b%2F</url>
    <content type="text"><![CDATA[本文学习 Kotlin 中 object 关键字的使用。 使用 object 关键字的对象表达式可以创建匿名对象，适合那些只需要使用一次的类实现，使用匿名对象我们不需要给这些只用一次的类对象声明 class 而是在运行时直接创建即可。 使用 object 关键字进行对象声明，借助这种方法可以简单的实现单例和同伴对象。 对象表达式对象表达式（Object expression） 对象表达式则会在使用处 立即 执行(并且初始化) 使用 object 可以创建匿名内部类，以点击事件为例 12345678910mMyMsgTv.setOnClickListener(object: View.OnClickListener&#123; override fun onClick(v: View?) &#123; // click &#125;&#125;)// 使用 Lambda 表达式简化。mMyMsgTv.setOnClickListener &#123; log("click")&#125; 自己定义两个接口 12345678interface OneFunInterface&#123; fun test(param:String)&#125;interface TwoFunInterface&#123; fun test1(param:String) fun test2(param:String)&#125; 我们可以使用匿名内部类创建对象 12345678910val o1 = object : OneFunInterface &#123; override fun test(param: String) &#123; &#125;&#125;val o2 = object : TwoFunInterface &#123; override fun test1(param: String) &#123; &#125; override fun test2(param: String) &#123; &#125;&#125; 实现匿名内部类时可以继承多个基类，如果基类有构造器，那么必须传递合适的参数 12345val o3 = object:User("zhang",22),OneFunInterface&#123; override fun test(param: String) &#123; &#125;&#125; 也可以不继承任何基类直接创建对象，👍 12345val o4 = object&#123; val x = 10 val y = 20&#125;log(o4.x) 对象表达式的内部可以访问创建对象表达式的域内的变量，这点和 Java 的匿名内部类是一样的， 但是 Kotlin 中不需要将变量强制声明为 final ，👍 12345678fun test()&#123; var t = 100 // 不必声明为 final val o1 = object : OneFunInterface &#123; override fun test(param: String) &#123; t = 10 &#125; &#125;&#125; 对象声明对象声明（Object declaration）不可以是局部的(也就是说，不可以直接嵌套在函数之内)， 但可以嵌套在另一个对象声明之内，或者嵌套在另一个非内部类之内。 对象声明是 延迟(lazily) 初始化的， 只会在首次访问时才会初始化 使用 object 关键字创建单例，不能具有构造器，可以指定基类，可以直接使用类名引用。 12345678910object Singleton : User(name = "test", age = 12) &#123; fun testFun() &#123; Log.e(javaClass.simpleName, "name = $name") &#125; val testVal = age&#125;// usageSingleton.testFun()Singleton.testVal 同伴对象，一个类内部对象声明可以使用 companion 关键字标记为同伴对象(Companion Object)。Companion Object 可以具有自己的类名，也可以直接使用默认类名 Companion。Companion Object 可以继承基类和实现接口。 同伴对象会在对应的类被装载(解析)时初始化 虽然同伴对象的成员看起来很像其他语言中的类的静态成员，但在运行时期，这些成员仍然是真实对象的实例的成员，它们与静态成员是不同的，但是，如果使用@JvmStatic 注解， 你可以让同伴对象的成员在 JVM 上被编译为真正的静态方法(static method)和静态域(static field)。 1234567891011121314151617181920212223242526// 默认类名 Companionclass MyClass &#123; companion object &#123; fun testFun() &#123;&#125; val testVal = 10 &#125;&#125;// 自己的类名class MyClass1 &#123; companion object MyCompanion &#123; fun testFun() &#123;&#125; val testVal = 10 &#125;&#125;// 继承基类 实现接口class MyClass2 &#123; companion object : User(), OneFunInterface &#123; override fun test(param: String) &#123; &#125; fun testFun() &#123;&#125; val testVal = 10 &#125;&#125; 我们可以直接使用外部类的类名调用其同伴对象的方法和属性 1234MyClass.CompanionMyClass1.MyCompanionMyClass.testValMyClass.testFun()]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin开发-8-范型]]></title>
    <url>%2Farticle%2F9e4433d5%2F</url>
    <content type="text"><![CDATA[本文主要介绍 Kotlin 范型的相关用法。 泛型的本质是参数化类型，操作的数据类型被指定为一个参数。使用范型约束： 增加代码的复用性，有时我们使用一些公用的数据结构，方法，类等，只是操作的对象类型不一样，但是代码逻辑一样，此时可以使用范型复用代码，比如 List&lt;T&gt;，就可以用来存储任何一种对象。 保证代码中类型转换的安全性，使用范型进行约束，能够保证在编译期对类型的匹配进行检测和转换，避免运行期出现类型转换异常，而且这些转换都是自动和隐式的。 推荐阅读 - Kotlin 泛型详解 - 10条 简单实现下面在 Java 和 Kotlin 中实现了最简单的范型的用法，用法相似，但是 Kotlin 就更加简单。当类型可以通过推断得到时，不必显式声明类型。 123456789101112131415// javaclass Box&lt;T&gt; &#123; private T t; public Box(T t) &#123; this.t = t; &#125; public T get() &#123; return t; &#125; public void set(T t) &#123; this.t = t; &#125;&#125;Box box = new Box&lt;&gt;(1); 1234// kotlinclass Box&lt;T&gt;(var t: T)val box = Box(1) Java 中的范型范型类型是不可变的，因此 List&lt;Child&gt; 并不是 List&lt;Parent&gt; 的子类型 123456// List&lt;String&gt; 不是 List&lt;Object&gt; 的子类型List&lt;Object&gt; objects = new ArrayList&lt;&gt;();List&lt;String&gt; strings = new ArrayList&lt;&gt;();objects = strings; // error. 为什么是不可变的呢？我们看一段伪代码，假如类型是可变的，那么 List&lt;String&gt; 就是 List&lt;Object&gt; 的子类。 12345List&lt;Object&gt; objects = new ArrayList&lt;&gt;();List&lt;String&gt; strings = new ArrayList&lt;&gt;();objects = strings; objects.add(100);String s = strings.get(0); // ClassCastException 由于范型类型的不可变，尽管 String 是 CharSequence 的子类型，但是我们甚至不能简单的做到如下操作： 12345678910class Box&lt;T&gt; &#123; private T t; public void resetBox(Box&lt;T&gt; box) &#123; this.t = box.t; &#125;&#125;Box&lt;CharSequence&gt; charSequenceBox = new Box&lt;&gt;();Box&lt;String&gt; stringBox = new Box&lt;&gt;();charSequenceBox.resetBox(stringBox); // error,在编译期禁止此操作 正因为如此，才有了 通配符类型参数 ，我们应该如下声明 resetBox() 的方法 123456class Box&lt;T&gt; &#123; private T t; public void resetBox(Box&lt;? extends T&gt; box) &#123; this.t = box.t; &#125;&#125; 通配符类型参数我们参照 List 类，来看一个简单的例子 12345List&lt;? extends String&gt; extendsTStringList = new ArrayList&lt;&gt;();// error 不能写入extendsTStringList.add("");// 可以读取String s = extendsTStringList.get(0); 这里的 通配符类型参数 ? extends T 表示，集合元素的类型是 T 的某种子类型, 而不限于 T 本身，这就意味着，我们可以安全地从集合元素中 读取 T (因为集合的元素是 T 的某个子类型的实例)，但 不能写入 到集合中去，因为我们不知道什么样的对象实例才能与这个 T 的未知子类型匹配。指定了 extends 边界 (上边界)的通配符类型, 使得我们的类型成为一种 协变(covariant) 类型。 同理，我们可以指定类型的下边界: 12345List&lt;? super String&gt; superTStringList = new ArrayList&lt;&gt;();// 可以写入superTStringList.add("");// 不能读取或只能读取为 object 类型Object o = superTStringList.get(0); 通配符类型参数 ? super T 表示，集合元素的类型是 T 的父类型，而不限于 T 本身，我们可以向集合中添加元素，因为集合中的元素一定是 T 的父类型，但我们不能从集合中读取元素，或者说只能读取为 object 类型的元素，因为我们不知道什么样的对象才能与 T 的未知父类型匹配。指定了 super 边界 (下边界)的通配符类型, 使得我们的类型成为一种 逆变(contravariance)。 协变；子类取代父类的位置是被允许的，也就是需要父类型时可以使用子类型代替逆变；父类取代子类的位置是被允许的，也就是需要子类型时可以使用父类型代替不变；不允许改变类型。 对于只能读取的对象，称为 生产者，因为它可以产出对象，对于只能写入的对象称为 消费者，因为它可以消费对象，生产者对应 extends，消费者对应 super。 声明处类型变异我们有如下 Box 类，它只有读取方法，也就是只能生产 T 类型对象，不存在消费者方法的调用，因此我们完全可以使用 Box&lt;Parent&gt; 存储 Box&lt;Child&gt; 的数据，这是安全的，但是在 java 中不能理解这一点。 123456789class Box&lt;T&gt; &#123; public T find()&#123; return null; &#125;&#125;public void test(Box&lt;String&gt; stringBox) &#123; Box&lt;CharSequence&gt; objectBox = stringBox; // error&#125; 为了解决上述问题，我们必须进行如下声明才能消除错误，但是使用了更加复杂的声明与上面所能调用的方法是一样的，但是编译器并不能理解这一点。 123public static void test(Box&lt;String&gt; stringBox) &#123; Box&lt;? extends CharSequence&gt; objectBox = stringBox;&#125; 在 Kotlin 中我们使用在范型声明处使用注解标注的方式将这种情况告诉编译器，由于这种注解出现在声明处，因此称为 声明处类型变异(declaration-site variance) ，这种方案与 Java 中的 使用处类型变异(use-site variance) 刚好相反, 在 Java 中, 是类型使用处的通配符产生了类型的协变。有两种注解修饰符： out 被称为 协变注解(variance annotation)，他表示此类型只能被生产，不能被消费，也就是只能出现在返回类型中，此时 Box&lt;Parent&gt; 可以安全的用作 Box&lt;Child&gt; 的父类型。 in 被称为 逆变注解(contravariant annotation)，他表示此类型只能被消费，不能被生产，也就是只能出现在参数类型中，此时可以用 Box&lt;Child&gt; 安全的接受 Box&lt;Parent&gt; 12345678910111213interface Box1&lt;out T&gt;&#123; // error，不能作为参数类型 fun testIn(t:T) // yes fun testOut(): T&#125;interface Box2&lt;in T&gt;&#123; // yes fun testIn(t:T) // error，不能作为返回类型 fun testOut(): T&#125; 那么此时我们就可以解决上面的复杂声明的问题 1234567fun test(box:Box1&lt;String&gt;)&#123; val box1:Box1&lt;CharSequence&gt; = box&#125;fun test(box:Box2&lt;CharSequence&gt;)&#123; val box2:Box2&lt;String&gt; = box&#125; 同时看一下官网 Comparable 使用逆变注解的例子 123456789abstract class Comparable&lt;in T&gt; &#123; abstract fun compareTo(other: T): Int&#125;fun demo(x: Comparable&lt;Number&gt;) &#123; x.compareTo(1.0) // 1.0 类型为 Double, 是 Number 的子类型 // 因此, 我们可以将 x 赋值给 Comparable&lt;Double&gt; 类型的变量 val y: Comparable&lt;Double&gt; = x // OK!&#125; 类型投射我们有时并不能保证范型类型只作为返回值出现，或只作为参数出现，我们通常会有更复杂的需求: 12345678class Box3&lt;T&gt; &#123; fun get(): T?&#123; return null &#125; fun set(t: T)&#123; &#125;&#125; 如果我们写一个 copy 函数 123fun copyBox(to: Box3&lt;Any&gt;, from: Box3&lt;Any&gt;) &#123; to.set(from)&#125; 由于范型参数类型的不变性，就是我们最初在 Java 中遇到的问题，下面的调用将无法通过编译，因为 Box&lt;String&gt; 并不是 Box&lt;Any&gt; 的子类，这种操作是为了避免向 from 中进行写入操作，比如 Int 类型，导致 ClassCastException。 123val from = Box3&lt;String&gt;()val to = Box3&lt;Any&gt;()copyBox(to,from) // error,required:Box3&lt;Any&gt; found:Box3&lt;String&gt; 我们需要使用 out 注解，说明我们在 copy 函数中对 from 不会进行写入操作。 1234567fun copyBox(to: Box3&lt;Any&gt;, from: Box3&lt;out Any&gt;) &#123; to.set(from)&#125;val from = Box3&lt;String&gt;()val to = Box3&lt;Any&gt;()copyBox(to,from) // ok 同理我们可以使用 in 注解来声明我们不会对对象进行读取操作，如下 1234567891011121314fun fill(dest: Box3&lt;String&gt;, value: String) &#123; // ...&#125;val dest = Box3&lt;CharSequence&gt;()fill(dest,"") // errorfun fill(dest: Box3&lt;in String&gt;, value: String) &#123; // ...&#125;val dest = Box3&lt;CharSequence&gt;()fill(dest,"") // ok 这种声明在 Kotlin 中称为 类型投射(type projection)，他用来声明该类型不是一个简单的类型，而是一个被限制的类型，我们只能对该类型进行读取或写入操作，从而保证数据的安全性，这是 Kotlin 使用处类型变异 的实现方式，与 Java 中的通配符相似，但是更简单。 星号投射星号投射（Star-projection） 有时可能想表示你并不知道类型参数的任何信息，但是仍然希望能够安全地使用它。这里所谓”安全地使用”是指，对泛型类型定义一个类型投射，要求这个泛型类型的所有的实体实例，都是这个投射的子类型。 星号投射与 Java 的原生类型(raw type)非常类似，但可以安全使用。 下面是官方的说法： 12345对于 Foo&lt;out T&gt;，其中 T 是一个具有上界 TUpper 的协变类型参数，Foo&lt;*&gt; 等价于 Foo&lt;out TUpper&gt;。 这意味着当 T 未知时，你可以安全地从 Foo&lt;*&gt; 读取 TUpper 的值。对于 Foo&lt;in T&gt;，其中 T 是一个逆变类型参数，Foo&lt;*&gt; 等价于 Foo&lt;in Nothing&gt;。 这意味着当 T 未知时，没有什么可以以安全的方式写入 Foo&lt;*&gt;。对于 Foo&lt;T&gt;，其中 T 是一个具有上界 TUpper 的不型变类型参数，Foo&lt;*&gt; 对于读取值时等价于 Foo&lt;out TUpper&gt; 而对于写值时等价于 Foo&lt;in Nothing&gt;。 在什么时候可以使用 星号投射，什么时候不可以 12345678910111213141516171819// error 不允许作为变量的的范型参数val list = ArrayList&lt;*&gt;()// error 不允许作为函数的范型参数fun &lt;T&gt; hello(args: Array&lt;T&gt;)&#123;&#125; hello&lt;*&gt;(args)// error 不允许作为父类的范型参数interface Foo&lt;T&gt; class Bar : Foo&lt;*&gt;// yes 尽管 * 不能直接作为类的泛型参数，Foo&lt;*&gt; 却可以，按照前面官方给出的说法，它在读时等价于Foo&lt;out Any&gt; 写时等价于 Foo&lt;in Nothing&gt;interface Foo&lt;T&gt; class Bar : Foo&lt;Foo&lt;*&gt;&gt; // yes 这表示接受的参数的类型在读写时分别等价于Array&lt;out Any&gt; 和 Array&lt;in Nothing&gt; fun hello(args: Array&lt;*&gt;)&#123; ... &#125; Raw 类型就是对于定义时有泛型参数要求，但在使用时指定泛型参数的情况，这个只在 Java 中有，显然也是为了前向兼容。在 Java 中我们可以如下声明 1List list = new ArrayList(); 这样的声明在 Kotlin 中是不允许的，但是可以使用 1val list = ArrayList&lt;Any?&gt;() 在 Java 中可以有这样的写法，会引发异常 123List&lt;Integer&gt; integers = new ArrayList&lt;&gt;(); List list = new ArrayList(); list = integers; 在 Kotlin 中这样的写法是错误的 123var list = ArrayList&lt;Any?&gt;() val integers = ArrayList&lt;Int&gt;() list = integers // ERROR! 范型函数函数中也可以使用范型参数类型 123456789fun &lt;T&gt; test(t:T):List&lt;T&gt;&#123; return mutableListOf(t)&#125;fun &lt;T&gt; Context.test(t:T):List&lt;T&gt;&#123; return mutableListOf(t)&#125;var testGenericFun = testGenericFun(1)var testGenericFunInContext = testGenericFunInContext(1) 范型约束约束范型的上界 如下范型参数 T 必须是 Box&lt;T&gt; 的子类 如果有多个上限，则需要使用 where 字句 如果上限的对象带有范型参数的声明处类型编译注解，则当前声明也需要同步 1234567891011class Box4&lt;T : Box&lt;T&gt;&gt; &#123;&#125;class Box5&lt;T&gt; where T : Box&lt;T&gt;, T : Cloneable &#123;&#125;class Box6&lt;out T&gt; where T : Box1&lt;T&gt;, T : Cloneable &#123;&#125; 在函数中约束范型上界 1234567fun &lt;T : Box&lt;T&gt;&gt;test1(t:T)&#123;&#125;fun &lt;T&gt; test2(t:T) where T : Box&lt;T&gt;, T : Cloneable&#123;&#125;]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin开发-7-特殊类]]></title>
    <url>%2Farticle%2Faa2c40d4%2F</url>
    <content type="text"><![CDATA[本文主要关于 Kotlin 中的特殊类，包括： 数据类：数据类的使用有诸多限制，它声明了一种数据结构，进行数据的存储。 嵌套类：相当于 java 中的静态内部类，可以直接使用外部类名创建。 内部类：相当于 java 中的内部类，需要使用外部类实例才能创建。 匿名内部类：使用 object 关键字创建的只用一次的类实现。 枚举类：比 java 更强大的枚举实现。 数据类数据类是一种特别的类，顾名思义，就是用来结构化的存放数据的类，在 Kotlin 中可以使用关键字 data 来很简单的声明一个数据类。 123data class Person(val name: String = "123", val age: Int = 123)data class User(val name: String, val age: Int) 如果在数据类中对以下函数没有明确的定义，也没有从父类中继承得到，那么数据类会自动生成这些函数，如 hashCode() 和 equals() 函数对、Person(name=c, age=3) 形式的 toString() 方法、用来访问属性址的 componentN() 函数群、用来复制对象 copy() 方法。 123456789101112// 创建数据类对象val p: Person = Person("a", 1)val p1 = Person("b", 2)// equals() &amp; hasoCode()log(p.equals(p1))// toString()log(p.toString())// componentNlog(p.component1() + " " + p.component2())// copy()，copy 的对象将会是一个全新的对象val p2 = p.copy("c", 3)log( "$&#123;p2.hashCode()&#125; $&#123;p.hashCode()&#125; $p2") 输出 1234MainActivity: falseMainActivity: Person(name=a, age=1)MainActivity: a 1MainActivity: 3072 3008 Person(name=c, age=3) 数据类应该满足以下要求： 主构造器至少有一个参数，如果需要无参构造方法，可以使用指定默认值的方式实现。 主构造器的所有参数都必须标记为 var 或 val，像 data class Use2(name: String, age: Int) 这样是不允许的。 数据类不能是 抽象类，open 类 ，封闭(sealed)类 或 内部类 数据类不能继承自其他类，但是可以实现接口。 copy 函数自动生成的 copy() 函数用来实现拷贝一个对象，同时修改部分属性，但是保留其他属性的值的功能。 自动生成的 copy() 函数将会是这样的 1fun copy(name: String = this.name, age: Int = this.age) = User(name, age) 解构数据类默认生成了 componentN() 组件函数，我们可以用如下方法快速获取数据类中属性的值 123val p: Person = Person("a", 1)val (myName,myAge) = plog("name = $myName,age = $myAge") 嵌套类类可以嵌套在另一个类中，称为 嵌套类（Nested Class），其实相当于 Java 中的静态内部类，不过在 Java 中这样什么关键字都不加的情况默认声明的是内部类，而 Kotlin 默认是嵌套类，也就是静态内部类，可以直接使用 外部类类名.嵌套类名 来访问创建嵌套类对象。 123456class OuterClass &#123; class NestedClass(val name: String)&#125;// 可以直接创建，不依赖外部类对象val nested = OuterClass.NestedClass("nest") 内部类Kotlin 中的内部类和 Java 中的内部类一样，但是 kotlin 中要用 inner 关键字声明是内部类，否则默认是嵌套类。 使用 inner 关键字声明的内部类，可以自由访问外部类成员属性，内部类会持有一个外部类的引用，指向外部类对象实例。 当属性冲突时，将优先使用内部类成员，如果想访问外部类成员可以使用带限定符的 this 表达式。 内部类是不能直接创建的，需要使用外部类对象才能创建。 12345678910111213141516171819202122232425262728293031class OuterClass &#123; class NestedClass(val name: String) val myVal = 100 val myVal1 = 100 inner class InnerClass()&#123; val myVal = 10 fun test():String&#123; // 当属性冲突时，将优先使用内部类成员 // 如果想访问外部类成员可以使用带限定符的this表达式 return "$myVal $myVal1 $&#123;this@OuterClass.myVal&#125;" &#125; &#125;// 必须依赖外部类对象才能创建val inner = OuterClass().InnerClass()``` ## 匿名内部类匿名内部类也是一个常见的用法，适用于只需要创建一次使用一次的情况，比如为控件设置监听。匿名内部类使用 `object` 关键字的对象表达式声明，其实下面中监听的设置不必这么复杂，这是最原始的版本。```kotlinmMyMsgTv.setOnClickListener(object : View.OnClickListener&#123; override fun onClick(v: View?) &#123; log("click") &#125;&#125;) 如果匿名内部类对象是只有一个抽象方法的接口，可以使用带有接口名称前缀的 lambda 表达式简化创建这个对象，简化版本： 123mMyMsgTv.setOnClickListener &#123; log("click")&#125; 枚举类创建一个简单的枚举类 123enum class EnumClass&#123; ONE,TOW,THREE&#125; 每个枚举值都是枚举类的一个实例，因此可以被初始化，需要注意的是 name 和 ordinal 是父类中已经存在的不允许被重写的属性，因此自定义的属性不能使用这些。 123enum class EnumClass2(val desc:String)&#123; ONE("one"),TOW("two"),THREE("three")&#125; 枚举可以具有自己的属性和函数，也可以重写父类中的方法 12345678910111213141516171819202122enum class EnumClass3(val desc: String) &#123; ONE("one") &#123; override fun log(): String &#123; return "one" &#125; &#125;, TOW("two") &#123; override fun log(): String &#123; return "two" &#125; &#125;, THREE("three") &#123; override fun log(): String &#123; return "three" &#125; &#125;; // 属性 val myVal = 100 // 函数 fun test() &#123;&#125; abstract fun log(): String&#125; 每个枚举都具有 name 和 ordinal 属性，并且实现了 Compaable 接口 1234567EnumClass1.ONE.nameEnumClass1.ONE.ordinal// 转化为一个枚举类对象var enumClass1:EnumClass1 = EnumClass1.valueOf("one")// 枚举类对象列表var values:Array&lt;EnumClass1&gt; = EnumClass1.values()]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin开发-6-扩展]]></title>
    <url>%2Farticle%2Fd0378250%2F</url>
    <content type="text"><![CDATA[本文主要介绍 Kotlin 扩展 ( Extension )的相关内容。 以下翻译自官方文档： 与 C# 和 Gosu 类似， Kotlin 提供了向一个类扩展新功能的能力， 而且不必从这个类继承，也不必使用任何设计模式， 比如 Decorator 模式之类。 这种功能是通过一种特殊的声明来实现的， Kotlin 中称为 扩展(extension)。Kotlin 支持 扩展函数(extension function) 和 扩展属性(extension property)。 扩展 是很多高级语言都具备的特性，使用扩展可以在不侵入原来类的基础上扩展新的功能，比如我们常用的 Utils 方法，就可以完全使用扩展方法来替代。 扩展函数扩展函数需要声明在top-level 级别下，如果声明在一个类里面，那么只能在这个类内使用，也就失去了扩展的意义。我开始写的时候因为写 java 的惯性，就声明在类里面，结果别的地方根本用不了，一度十分怀疑扩展存在的意义。。。 声明的方式与普通函数稍有不同，在函数名前面要使用扩展的接收者，扩展的接收者就是我们要扩展的对象，如下： 123fun 扩展接收者.函数名:返回类型(参数列表)&#123; 函数体&#125; 先来声明两个扩展函数看看效果 1234567891011// ExtensionTest.ktfun Context.extensionLog(msg: String) &#123; Log.e(this.javaClass.simpleName, msg)&#125;fun &lt;E&gt;MutableList&lt;E&gt;.swap(index1:Int,index2:Int)&#123; val temp = this[index1] this[index1] = this[index2] this[index2] = temp&#125; 在 MainActivity.kt 中使用它们 123456extensionLog("测试扩展函数")val list = mutableListOf("str1","str2")extensionLog(list.toString())list.swap(0,1)extensionLog(list.toString()) 输出结果： 123com.march.ktexample E/MainActivity: 测试扩展函数com.march.ktexample E/MainActivity: [str1, str2]com.march.ktexample E/MainActivity: [str2, str1] 总结一下： 扩展函数的声明对子类是有效的， 比如我们给 Context 类扩展，那么 Context 所有子类都可以使用扩展函数，扩展虽然不是继承，但是却具有和继承类似的效果。 在扩展函数中可以使用 this 关键字，访问当前扩展接收者对象。 扩展函数的静态解析扩展函数并不是真的给扩展接收者的类增加了新的方法，他只是创建了一个新的函数，并且可以让扩展接收者的类使用点号的形式去调用而已，对原来的类本身没有任何影响。 扩展函数的调用派发过程是静态的，这就意味着，调用扩展函数时，具体被调用的函数是哪一个，是通过调用函数的对象表达式的类型来决定的，而不是在运行时刻表达式动态计算的最终结果类型决定的。也就是说如果有多个扩展调用，那么调用哪一个取决于你使用哪种类型去调用。 12345678910111213141516171819202122232425open class Aclass B : A()fun A.extension(): String &#123; return "a的扩展"&#125;fun B.extension(): String &#123; return "b的扩展"&#125;// 一个普通的函数，扩展函数的实际调用由调用他的类决定// 因此这里不管传什么类型的值，都会是调用 A 的扩展函数fun printExtension(a:A)&#123; extensionLog(a.extension())&#125;// 调用 A 的扩展extensionLog(A().extension())// 调用 B 的扩展extensionLog(B().extension())// 调用 A 的扩展printExtension(A())// 调用 A 的扩展printExtension(B()) 输出结果 1234com.march.ktexample E/MainActivity: a的扩展com.march.ktexample E/MainActivity: b的扩展com.march.ktexample E/MainActivity: a的扩展com.march.ktexample E/MainActivity: a的扩展 成员函数优先当扩展函数和成员函数都存在时，相同的函数是说函数名与参数列表都相同，优先使用成员函数。 123456789101112131415161718192021// B 有成员函数class B &#123; fun extension(): String &#123; return "b的成员" &#125;&#125;// B 有扩展函数fun B.extension(): String &#123; return "b的扩展"&#125;// 将优先使用成员函数fun printExtension(b:B)&#123; extensionLog(b.extension())&#125;printExtension(B())结果：com.march.ktexample E/MainActivity: b的成员 可为空的接收者使用可为空的类型作为扩展接收者时，即使调用的对象为空仍然可以调用，不会空指针，可以在扩展方法内检测接受者是不是为空。 12345// 可为空的接收者fun String?.testNullableReceiver():String&#123; if(this == null) return "I am null" return "I am not null $&#123;toString()&#125;"&#125; 再看一下，可空类型的 toString() 方法 123456fun Any?.toString(): String &#123; if (this == null) return "null" // 进行过 null 检查后, 'this' 会被自动转换为非 null 类型, 因此下面的 toString() 方法 // 会被解析为 Any 类的成员函数 return toString()&#125; 测试 1234567891011val strNull1:String? = nullval strNull2:String? = "strNull2 "val strNoNull:String = "strNoNull "extensionLog(strNull1.testNullableReceiver())extensionLog(strNull2.testNullableReceiver())extensionLog(strNoNull.testNullableReceiver())// 结果com.march.ktexample E/MainActivity: I am nullcom.march.ktexample E/MainActivity: I am not null strNull2 com.march.ktexample E/MainActivity: I am not null strNoNull 扩展属性扩展属性并不真的是类的成员，他不能更改类的内容，因此扩展属性不支持 backing-field，因此没办法使用 set() 为属性赋值。 扩展属性不能使用 初始化器 为属性赋值 123456789101112131415var Context.extensionProperty: String get() &#123; return "$&#123;javaClass.simpleName&#125; properties = " &#125; // ⚠️ 这样是错误的，没有backing-field支持，这里将会StackOverflow set(value) &#123; extensionProperty = value &#125;// 错误，不允许初始化器val Context.testValue1:Int = 100// 一个正确的示范val &lt;T&gt; List&lt;T&gt;.lastIndex: Int get() = size - 1 扩展同伴对象12345678910111213141516171819class MainActivity : Activity() &#123; companion object MyCompanion &#123; &#125;&#125;// 扩展函数fun MainActivity.MyCompanion.testCompanionFunc(): String &#123; return "testCompanionFunc"&#125;// 扩展属性val MainActivity.MyCompanion.testCompanionProperty get() = "testCompanionProperty" extensionLog(MainActivity.MyCompanion.testCompanionFunc())extensionLog(MainActivity.MyCompanion.testCompanionProperty) 声明扩展为成员以下翻译自官方文档：在类的内部，你可以为另一个类定义扩展。在这类扩展中，存在多个 隐含接受者(implicit receiver) - 这些隐含接收者的成员可以不使用限定符直接访问。扩展方法的定义所在的类的实例，称为 派发接受者(dispatch receiver)， 扩展方法的目标类型的实例，称为 扩展接受者(extension receiver)。 也就是说我们可以在一个类 BB 内部声明另一个类 AA 的扩展，AA 是扩展接受者，BB 是派发接受者，此时存在多个接受者，在 AA 的扩展方法中，可以自由的不使用限定符的访问 AA 和 BB 的成员。 1234567891011121314151617class AA &#123; fun funcInAA(): String &#123; return "func in AA" &#125;&#125;class BB &#123; fun funcInBB(): String &#123; return "func in BB" &#125; fun AA.extendAAFuncInBB(): String &#123; return "extendAAFuncInBB" + funcInBB() + funcInAA() &#125; fun testFunc(aa: AA): String &#123; return aa.extendAAFuncInBB() &#125;&#125; 当派发接受者与扩展接受者的成员名称发生冲突时，扩展接受者的成员将会被优先使用。 如果想要使用派发接受者的成员，需要使用 this 关键字 123456789class BB &#123; fun AA.testToString()&#123; // 默认使用 AA.toString() toString() // 使用 BB.toString() this@BB.toString() &#125;&#125; 扩展函数可以在子类中被覆盖，这类扩展函数在派发过程中针对派发接受者是虚拟的，针对扩展接受者是静态的。 前面说过，扩展的解析是静态的，使用哪个扩展取决于调用他的是哪个类型的类对象，但是派发接受者是虚拟的是说，他将使用子类中更具体的实现。 看一个官网的例子，下面的 caller(d:D) 方法接收的是 D 类型的对象，此时调用扩展函数时，不管你传递什么类型的值(D 或 D 的子类对象)，都会调用 D 的扩展函数，因为扩展接受者的解析是静态的， 所以所有的打印结果都是 D.foo ；但是派发接受者的解析是虚拟的，所以 C1().caller() 将使用子类中更具体的实现，C1 对扩展函数进行了重载，因此会使用 C1 重载后的 caller() 打印出 in C1。 123456789101112131415161718192021222324252627282930313233open class D &#123;&#125;class D1 : D() &#123;&#125;open class C &#123; open fun D.foo() &#123; println("D.foo in C") &#125; open fun D1.foo() &#123; println("D1.foo in C") &#125; fun caller(d: D) &#123; d.foo() // 调用扩展函数 &#125;&#125;class C1 : C() &#123; override fun D.foo() &#123; println("D.foo in C1") &#125; override fun D1.foo() &#123; println("D1.foo in C1") &#125;&#125;C().caller(D()) // 打印结果为 "D.foo in C"C1().caller(D()) // 打印结果为 "D.foo in C1" - 派发接受者的解析过程是虚拟的C().caller(D1()) // 打印结果为 "D.foo in C" - 扩展接受者的解析过程是静态的 总结扩展声明在 top-level 才能在所有地方都可以使用。 扩展函数的声明对子类是有效的，我们扩展父类，子类也会有这些扩展。 在扩展函数中可以使用 this 关键字，访问当前扩展接收者对象。 扩展的的接受者可以为空，不会 NPE。 成员函数和扩展函数冲突时，成员函数优先。 扩展接受者的解析是静态的，将会使用哪个扩展取决于调用的类的类型，也就是说类型确定了，使用的方法就确定了，并不在乎实际上是什么类型，比如我参数是 d:D，就决定了是 D 类型的扩展方法，传它的子类 D1:D 类型也不会改变。 派发接受者的解析是虚拟的，将会使用哪个扩展取决于调用的类的实际的类型，将会使用当前实际类型重载的方法，比如我参数是 d:D，但我传它的子类 D1:D 类型则会使用 D1 中对扩展的重载。]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android使用CMAKE编译libjpeg-turbo]]></title>
    <url>%2Farticle%2Ffc67caea%2F</url>
    <content type="text"><![CDATA[本文主要介绍使用 CMAKE 编译 libjpeg-turbo 类库，本文相关代码请在GitHub-TurboJpegSample 查看。 libjpeg-turbo 附 GitHub 地址，libjpeg-turbo 是个运用极其广泛的库，可以说，基本上电脑上手机上能见到的 JPEG 压缩的地方用的一般都是 libjpeg-turbo，本文只介绍使用了图片压缩的功能。 使用 Android 保存图片时，我们通常使用的是 Bitmap.compress() 方法，但是使用该方法时，就算 quality 设置为 100，图片质量还是会越来越模糊，颜色也会越来越绿～，至于为什么会这样，请看 知乎回答。 这个问题在贴吧上体现尤为明显，贴吧里面经常很多绿绿的图片就是因为大家保存下来上传上去，保存下来上传上去 … 导致质量越拉越低，我解压了 美图秀秀 和 in 的 apk 发现里面都引用了 libjpeg.so，所以这个应该是一个比较通用的解决方案。 我们对图片使用质量压缩时它的底层就是用 skia 引擎进行处理，如我们调用bitmap.compress(Bitmap.CompressFormat.JPEG...) 他实际会 使用一个libjpeg.so 的动态库进行编码压缩。android 在进行 jpeg 压缩编码的时候，考虑到了效率问题使用了定长编码方式进行编码（因为当时的手机性能都比较低），而 ios 使用了变长编码的算法——哈夫曼算法。而且 IOS 对 skia 引擎也做了优化，所以我们看到同样的图片在 ios 上压缩会好一点。 文档就整理到这里吧，其实上面说的都是看了一些博客的介绍然后进行了整理和记录，来清楚为什么我们需要自己来编译 so 实现图片压缩。 资源准备我们需要下载源码编译出 libjpeg.so 来使用，clone 源代码。 1git clone git://git.linaro.org/people/tomgall/libjpeg-turbo/libjpeg-turbo.git -b linaro-android 重命名根目录 libjpeg-turbo 为 jni，进入 jni 目录，首先你应该配置好 ndk， 使用 ndk-build 命令进行编译。 1234mv libjpeg-turbo jnindk-build APP_ABI=armeabi-v7a,armeabi 编译完成之后我们就可以获取到 libjpeg.so，目录如下： 12345678910jnilibs - armeabi - libjpeg.so - armeabi-v7a - libjpeg.soobj - local - armeabi - armeabi-v7a 此时如果出现了以下异常： 12Users/march/AndroidRes/sdk/ndk-bundle/build/core/build-binary.mk:702: *** Android NDK: Aborting (set APP_ALLOW_MISSING_DEPS=true to allow missing dependencies) . Stop. 打开 build-binary.mk 添加 APP_ALLOW_MISSING_DEPS=true 123456789101112131415161718ifdef undefined_libs $(call __ndk_warning,Module $(LOCAL_MODULE) depends on undefined modules: $(undefined_libs)) # https://github.com/android-ndk/ndk/issues/208 # ndk-build didn't used to fail the build for a missing dependency. This # seems to have always been the behavior, so there's a good chance that # there are builds out there that depend on this behavior (as of right now, # anything using libc++ on ARM has this problem because of libunwind). # # By default we will abort in this situation because this is so completely # broken. A user may define APP_ALLOW_MISSING_DEPS to "true" in their # Application.mk or on the command line to revert to the old, broken # behavior. APP_ALLOW_MISSING_DEPS=true # here ifneq ($(APP_ALLOW_MISSING_DEPS),true) $(call __ndk_error,Aborting (set APP_ALLOW_MISSING_DEPS=true to allow missing dependencies)) endifendif 创建工程使用 AndroidStudio 新建工程，勾选 support c++，生成的工程中会包含 CMakeLists.txt 文件，在下面的介绍中没有截图，对目录的说明如果不够清晰，请至 GitHub-TurboJpegSample 查看工程代码。 在 app 目录下新建文件夹 libjpeg，用来存放 so 文件和头文件，目录如下： 123456789101112app - libjpeg - prebuilt - armeabi - libjpeg.so - include - 头文件 - src - main - cpp - java - res 编写 compress.h 和 compress.c，这个就是压缩的核心代码了，篇幅较长，但是这里就不贴了，详情请查看 项目的 cpp 目录，使用的算法是网上查找的，看起来资料介绍的都是这一种。 CMakeLists.txt12345678910111213141516171819202122232425262728293031# 最低版本cmake_minimum_required(VERSION 3.4.1)#设置生成的 so 动态库最后输出的路径set(CMAKE_LIBRARY_OUTPUT_DIRECTORY $&#123;PROJECT_SOURCE_DIR&#125;/../jniLibs/$&#123;ANDROID_ABI&#125;)# 初始化目录变量set(libjpeg_dir $&#123;CMAKE_SOURCE_DIR&#125;/libjpeg)set(INC_DIR $&#123;libjpeg_dir&#125;/include)set(libjpeg_lib_dir $&#123;libjpeg_dir&#125;/prebuilt)# 添加头文件目录include_directories($&#123;INC_DIR&#125;)# 设置资源路径set(SOURCE_FILES src/main/cpp/compress.c)# add_library(compress SHARED $&#123;SOURCE_FILES&#125;)find_library(log-lib log)find_library(graphics jnigraphics)add_library(libjpeg SHARED IMPORTED)set_target_properties(libjpeg PROPERTIES IMPORTED_LOCATION $&#123;libjpeg_lib_dir&#125;/$&#123;ANDROID_ABI&#125;/libjpeg.so)target_link_libraries(compress libjpeg $&#123;log-lib&#125; $&#123;graphics&#125;) build.gradle相比普通的 Android 工程，app/build.gradle 文件也有些许不同，我只编译了 armeabi 。 123456789101112131415161718192021222324252627282930313233343536373839android &#123; compileSdkVersion 25 buildToolsVersion "25.0.3" defaultConfig &#123; ... externalNativeBuild &#123; cmake &#123; abiFilters 'armeabi' &#125; &#125; ndk &#123; //打包进APK的ABI类型 abiFilters 'armeabi' &#125; &#125; externalNativeBuild &#123; cmake &#123; path "CMakeLists.txt" &#125; &#125; sourceSets &#123; main &#123; java.srcDirs 'src/java' jniLibs.srcDirs 'libs'// jniLibs.srcDirs '../libjpeg/prebuilt', 'libs' // 这里没有添加libjpeg.so这个动态库，也是可以执行的。 // 原因在于android本身使用了 libjpeg.so这个动态库， // 这个库存放在/system/lib下，如果我们没有加入 // libjpeg.so的话，他会去/system/lib下加载这个动态库 // 如果android手机上没有 libjpeg.so这个动态库的话， // 也可以使用: jniLibs.srcDirs '../libjpeg/prebuilt' 'libcd // 将libjpeg.so加入到apk中 &#125; &#125;&#125; 编写 java 调用123456789101112131415161718public class TurboJpegUtils &#123; static &#123; System.loadLibrary("compress"); &#125; /** * 使用native方法进行图片压缩。 * Bitmap的格式必须是ARGB_8888 &#123;@link android.graphics.Bitmap.Config&#125;。 * * @param bitmap 图片数据 * @param quality 压缩质量 * @param dstFile 压缩后存放的路径 * @param optimize 是否使用哈夫曼算法 * @return 结果 */ public static native int compress(Bitmap bitmap, int quality, String dstFile, boolean optimize);&#125; 运行之后就可以测试结果，同时在 配置的 jniLibs 目录中也会生成 so 文件，在别的地方使用同包名下的 TurboJpegUtils 类也可以调用了。 总结测试对比结果，确实比 Andorid 原生的算法压缩图片的效果好很多，但是压缩次数多了以后也会有明显的模糊现象。]]></content>
      <categories>
        <category>Android</category>
        <category>Ndk</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Ndk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 超轻量级路由方案 [开源]]]></title>
    <url>%2Farticle%2F327200%2F</url>
    <content type="text"><![CDATA[本文主要介绍 Android 轻量级路由方案 的实现过程； 什么是路由协议？路由协议就是约定一套路径解析的规则，然后大家都遵循这个规则来进行页面跳转，从而达到动态和解耦的目的。 路由的存在有什么意义？ 多模块，组件化，插件化开发时，使用路由进行解耦，组件之间遵循约定好的路由协议进行跳转，不再需要互相依赖。 混合开发时，Web 端使用约定好的路由路径，可以方便跳转 app 内各个页面并进行参数传递。 在 GitHub 上已经有很多相当成熟的路由框架，他们支持编译时注解路径，支持隐式跳转，支持跳转到 Fragment，支持自定义解析等等… 可以说非常强大了。。 那我为啥还要自己写？主要还是因为，我们要知其然(知道轮子怎么用)，知其所以然(知道轮子怎么造)。另外虽然我写的功能不如那些框架强大，但是也更轻量，完成路由的生成、解析和跳转，大约只有 300 行代码，用来完成简单的路由需求也是不错的选择。 我并没有给这个功能单独创建一个工程，因为他太轻量了，我把他集成在了我常用开发库中，本文相关的源代码可以在 GitHub-DevKitSample 中查看。 总的来说这个路由方案的核心的原理就是对路径进行解析，然后生成 intent，设置参数，进行页面跳转，同时又要支持使用参数，配置生成跳转的路由路径，感谢强大的 Uri，简化了我很多解析的过程。 路由协议一个路由路径应该有 Scheme、Authority、Path、QueryParam 几部分组成，他们以下面的形式组装。 1Scheme://Authority/Path?QueryParam 比如下面的 https 协议的路径，Scheme 就是 https，Authority 就是 www.baidu.com，Path 就是 test/list，QueryParam 以 key=value 的形式表现，如 id=100。 1https://www.baidu.com/test/list?id=100&amp;key=value 因此我们可以定制自己的协议，作为应用内跳转的解析方式，比如定义下面的协议： 1chendong://test.march.com/page/1?id=100 定制协议我们在 Android 中进行数据传递时需要知道参数的类型，而这些仅仅靠字符串的路径是无法表达的，因此我们需要对 QueryParam 的声明形式进行如下约定，在 QueryParam 的 key 中需要表达数据的类型。 int long boolean float double String Object i-key l-key b-key f-key d-key s-key o-key 那么我们就会有如下的一个路径，参数仍然是 key-value 的形式，只不过 key 的写法我们是有约定要求的。 1chendong://testJs.march.com/page/1?i-iKey=10&amp;f-fKey=1.25&amp;l-lKey=10000000000&amp;d-dKey=1.23456789&amp;b-bKey=true&amp;s-sKey=test 当路径为 /page/pageId 这种路径时表示是一个页面跳转，其中 pageId 为页面的唯一标示，至于 pageId 和页面的唯一映射，需要提前配置起来，我们会存储以下两个映射 map。 1234// 存储 pageId - Activity.class 的映射private Map&lt;Integer,Class&gt; pageMap = new HashMap&lt;&gt;();// 存储 Activity.class - pageId 的映射private Map&lt;Class, Integer&gt; classMap = new HashMap&lt;&gt;(); 解析 pageId首先将路径转换为 Uri 1Uri uri = Uri.parse(url); 接下来我们需要进行 pageId 的解析，我们只有获取到 pageId 才能确认跳转的是哪个页面，使用正则来进行解析。 12345678910111213141516// 解析 pageIdprivate static int parsePageId(Uri uri) &#123; int pageId = -1; String path = uri.getPath(); if (path.startsWith(PATH_PAGE)) &#123; Pattern compile = Pattern.compile("/page/([0-9]*$)"); Matcher matcher = compile.matcher(path); if (matcher.find()) &#123; pageId = Integer.parseInt(matcher.group(1)); &#125; &#125; return pageId;&#125;// 根据映射拿到跳转界面的 classClass pageCls = sRouterConfig.pageMap.get(parsePageId(uri)); 解析传递的参数声明以下几种数据类型的标示 123456private static final String TYPE_I = "i";private static final String TYPE_L = "l";private static final String TYPE_B = "b";private static final String TYPE_F = "f";private static final String TYPE_D = "d";private static final String TYPE_S = "s"; 定义一个数据类型，除了存储 key-value，我们还需要将数据的类型分离出来存储 12345678910private static class Param &#123; String type; // 类型，i,l,b,f,d,s String key; String value; Param(String type, String key, String value) &#123; this.type = type; this.key = key; this.value = value; &#125;&#125; 解析参数，使用 Uri 的几个 api 和简单的正则，将 type，key，value 三部分分离出来存储起来，so easy ~ 1234567891011121314151617181920// 解析参数private static List&lt;Param&gt; parseParams(Uri uri) &#123; Set&lt;String&gt; keySets = uri.getQueryParameterNames(); List&lt;Param&gt; params = new ArrayList&lt;&gt;(); Param param; Pattern compile = Pattern.compile("(\\b[ilbfds])-(.*)"); for (String queryKey : keySets) &#123; String queryValue = uri.getQueryParameter(queryKey); Matcher matcher = compile.matcher(queryKey); if (matcher.find()) &#123; String type = matcher.group(1); String key = matcher.group(2); if (!TextUtils.isEmpty(type) &amp;&amp; !TextUtils.isEmpty(key)) &#123; param = new Param(type, key, queryValue); params.add(param); &#125; &#125; &#125; return params;&#125; 构建跳转的 intent我们已经拿到了想要跳转的界面，直接创建跳转的 intent 123// find classClass pageCls = sRouterConfig.pageMap.get(parsePageId(uri));Intent intent = new Intent(context, pageCls); 向 intent 中添加传递的参数 1234567891011121314151617181920212223242526272829// parse paramsList&lt;Param&gt; params = parseParams(uri);for (Param param : params) &#123; putExtra(intent, param);&#125;// 向 intent 根据类型输入参数private static void putExtra(Intent intent, Param param) &#123; switch (param.type) &#123; case TYPE_I: intent.putExtra(param.key, Integer.parseInt(param.value)); break; case TYPE_L: intent.putExtra(param.key, Long.parseLong(param.value)); break; case TYPE_B: intent.putExtra(param.key, Boolean.parseBoolean(param.value)); break; case TYPE_F: intent.putExtra(param.key, Float.parseFloat(param.value)); break; case TYPE_D: intent.putExtra(param.key, Double.parseDouble(param.value)); break; case TYPE_S: intent.putExtra(param.key, param.value); break; &#125;&#125; 进行页面跳转，兼容了一下 startActivityForResult() 的情况。 1234567891011121314// 启动 activityprivate static void startActivity(Context context, int reqCode, Class pageCls, List&lt;Param&gt; params) Intent intent = new Intent(context, pageCls); for (Param param : params) &#123; putExtra(intent, param); &#125; if (reqCode == -1) &#123; context.startActivity(intent); &#125; else if (context instanceof Activity) &#123; ((Activity) context).startActivityForResult(intent, reqCode); &#125; else &#123; context.startActivity(intent); &#125;&#125; 展示一下完整的流程 12345678910111213141516171819public static boolean goFrom(Context context, String url, int reqCode) &#123; try &#123; Uri uri = Uri.parse(url); if (checkSchemeAuthority(uri)) return false; // find class Class pageCls = sRouterConfig.pageMap.get(parsePageId(uri)); if (pageCls == null) &#123; return false; &#125; // parse params List&lt;Param&gt; params = parseParams(uri); startActivity(context, reqCode, pageCls, params); &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; return true;&#125; 生成跳转的路由路径我们支持使用路由路径跳转的同时，也要支持配置参数生成跳转的路由路径。同样借助 Uri 的相关 api，这个操作并不困难。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// url 构建器public static class RouterUrlBuilder &#123; private final Uri.Builder uriBuilder; RouterUrlBuilder(String scheme, String authority, int pageId) &#123; uriBuilder = new Uri.Builder() .scheme(scheme) .authority(authority) .path(PATH_PAGE + pageId); &#125; public RouterUrlBuilder put(String key, int value) &#123; uriBuilder.appendQueryParameter(TYPE_I + SEPARATOR + key, String.valueOf(value)); return this; &#125; public RouterUrlBuilder put(String key, long value) &#123; uriBuilder.appendQueryParameter(TYPE_L + SEPARATOR + key, String.valueOf(value)); return this; &#125; public RouterUrlBuilder put(String key, boolean value) &#123; uriBuilder.appendQueryParameter(TYPE_B + SEPARATOR + key, String.valueOf(value)); return this; &#125; public RouterUrlBuilder put(String key, float value) &#123; uriBuilder.appendQueryParameter(TYPE_F + SEPARATOR + key, String.valueOf(value)); return this; &#125; public RouterUrlBuilder put(String key, double value) &#123; uriBuilder.appendQueryParameter(TYPE_D + SEPARATOR + key, String.valueOf(value)); return this; &#125; public RouterUrlBuilder put(String key, String value) &#123; uriBuilder.appendQueryParameter(TYPE_S + SEPARATOR + key, value); return this; &#125; public String build() &#123; return uriBuilder.build().toString(); &#125;&#125; 我们需要使用 Router 中配置的 Scheme、Authority 和页面映射。 1234567public static RouterUrlBuilder newRouterUrlBuilder(Class targetActivity) &#123; if (sRouterConfig == null || !sRouterConfig.isSchemeAndAuthoritySet()) &#123; throw new IllegalArgumentException("set scheme and authority first"); &#125; return new RouterUrlBuilder(sRouterConfig.scheme, sRouterConfig.authority, sRouterConfig.classMap.get(targetActivity));&#125; 然后我们可以这样配置传递的参数 123456String url = Router.newRouterUrlBuilder(HomeActivity.class) .put("iKey", 10) .put("sKey1", "ss=ss") .put("sKey2", "ss=s&amp;s") .put("sKey3", "ss&amp;ss") .build(); Usage配置 Scheme、Authority 和页面映射 1234new Router.RouterConfig("chendong", "testJs.march.com") .add(1, JBTestActivity.class) .add(2, HomeActivity.class) .apply(); 根据路径跳转 12String url = "chendong://testJs.march.com/page/1?i-iKey=10&amp;f-fKey=1.25&amp;l-lKey=10000000000&amp;d-dKey=1.23456789&amp;b-bKey=true&amp;s-sKey=test";Router.goFrom(mActivity, url); 生成路由路径 123456String jumpUrl = Router.newRouterUrlBuilder(HomeActivity.class)s .put("iKey", 10) .put("sKey1", "ss=ss") .put("sKey2", "ss=s&amp;s") .put("sKey3", "ss&amp;ss") .build(); 我们可以在 html 页面中使用路由路径进行 app 内页面跳转 1&lt;a href="chendong://testJs.march.com/page/2?i-id=10&amp;s-name"&gt; 打开首页 &lt;/a&gt; 截断路径进行跳转 123456789mWebView.setWebViewClient(new WebViewClient() &#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; if (!Router.goFrom(mContext, url)) &#123; mWebView.loadUrl(url); &#125; return true; &#125;&#125;); todo现在只是简化的版本，支持基本的功能，需要完善和验证的地方还有很多。 我把他集成在了我常用开发库中，本文相关的源代码可以在 GitHub-DevKitSample 中查看。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rxjava2.x开发-5-操作符-变换]]></title>
    <url>%2Farticle%2Fcc39cbd0%2F</url>
    <content type="text"><![CDATA[本文以 Observable 为例，主要总结 RxJava2.x 关于 变换 操作相关操作符的用法。 Buffer收集 Observable 的数据放进一个数据包裹，然后发射这些数据包裹，而不是一次发射一个值。Buffer 操作符将一个 Observable 变换为另一个，原来的Observable 正常发射数据，变换产生的 Observable 发射这些数据的缓存集合。 注意：如果原来的 Observable 发射了一个 onError 通知，Buffer 会立即传递这个通知，而不是首先发射缓存的数据，即使在这之前缓存中包含了原始Observable 发射的数据。 我们创建一个 Observable 用来发送 0 ～ 49 的50个整数值，如下： 12345List&lt;Integer&gt; integers = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 50; i++) &#123; integers.add(i);&#125;Observable&lt;Integer&gt; observable = Observable.fromIterable(integers); buffer(count[,skip][,bufferSupplier])123observable .buffer(10) .subscribe(new MyObserver&lt;List&lt;Integer&gt;&gt;("buffer1"));]]></content>
      <categories>
        <category>Android</category>
        <category>Library</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RxJava2.x</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rxjava2.x开发-4-操作符-创建]]></title>
    <url>%2Farticle%2F6cad82c9%2F</url>
    <content type="text"><![CDATA[本文以 Observable 为例，本文主要总结 RxJava2.x 关于 创建 操作相关操作符的用法。 CreateCreate 是最基本的创建操作符，他用来创建一个标准的被观察者，然后恰当的调用观察者的 onNext，onError 和 onCompleted 方法。 一个形式正确的有限 Observable 必须尝试调用观察者的 onCompleted 正好一次或者它的 onError 正好一次，而且此后不能再调用观察者的任何其它方法。 好的做法是在数据发射之前判断观察者的状态，在没有观察者时不进行事件发送和计算操作。Create 操作符不在任何线程调度器上执行。 123456789Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; if(!e.isDisposed()) &#123; e.onNext(1); e.onComplete(); &#125; &#125;&#125;); JustJust 类似于 From，但是 From 会将数组或 Iterable 的数据取出然后逐个发射，而 Just 只是简单的原样发射，将数组或 Iterable 当做单个数据，如下情况，将会直接发送一个 List 出去，而不是里面的数字 0; 123List&lt;Integer&gt; integers = new ArrayList&lt;&gt;();integers.add(0);Observable.just(integers); Just 它最多接受 10 个参数，返回一个按参数列表顺序发射这些数据的 Observable。从 RxJava2.x 开始，使用 just 不允许传递 null，否则会出现异常(NPE) 12345678Observable.just(0);Observable.just(0, 1);Observable.just(0, 1, 2, 3, 4, 5, 6, 7, 8, 9) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer o) throws Exception &#123; &#125; &#125;); From在 RxJava1.x 时，只有一个 From 操作符，接受不同类型的参数，但是在 RxJava2.x 对这个操作符进行了细分。 fromIterable 和 fromArrayfrom 操作符可以转换 数组 和 Iterable，产生的 Observable 会发射 数组 和 Iterable 的每一项数据。 123List&lt;Integer&gt; integers = new ArrayList&lt;&gt;();integers.add(0);Observable.fromIterable(integers); 123int[] array = new int[]&#123;1,2,3&#125;;Observable.fromArray(array);Observable.fromArray(1,2,3); fromCallable 和 fromFuturetodo… Callable 和 Future 都是 java.util.concurrent 包里面的类，具体使用方法暂时不清楚，后面补充。 fromCallable() 返回的是 onNext 传递的数据，fromCallable() 获取要发送的数据的代码只会在有 Observer 订阅之后执行，且获取数据的代码可以在子线程中执行。 123456Observable.fromCallable(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; return 100 + 2; &#125;&#125;); 1234public static &lt;T&gt; Observable&lt;T&gt; fromFuture(Future&lt;? extends T&gt; future)public static &lt;T&gt; Observable&lt;T&gt; fromFuture(Future&lt;? extends T&gt; future, long timeout, TimeUnit unit)public static &lt;T&gt; Observable&lt;T&gt; fromFuture(Future&lt;? extends T&gt; future, long timeout, TimeUnit unit)public static &lt;T&gt; Observable&lt;T&gt; fromFuture(Future&lt;? extends T&gt; future, long timeout, TimeUnit unit, Scheduler scheduler) fromPublishertodo…暂时不是很清楚它的用法， 但是 Flowable 实现了 Publisher 接口，可以使用该方法将 Flowable 转换为 Observable 123456Flowable&lt;Integer&gt; integerFlowable = Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull FlowableEmitter&lt;Integer&gt; e) throws Exception &#123; &#125;&#125;, BackpressureStrategy.BUFFER);Observable.fromPublisher(integerFlowable); Defer直到有观察者订阅时才创建 Observable，并且为每个观察者创建一个新的Observable。 Defer 操作符会一直等待直到有观察者订阅它，然后它使用 Observable 工厂方法生成一个 Observable。它对每个观察者都这样做，因此尽管每个订阅者都以为自己订阅的是同一个 Observable，事实上每个订阅者获取的是它们自己的单独的数据序列。 123456789101112131415Observable&lt;Object&gt; defer = Observable.defer(new Callable&lt;ObservableSource&lt;?&gt;&gt;() &#123; @Override public ObservableSource&lt;?&gt; call() throws Exception &#123; return Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exceptio RxHelper.log("发射数据 --&gt; " + hashCode()); e.onNext(1); e.onComplete(); &#125; &#125;); &#125;&#125;);defer.subscribe(new MyObserver&lt;&gt;());defer.subscribe(new MyObserver&lt;&gt;()); Empty/Never/Throwempty 创建一个不发射任何数据但是正常终止的 Observable; never 创建一个不发射数据也不终止的 Observable; throw 创建一个不发射数据以一个错误终止的 Observable; 1234567891011Observable.empty();Observable.never();Observable.error(new Callable&lt;Throwable&gt;() &#123; @Override public Throwable call() throws Exception &#123; return new RuntimeException("test"); &#125;&#125;);Observable.error(new RuntimeException("test")); Interval 和 Range默认在 computation 调度器上执行，你也可以传递一个可选的Scheduler 参数来指定调度器。 intervalinterval 返回一个以固定时间间隔发送无限递增的 Long 型数列的 Observable。 12345678public static Observable&lt;Long&gt; interval(long period, TimeUnit unit)public static Observable&lt;Long&gt; interval(long initialDelay, long period, TimeUnit unit)public static Observable&lt;Long&gt; interval(long period, TimeUnit unit, Scheduler scheduler)public static Observable&lt;Long&gt; interval(long initialDelay, long period, TimeUnit unit, Scheduler scheduler)// 延迟 1s，间隔 100ms，发送无限增长的 Long 型数列Observable.interval(1, 100, TimeUnit.MILLISECONDS) .subscribe(new MyObserver&lt;Long&gt;("interval")); intervalRangeintervalRange 类似于 interval，但是它可以指定起始数值，而且不再是一个无限数列，需要注意的是，假设起始值为 start = a，count = b，即为从 start 开始，发送 count 个数据，那么发送的区间是 [a,a+b)，左闭右开，例如 start = 100，count = 120，区间是 [100,220)，即 100 ～ 219，另外 count 不能为负数，否则会异常。 123456public static Observable&lt;Long&gt; intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit)public static Observable&lt;Long&gt; intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit, Scheduler scheduler)// 延迟 1s，间隔 100ms，发送从100 开始的递增数列，发送的区间是 [100,100+120)Observable.intervalRange(100, 120, 1, 100, TimeUnit.MILLISECONDS) .subscribe(new MyObserver&lt;Long&gt;("intervalRange")); range 和 rangeLong从 start 开始发送 count 个数据，区间为 [start,start+count) 123Observable.range(100,50).subscribe(new MyObserver&lt;Integer&gt;("range"));Observable.rangeLong(100,50).subscribe(new MyObserver&lt;Long&gt;("rangeLong")); Repeatrepeat 默认在 trampoline 调度器执行。 repeat重复发送 Observable 的数据，如果不指定数目，将会无限发送。 12345Observable.just(1).repeat(10) .subscribe(new MyObserver&lt;Integer&gt;("repeat1")); Observable.just(1).repeat() .subscribe(new MyObserver&lt;Integer&gt;("repeat2")); repeatWhentodo…对这个运算符不是很清楚它的作用 它不是缓存和重放原始 Observable 的数据序列，而是有条件的重新订阅和发射原来的 Observable。 将原始 Observable 的终止通知（完成或错误）当做一个 void 数据传递给一个通知处理器，它以此来决定是否要重新订阅和发射原来的 Observable。这个通知处理器就像一个 Observable 操作符，接受一个发射 void 通知的 Observable 为输入，返回一个发射 void 数据（意思是，重新订阅和发射原始 Observable）或者直接终止（意思是，使用 repeatWhen 终止发射数据）的Observable。 123456789Observable.just(1,2,4).repeatWhen(new Function&lt;Observable&lt;Object&gt;, ObservableSource&lt;?&gt;&gt;() &#123; @Override public ObservableSource&lt;?&gt; apply(@NonNull Observable&lt;Object&gt; objectObservable) throws Exception &#123; RxHelper.log("apply"); return objectObservable; &#125;&#125;) .subscribeOn(Schedulers.computation()) .subscribe(new MyObserver&lt;Integer&gt;("repeatWhen")); Start发送事件之前先发送某些事件。 12345678910111213141516171819202122// 接收单个值Observable.just(1, 2, 4).startWith(100) .subscribe(new MyObserver&lt;Integer&gt;("startWith1"));// 接收 iterableList&lt;Integer&gt; ints = new ArrayList&lt;&gt;();ints.add(100);ints.add(200);Observable.just(1, 2, 4).startWith(ints) .subscribe(new MyObserver&lt;Integer&gt;("startWith2"));// 接收 arrayObservable.just(1, 2, 4).startWithArray(100, 200) .subscribe(new MyObserver&lt;Integer&gt;("startWith3"));// 接收 arrayInteger[] intArray = new Integer[]&#123;100, 200&#125;;Observable.just(1, 2, 4).startWithArray(intArray) .subscribe(new MyObserver&lt;Integer&gt;("startWith4"));// 接收 observableObservable.just(1, 2, 4).startWith(Observable.just(100, 200)) .subscribe(new MyObserver&lt;Integer&gt;("startWith5")); Timer在一定时间之后发送一个特殊值 0，timer 操作符默认在 computation 线程执行。 1234public static Observable&lt;Long&gt; timer(long delay, TimeUnit unit)public static Observable&lt;Long&gt; timer(long delay, TimeUnit unit, Scheduler scheduler)Observable.timer(10, TimeUnit.MILLISECONDS).subscribe(new MyObserver&lt;Long&gt;("timer"));]]></content>
      <categories>
        <category>Android</category>
        <category>Library</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RxJava2.x</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 选择器]]></title>
    <url>%2Farticle%2Fd318b1f4%2F</url>
    <content type="text"><![CDATA[使用 CSS 可以声明元素的样式规则，而这些规则到底匹配什么类型的元素，则由选择器来决定，选择器就是用来为声明的样式指定一个或者一组匹配的元素的一种规则。 为了能满足匹配的多种要求，选择器的种类也是多种多样的。 本文主要分为两部分，一个是借助选择器实现的一些特殊的效果做一下记录，另一个是系统的介绍各种选择器的使用和特性，做需要时查找使用。 效果 hover A 元素，B 元素作出反应 选择器 基本选择器 多元素选择器 属性选择器 (css2.1) 伪类(css2.1) 伪元素(css2.1) 同级元素通用选择器(css3) 属性选择器(css3) 与用户界面有关的伪类(css3) 结构性伪类(css3) 反选伪类(css3) :target 伪类(css3) 记录一些效果 hover A 元素，B 元素作出反应 如果是当前元素的 hover 很好实现，使用 hover 伪类实现即可，目前的场景是 hover A 元素，B 元素作出反应，可以结合伪类选择器和后代选择器来实现，当 父元素 hover 时也改变子元素的状态。 1234567891011121314151617181920212223242526272829&lt;style&gt; .child &#123; position:absolute; height:100px; background:blue; transition:all 0.5s; left:-50%; opacity: 0; width: 300px;&#125;.father &#123; background-color:red; width:500px; height: 300px;&#125;.father:hover .child &#123; left:0; opacity: 1; width: 100px;&#125;&lt;/style&gt; &lt;body&gt; &lt;div class="father"&gt; &lt;div class="child"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 基本选择器 标记 描述 含义 * 通用选择器 匹配所有元素 E 标签选择器 匹配所有使用E标签的元素 .info class选择器 匹配所有class属性中包含info的元素 #footer id选择器 匹配所有id属性等于footer的元素 实例 1234567* &#123; margin:0; padding:0; &#125;p &#123; font-size:2em; &#125;.info &#123; background:#ff0; &#125;p.info &#123; background:#ff0; &#125;p.info.error &#123; color:#900; font-weight:bold; &#125;#info &#123; background:#ff0; &#125;p#info &#123; background:#ff0; &#125; 多元素选择器 标记 描述 含义 E,F 多元素选择器 同时匹配所有E元素或F元素，E和F之间用逗号分隔 E F 后代元素选择器 匹配所有属于E元素后代的F元素，E和F之间用空格分隔 E &gt; F 子元素选择器 匹配所有E元素的子元素F E + F 毗邻元素选择器 匹配所有紧随E元素之后的同级元素F 示例 12345div p &#123; color:#f00; &#125;#nav li &#123; display:inline; &#125;#nav a &#123; font-weight:bold; &#125;div &gt; strong &#123; color:#f00; &#125;p + p &#123; color:#f00; &#125; 属性选择器 (css2.1) 标记 描述 E[attr] 匹配所有具有attr属性的E元素，不考虑它的值。(注意：E在此处可以省略，比如”[title]”，以下同。) E[attr=val] 匹配所有attr属性等于”val”的E元素 E[attr~=val] 匹配所有attr属性具有多个空格分隔的值、其中一个值等于”val”的E元素 E[attr&vert;=val] 匹配所有att属性具有多个连字号分隔的值、其中一个值以”val”开头的E元素，主要用于lang属性，比如”en”、”en-us”、”en-gb”等等 示例 12345p[title] &#123; color:#f00; &#125;div[class=error] &#123; color:#f00; &#125;td[headers~=col1] &#123; color:#f00; &#125;p[lang|=en] &#123; color:#f00; &#125;blockquote[class=quote][cite] &#123; color:#f00; &#125; 伪类(css2.1)伪类，表示它具有类的相似性质，但是它并不是类。 可以理解为，伪类更多的表示的元素的一种状态，比如 :first-child 表示的第一个字元素，:visited 表示元素被访问过，（当然不是所有元素都会有被访问过的这种状态）由浏览器创建一些内置类，来表达这种状态，并根据元素实际的状态，向这些内置类中动态添加或删除。 标记 描述 E:first-child 匹配父元素的第一个子元素 E:link 匹配所有未被点击的链接 E:visited 匹配所有已被点击的链接 E:active 匹配鼠标已经其上按下、还没有释放的E元素 E:hover 匹配鼠标悬停其上的E元素 E:focus 匹配获得当前焦点的E元素 E:lang(c) 匹配lang属性等于c的E元素 示例 1234p:first-child &#123; font-style:italic; &#125;input[type=text]:focus &#123; color:#000; background:#ffe; &#125;input[type=text]:focus:hover &#123; background:#fff; &#125;q:lang(sv) &#123; quotes: "\201D" "\201D" "\2019" "\2019"; &#125; 伪元素(css2.1) 标记 描述 E:first-line 匹配E元素的第一行 E:first-letter 匹配E元素的第一个字母 E:before 在E元素之前插入生成的内容 E:after 在E元素之后插入生成的内容 示例 1234p:first-line &#123; font-weight:bold; color;#600; &#125;.preamble:first-letter &#123; font-size:1.5em; font-weight:bold; &#125;.cbb:before &#123; content:""; display:block; height:17px; width:18px; background:url(top.png) no-repeat 0 0; margin:0 0 0 -18px; &#125;a:link:after &#123; content: " (" attr(href) ") "; &#125; 同级元素通用选择器(css3) 标记 描述 E ~ F 匹配任何在E元素之后的同级F元素 示例 1p ~ ul &#123; background:#ff0; &#125; 属性选择器(css3) 标记 描述 E[attr\^=”val”] 属性attr的值以”val”开头的元素 E[attr$=”val”] 属性attr的值以”val”结尾的元素 E[attr*=”val”] 属性attr的值包含”val”字符串的元素 示例 1div[id^="nav"] &#123; background:#ff0; &#125; 与用户界面有关的伪类(css3) 标记 描述 E:enabled 匹配表单中激活的元素 E:disabled 匹配表单中禁用的元素 E:checked 匹配表单中被选中的radio 或checkbox 元素 E:selection 匹配用户当前选中的元素 示例 1input[type="text"]:disabled &#123; background:#ddd; &#125; 结构性伪类(css3) 标记 描述 E:root 匹配文档的根元素，对于HTML文档，就是HTML元素 E:nth-child(n) 匹配其父元素的第n个子元素，第一个编号为1 E:nth-last-child(n) 匹配其父元素的倒数第n个子元素，第一个编号为1 E:nth-of-type(n) 与:nth-child()作用类似，但是仅匹配使用同种标签的元素 E:nth-last-of-type(n) 与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素 E:last-child 匹配父元素的最后一个子元素，等同于:nth-last-child(1) E:first-of-type 匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1) E:last-of-type 匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1) E:only-child 匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1) E:only-of-type 匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1) E:empty 匹配一个不包含任何子元素的元素，注意，文本节点也被看作子元素 示例 12345678910p:nth-child(3) &#123; color:#f00; &#125;p:nth-child(odd) &#123; color:#f00; &#125;p:nth-child(even) &#123; color:#f00; &#125;p:nth-child(3n+0) &#123; color:#f00; &#125;p:nth-child(3n) &#123; color:#f00; &#125;tr:nth-child(2n+11) &#123; background:#ff0; &#125;tr:nth-last-child(2) &#123; background:#ff0; &#125;p:last-child &#123; background:#ff0; &#125;p:only-child &#123; background:#ff0; &#125;p:empty &#123; background:#ff0; &#125; 反选伪类(css3) 标记 描述 E:not(s) 匹配不符合当前选择器的任何元素 示例 1:not(p) &#123; border:1px solid #ccc; &#125; :target 伪类(css3) 标记 描述 E:target 匹配文档中特定”id”点击后的效果]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 基础 1]]></title>
    <url>%2Farticle%2F5b70625a%2F</url>
    <content type="text"><![CDATA[CSS 指层叠样式表 (Cascading Style Sheets) 解决内容与表现分离的问题。 开始1234567891011121314151617body&#123; background-color:#d0e4fe;&#125;h1&#123; color:orange; text-align:center;&#125;p&#123; font-family:&quot;Times New Roman&quot;; font-size:20px;&#125;四个值: 第一个值为左上角，第二个值为右上角，第三个值为右下角，第四个值为左下角。三个值: 第一个值为左上角, 第二个值为右上角和左下角，第三个值为右下角两个值: 第一个值为左上角与右下角，第二个值为右上角与左下角一个值: 四个圆角值相同 插入样式表向 html 文档中插入样式表，样式表中不能包含任何的 html 标签。 如果某些属性在不同的样式表中被同样的选择器定义，那么属性值将从更具体的样式表中被继承过来。多重样式层叠优先级如下，同一优先级内同样的样式后面定义的具有更高的优先级 内联样式 &gt; 内部样式表 &gt; 外部样式表 &gt; 浏览器缺省设置 外部样式表浏览器会从文件 mystyle.css 中读到样式声明，并根据它来格式文档，外部样式表可以在任何文本编辑器中进行编辑，外部样式表应该以 .css 扩展名进行保存。 123&lt;head&gt;&lt;link rel="stylesheet" type="text/css" href="mystyle.css"&gt;&lt;/head&gt; 内部样式表当单个文档需要特殊的样式时，就应该使用内部样式表。 123456&lt;head&gt;&lt;style&gt; hr &#123;color:red;&#125; p &#123;margin-left:20px;&#125; body &#123;background-image:url("images/back40.gif");&#125;&lt;/style&gt; 内联样式由于要将表现和内容混杂在一起，内联样式会损失掉样式表的许多优势。例如当样式仅需要在一个元素上应用一次时，可以使用内联样式。要使用内联样式，你需要在相关的标签内使用样式style 属性。style 属性可以包含任何 CSS 属性。 1&lt;p style="color:red;margin-left:20px"&gt;This is a paragraph.&lt;/p&gt; CSS 背景 Property 描述 background 简写属性，作用是将背景属性设置在一个声明中。 background-attachment 背景图像是否固定或者随着页面的其余部分滚动。 background-color 设置元素的背景颜色。 background-image 把图像设置为背景。 background-position 设置背景图像的起始位置。 background-repeat 设置背景图像是否及如何重复。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758591. 背景颜色(background-color)定义颜色的三种方式- 十六进制："#123456"- RGB颜色：rgb(255,0,0)- 颜色名称：red,greenbody &#123;background-color:#b0c4de;&#125;---2. 背景图像(background-image)默认情况下，背景图像进行平铺重复显示，以覆盖整个元素实体.body &#123;background-image:url('paper.gif');&#125;---3. 背景图像平铺方式(background-repeat)默认情况下，图像会水平和垂直平铺，使用background-repeat指定平铺方式水平方向平铺 background-repeat:repeat-x; 垂直方向平铺 background-repeat:repeat-y; 不平铺 background-repeat:no-repeat; body&#123;background-image:url('img_tree.png');background-repeat:no-repeat;&#125;---4. 背景图像滑动方式(background-attachment)scroll 默认值。背景图像会随着页面其余部分的滚动而移动。fixed 当页面的其余部分滚动时，背景图像不会移动。inherit 规定应该从父元素继承 background-attachment 属性的设置body &#123; background-image: url(bgimage.gif);background-attachment: fixed;&#125;---5. 背景图像的位置(background-position)指定背景图像的位置right top left bottombody&#123;background-image:url('img_tree.png');background-repeat:no-repeat;background-position:right top;&#125;---6. 简写属性(backgound)简写属性的顺序为 1. background-color 2. background-image 3. background-repeat 4. background-attachment 5. background-positionbody &#123; background:#ffffff url('img_tree.png') no-repeat right top;&#125; CSS 文本 Property 描述 color 设置文本颜色 body {color:blue;} direction 设置文本方向。 letter-spacing 设置字符间距 line-height 设置行高 text-align 对齐元素中的文本 text-decoration 向文本添加修饰 text-indent 缩进元素中文本的首行 text-shadow 设置文本阴影 text-transform 控制元素中的字母 unicode-bidi 设置或返回文本是否被重写 vertical-align 设置元素的垂直对齐 white-space 设置元素中空白的处理方式 word-spacing 设置字间距 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001. 文本颜色(color)对于W3C标准的CSS：如果你定义了颜色属性，你还必须定义背景色属性。body &#123;color:blue;&#125;h1 &#123;color:#00ff00;&#125;h2 &#123;color:rgb(255,0,0);&#125;---2. 文本对齐方式(text-align)四种取值：right left center justify(自适应窗口对齐对)p.date &#123;text-align:justify;&#125;---3. 文本修饰(text-decoration)三种取值：overline(上划线) line-through(删除线) underline(下划线)h1 &#123;text-decoration:overline;&#125;---4. 文本转换(text-transform)三种取值：uppercase(全部大写) lowercase(全部小写) capitalize(首字母大写)p.uppercase &#123;text-transform:uppercase;&#125;---5. 文本缩进(text-indent)首行文本缩进p &#123;text-indent:50px;&#125;---6. 文字间距(letter-spacing)三个取值normal 默认。规定字符间没有额外的空间。length 定义字符间的固定空间（允许使用负值）。inherit 规定应该从父元素继承 letter-spacing 属性的值。h2 &#123;letter-spacing:-3px&#125;---7. 文字高度(line-height)normal 默认。设置合理的行间距。number 设置数字，此数字会与当前的字体尺寸相乘来设置行间距。length 设置固定的行间距。10px% 基于当前字体尺寸的百分比行间距。inherit 规定应该从父元素继承 line-height 属性的值。p.big &#123;line-height:200%;&#125;p.test &#123;line-height:10px;&#125;---8. 文字阴影(text-shadow)h-shadow 必需。水平阴影的位置。允许负值。v-shadow 必需。垂直阴影的位置。允许负值。blur 可选。模糊的距离。color 可选。阴影的颜色。参阅 CSS 颜色值。h1 &#123;color:white;text-shadow:2px -2px 3px #000;&#125;--- 9. 文本书写方向多语言支持(unicode-bidi)unicode-bidi 属性与 direction 属性一起使用，来设置或返回文本是否被重写，以便在同一文档中支持多种语言。如阿拉伯语言是从左到右书写的。使用该属性可以改变区域内文字书写方向normal 默认。不使用附加的嵌入层面。 embed 创建一个附加的嵌入层面。 bidi-override 创建一个附加的嵌入层面。重新排序取决于 direction 属性。 initial 设置该属性为它的默认值。请参阅 initialinherit 从父元素继承该属性。请参阅 inherit。div.ex1&#123; direction:rtl; unicode-bidi:bidi-override;&#125;---10. 文字垂直对齐(vertical-align)baseline 默认。元素放置在父元素的基线上。sub 垂直对齐文本的下标。super 垂直对齐文本的上标top 把元素的顶端与行中最高元素的顶端对齐text-top 把元素的顶端与父元素字体的顶端对齐middle 把此元素放置在父元素的中部。bottom 把元素的顶端与行中最低的元素的顶端对齐。text-bottom 把元素的底端与父元素字体的底端对齐。length 百分比% 使用 "line-height" 属性的百分比值来排列此元素。允许使用负值。inherit 规定应该从父元素继承 vertical-align 属性的值。--- 11. 文字空白处理(white-space)normal 默认。空白会被浏览器忽略。pre 空白会被浏览器保留。其行为方式类似 HTML 中的 &lt;pre&gt; 标签。nowrap 文本不会换行，文本会在在同一行上继续，直到遇到 &lt;br&gt; 标签为止。pre-wrap 保留空白符序列，但是正常地进行换行。pre-line 合并空白符序列，但是保留换行符。inherit 规定应该从父元素继承 white-space 属性的值---12. 单词间距(word-spacing)单词之间的间距，不同于letter-spacing(字母字符间距)normal 默认。定义单词间的标准空间。length 定义单词间的固定空间。inherit 规定应该从父元素继承 word-spacing 属性的值。 CSS 字体 Property 描述 font 在一个声明中设置所有的字体属性 font-family 指定文本的字体系列 font-size 指定文本的字体大小 font-style 指定文本的字体样式 font-variant 以小型大写字体或者正常字体显示文本。 font-weight 指定字体的粗细。 1234567891011121. 字体系列(font-family) font-family 属性应该设置几个字体名称作为一种"后备"机制，如果浏览器不支持第一种字体，他将尝试下一种字体。注意: 如果字体系列的名称超过一个字,多个汉字或多个单词，它必须用引号p.serif&#123;font-family:"Times New Roman",Times,serif;&#125;---2. 字体样式(font-style)normal italic斜体 oblique斜体p.oblique &#123;font-style:oblique;&#125;---3 盒模型盒模型是一个种布局方式，每个元素都被表示一个矩形的盒子，有尺寸大小、属性、颜色、边框和位置（渲染）目标。 盒模型默认的值是content-box，CSS3中新增了一种盒模型计算方式：padding-box，还有常用的 border-box，几种盒模型计算元素宽高的区别如下： content-box（默认） 123width = width + padding-left + padding-right + border-left + border-rightheight = height + padding-top + padding-bottom + border-top + border-bottom padding-box（Css 3） 123width = width(包含padding-left + padding-right) + border-top + border-bottomheight = height(包含padding-top + padding-bottom) + border-top + border-bottom border-box 123width = width(包含padding-left + padding-right + border-left + border-right)height = height(包含padding-top + padding-bottom + border-top + border-bottom)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「设计模式」使用更安全的单例模式]]></title>
    <url>%2Farticle%2F65563eb2%2F</url>
    <content type="text"><![CDATA[本文介绍 Java 单例模式，主要包括： 饿汉式单例实现 懒汉式单例简单实现 懒汉式线程安全加锁单例实现 懒汉式双重检查加锁单例实现。 使用枚举实现单例 饿汉式饿汉式的特点就是空间换时间，在开始时就创建，而且只创建一次，节约了运行时间，保证了线程安全，缺点就是当你不需要用的时候也同样占用内存空间。 123public class TokenProvider &#123; private static TokenProvider sInst = new TokenProvider();&#125; 懒汉式懒汉式的特点就是时间换空间，不需要时不创建，需要时才创建，节约了内存空间，缺点就是每次获取都需要判断，增加了运行时间，而且不加锁的懒汉式无法保证线程安全。 看一个最简单的 饿汉式 创建单例的方法 1234567891011public class TokenProvider &#123; private static TokenProvider sInst; public static TokenProvider getInst() &#123; if (sInst == null) &#123; sInst = new TokenProvider(); &#125; return sInst; &#125;&#125; 为什么会有线程安全的问题呢？因为多线程访问时，假设 A 线程正在创建实体，此时 B 线程已经开始进行 sInst == null 的判空操作，此时 B 线程便会创建一个新的实体。 如何解决？请看下面线程安全加锁 线程安全加锁当使用懒汉式时，如果多线程同时创建单例，不加锁的话就会创建多个实体，无法保证线程安全，此时应在判空操作之前加锁，让其他线程在外面等待已经进入的线程完成操作，创建完成实体，这时第二个线程进入时，sInst 已经不为空可以直接返回，从而保证线程安全。 加锁保证线程安全 12345678910111213public class TokenProvider &#123; private static TokenProvider sInst; public static TokenProvider getInst() &#123; synchronized (TokenProvider.class) &#123; if (sInst == null) &#123; sInst = new TokenProvider(); &#125; &#125; return sInst; &#125;&#125; 缺点也很明显，需要使用该单例时，所有线程都会首先进入同步代码块，在线程同步时会浪费很多时间，我们需要避免这种情况，请看下节双重检查加锁 双重检查加锁为了解决上面的问题，我们需要避免每次都进行同步加锁，在最外层先进行判空操作，当实体已经创建时，后面的线程则不需要进入同步代码块等待，节约了时间。 volatile: 被 volatile 修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存,从而确保多个线程能正确的处理该变量。 我们必须使用 volatile 来避免指令重排的问题，简单的来说在 2 处创建对象时，为 sInst 分配内存空间 和 初始化 sInst 两条指令可能发生重排序，这会导致在 1 处获取到一个没有被初始化的对象导致问题发生。Double-Check-Locking 指令重排问题 123456789101112131415public class TokenProvider &#123; private volatile static TokenProvider sInst; public static TokenProvider getInst() &#123; if (sInst == null) &#123; // 1 synchronized (TokenProvider.class) &#123; if (sInst == null) &#123; sInst = new TokenProvider(); // 2 &#125; &#125; &#125; return sInst; &#125;&#125; 使用枚举实现单例简单说一下枚举，枚举类似类，一个枚举可以拥有成员变量，成员方法，构造方法。创建enum 时，编译器会自动为我们生成一个继承自 Java.lang.Enum 的类，构建实例的过程不是我们做的，一个 enum 的构造方法限制是 private 的，也就是不允许我们调用。单例中的每一个都是 static final 类型，下面代码的对比应该更清楚一些 123enum Type&#123; A,B,C,D;&#125; 等同于 123456class Type extends Enum&#123; public static final Type A; public static final Type B; public static final Type C; public static final Type D;&#125; 在枚举中我们明确了构造方法限制为私有，在我们访问枚举实例时会执行构造方法，同时每个枚举实例都是 static final 类型的，也就表明只能被实例化一次。在调用构造方法时，我们的单例被实例化。也就是说，因为 enum 中的实例被保证只会被实例化一次，所以我们的 INSTANCE 也被保证实例化一次。 12345678910111213public enum TokenProviderSingleton &#123; INSTANCE; private TokenProvider mInst; TokenProviderSingleton() &#123; mInst = new TokenProvider(); &#125; public TokenProvider getInst() &#123; return mInst; &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js 开发-1(基础)]]></title>
    <url>%2Farticle%2F22324dc8%2F</url>
    <content type="text"><![CDATA[Js 是弱类型动态语言 内建数据类型object (Func,Array,Date…)numberstringbooleannullundefined + : 只要有字符串就是字符串拼接- : 如果有字符串，转换为数字计算 空字符串，null，undefined，数字0，数字NaN 转化为 boolean 为 false，其他为true. == : 等于，类型相同，同 ===，类型不同，进行转换，null == undefined, number == string(转换为数字比较)，boolean == number(转换成bool比较),object == number/string(尝试将obj转为基本类型) === : 严格等于，类型不同，返回 false，类型相同 null === null,undefined === undefind,NaN != NaN,new Object != new Object]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Retrofit开发-2-结合RxJava]]></title>
    <url>%2Farticle%2F36f21fa4%2F</url>
    <content type="text"><![CDATA[请先阅读 Retrofit 开发-1(OkHttp+Retrofit基本使用) 本文建立在对 RxJava2.x 和 Retrofit 基本熟悉的基础上，主要是在 Android 平台下对 RxJava + Retrifit 发送请求进行封装方法的探索。 准备首先你要确保在创建 Retrofit 时使用了 RcJava 的数据转换适配器。 依赖 1adapter_rxjava2 : 'com.jakewharton.retrofit:retrofit2-rxjava2-adapter:1.0.0', 配置 12final Retrofit.Builder retrofitBuilder = new Retrofit.Builder();retrofitBuilder.addCallAdapterFactory(RxJava2CallAdapterFactory.createWithScheduler(Schedulers.io())); 将数据中返回的全部类型改成 Observable 类型 12345@GET(GET_USER_INFO)Observable&lt;UserInfoDTOResponse&gt; getUser();@GET(GET_BABY_RELATION_LIST)Observable&lt;UserBabyRelationResp&gt; getBabyRelationList(@Query("babyId") Long babyId, @Query("limit") int limit, @Query("offset") Long offset); 请求数据这边熟悉了 RxJava 的相关使用和操作符之后用起来还算得心应手，就不做过多解释，贴两段代码感受一下。 封装的 Observer 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class ObserverWrap&lt;T&gt; implements Observer&lt;T&gt; &#123; Context mContext; public ObserverWrap(Context context) &#123; mContext = context; &#125; public ObserverWrap() &#123; &#125; @Override public void onSubscribe(@NonNull Disposable d) &#123; L.eWithTread("Rx", "onSubscribe"); &#125; @Override public void onNext(@NonNull T t) &#123; L.eWithTread("Rx", "onNext -&gt; " + t.toString()); &#125; @Override public void onError(@NonNull Throwable e) &#123; L.eWithTread("Rx", "onError"); e.printStackTrace(); ToastUtil.show("请求失败"); if (e instanceof UnknownHostException) &#123; ToastUtil.show("网络不好"); &#125; onFinish(); &#125; @Override public void onComplete() &#123; L.eWithTread("Rx", "onComplete"); onFinish(); &#125; public void onFinish() &#123; if (mContext != null) &#123; ((BaoBaoBaseActivity) mContext).dismissLoadingDialog(); &#125; &#125;&#125; 获取用户信息 123456789101112131415// 调用RequestTest.getUserInfo() .subscribe(new ObserverWrap&lt;UserInfoDTOResponse.UserInfoDTO&gt;()); // 方法public static Observable&lt;UserInfoDTOResponse.UserInfoDTO&gt; getUserInfo() &#123; return ApiRequest.getService().getUser() .map(new Function&lt;UserInfoDTOResponse, UserInfoDTOResponse.UserInfoDTO&gt;() &#123; @Override public UserInfoDTOResponse.UserInfoDTO apply(@io.reactivex.annotations.NonNull UserInfoDTOResponse userInfoDTOResponse) throws Exception &#123; return userInfoDTOResponse.getData(); &#125; &#125;) .observeOn(AndroidSchedulers.mainThread());&#125; 来一个复杂点的，获取一个列表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 调用RequestTest.getUserBabyRelationList(mActivity,baby) .subscribe(new ObserverWrap&lt;UserBabyRelation&gt;(mActivity)); // 方法public static Observable&lt;UserBabyRelation&gt; getUserBabyRelationList(final Context context, Baby baby) &#123; return ApiRequest.getService() .getBabyRelationList(baby.getBabyId(), 100, null) .subscribeOn(Schedulers.newThread()) .doOnSubscribe(new Consumer&lt;Disposable&gt;() &#123; @Override public void accept(@io.reactivex.annotations.NonNull Disposable disposable) throws Exception &#123; if(context instanceof BaoBaoBaseActivity)&#123; ((BaoBaoBaseActivity) context).showLoadingDialog(); &#125; &#125; &#125;) .subscribeOn(AndroidSchedulers.mainThread()) .filter(new Predicate&lt;UserBabyRelationResp&gt;() &#123; @Override public boolean test(@io.reactivex.annotations.NonNull UserBabyRelationResp userBabyRelationResp) throws Exception &#123; if (userBabyRelationResp.getStatus() == 200 &amp;&amp; isRespNotNull(userBabyRelationResp)) &#123; return true; &#125; else if (userBabyRelationResp.getStatus() != 200) &#123; if (userBabyRelationResp.getMessage() != null) &#123; ToastUtil.show(userBabyRelationResp.getMessage()); &#125; return false; &#125; return false; &#125; &#125;) .map(new Function&lt;UserBabyRelationResp, List&lt;UserBabyRelation&gt;&gt;() &#123; @Override public List&lt;UserBabyRelation&gt; apply(@io.reactivex.annotations.NonNull UserBabyRelationResp userBabyRelationResp) throws Exception &#123; return userBabyRelationResp.getData().getList(); &#125; &#125;) .flatMap(new Function&lt;List&lt;UserBabyRelation&gt;, ObservableSource&lt;UserBabyRelation&gt;&gt;() &#123; @Override public ObservableSource&lt;UserBabyRelation&gt; apply(@io.reactivex.annotations.NonNull List&lt;UserBabyRelation&gt; userBabyRelations) throws Exception &#123; return Observable.fromIterable(userBabyRelations); &#125; &#125;) .observeOn(AndroidSchedulers.mainThread());&#125; 封装在 Android 平台下我们进行网络请求时，往往有些特殊的要求，总结如下，不断完善实现下列需求的方法，寻找一种更合适更简单的 Retrofit + RxJava 的网络请求架构。 请求开始时，显示 Dialog 提示用户等待，请求结束时消掉 Dialog 当 Activity 销毁时取消当前界面的请求。 当 Dialog 被认为 cancel 时，取消当前页面的请求。]]></content>
      <categories>
        <category>Android</category>
        <category>Library</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Retrofit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2.x开发-3-源码分析]]></title>
    <url>%2Farticle%2F7ae7177b%2F</url>
    <content type="text"><![CDATA[知其然(知道轮子是怎么用的)，知其所以然(也要知道轮子是怎么造的)。 本文主要介绍 RxJava2.x 是如何通过流式API完成事件的传递和变换的，我们不是要全部把它弄的清清楚楚，那需要大量的时间和不断深入才可以，只是通过简单的例子来理解他的基本工作原理和主要功能。 看了很多文章，文章中会讲代理模式什么的，但我觉得更像是包装者模式，可能我理解有偏差😭，但是我觉得这样更好理解一些，我就先按照我的理解来写，后面不对再修正好了。 文中源码我会去掉错误检查和注解的部分代码，只保留核心代码，看起来更清晰。 简单的订阅看一个最最简单的例子 1234567891011121314151617181920212223Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); &#125;&#125;).subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(@NonNull Disposable d) &#123; log("onSubscribe"); &#125; @Override public void onNext(@NonNull Integer integer) &#123; log("onNext - &gt; " + integer); &#125; @Override public void onError(@NonNull Throwable e) &#123; log("onError"); &#125; @Override public void onComplete() &#123; log("onComplete"); &#125;&#125;); 这可能是最最基本的用法了，然后看一下源码，被观察者是如何向观察者发送数据的，首先是创建被观察者的过程。 123456// Observable.javapublic static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) &#123; ObjectHelper.requireNonNull(source, "source is null"); return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));&#125; ObservableOnSubscribe 是个接口，里面只有一个 subscribe() 方法，而我们就是在这个方法中进行事件的发送的。源码中可以看见实际上创建了一个 ObservableCreate 返回了，这个 ObservableCreate 其实是Observable 的子类，他是一个被观察者的具体实现，因为是内部自己创建的所以叫 ObservableCreate，我猜的。整个过程就创建了一个 ObservableCreate 并返回了回来，然后怎么就可以继续链式调用了，比如在上面的简单例子中，调用了 subscirbe() 方法，这也是最后将调用的方法。 我们就上面的简单例子来继续看 subscribe() 发生的一刻发生了什么，我去掉了各种检查错误的代码，只保留核心代码。 12345// Observable.javapublic final void subscribe(Observer&lt;? super T&gt; observer) &#123; subscribeActual(observer);&#125; 没错，就剩了一句了，subscribeActual() 是一个抽象方法，我们还要去看一下子类的具体实现，上面我们发现创建的 Observable 的子类是 ObservableCreate，那我们肯定是要去看这个子类了。 1234567891011121314151617// ObservableCreate.javapublic final class ObservableCreate&lt;T&gt; extends Observable&lt;T&gt; &#123; final ObservableOnSubscribe&lt;T&gt; source; public ObservableCreate(ObservableOnSubscribe&lt;T&gt; source) &#123; this.source = source; &#125; @Override protected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer); observer.onSubscribe(parent); source.subscribe(parent); &#125;&#125; 还是只看重点的，final ObservableOnSubscribe&lt;T&gt; source; 就是我们创建 Observable 时传进去的接口类，他只有一个 subscribe() 方法，再来仔细看一下 subscribeActual() 的实现，参数自然是要订阅过来的观察者 Observer，然后可以看到 Observer 被包装成了一个 CreateEmitter 发射器，我们知道他是用来发射事件的，那我们再看一眼发射器，不细看，他是一个静态内部类，看一下类声明即可 123static final class CreateEmitter&lt;T&gt; extends AtomicReference&lt;Disposable&gt; implements ObservableEmitter&lt;T&gt;, Disposable&#123;&#125; 接着上面的说，然后将发射器作为参数执行了 ObservableOnSubscribe 的 subscribe() 方法，然后会怎么样？自然是执行我们自己实现的 ObservableOnSubscribe 的 subscribe() 方法，开始使用发射器发送事件。其实我们是调用发射器，发射器调用他包装的 Observer 中对应的方法而已。 插一句，我们注意到当订阅发生时，首先执行了 observer.onSubscribe(parent); 方法，这也就是为啥观察者中的方法为什么会首先被调用，而 CreateEmitter 是实现了 Disposable 接口的，它可用来切断事件流。 总结，当观察者被订阅到被观察者时，被观察者被包装成一个发射器，调用 subscribe() 方法，使用发射器发射事件，被观察者收到事件。 操作符在实际应用过程中我们可能经历无数次操作符的变化，但是为了简化分析的过程，我们只看使用了一个操作符的例子，然后类推一下，其实多个变化也是一样的。 看一个使用操作符的场景 12345678910111213141516Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); &#125;&#125;).map(new Function&lt;Integer, String&gt;() &#123; @Override public String apply(@NonNull Integer integer) throws Exception &#123; return String.valueOf(integer); &#125;&#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(@NonNull String s) throws Exception &#123; log("accept -&gt; " + s); &#125;&#125;); 在上个问题的基础上，我们以 map 操作符为例看一下，使用操作符的场景是如何建立连接，发送事件的，直接来看 map 方法，在 map 方法中创建了一个 ObservableMap 返回。 123456// Observable.javapublic final &lt;R&gt; Observable&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper) &#123; ObjectHelper.requireNonNull(mapper, "mapper is null"); return RxJavaPlugins.onAssembly(new ObservableMap&lt;T, R&gt;(this, mapper));&#125; 这个 ObservableMap 也是 Observer 的子类，也就是说它也是一个被观察者，参数是当前的被观察者和一个 Function，我们再来看一下 ObservableMap。 1234567891011121314151617181920212223242526272829public final class ObservableMap&lt;T, U&gt; extends AbstractObservableWithUpstream&lt;T, U&gt; &#123; final Function&lt;? super T, ? extends U&gt; function; public ObservableMap(ObservableSource&lt;T&gt; source, Function&lt;? super T, ? extends U&gt; function) &#123; super(source); this.function = function; &#125; @Override public void subscribeActual(Observer&lt;? super U&gt; t) &#123; source.subscribe(new MapObserver&lt;T, U&gt;(t, function)); &#125; static final class MapObserver&lt;T, U&gt; extends BasicFuseableObserver&lt;T, U&gt; &#123; final Function&lt;? super T, ? extends U&gt; mapper; MapObserver(Observer&lt;? super U&gt; actual, Function&lt;? super T, ? extends U&gt; mapper) &#123; super(actual); this.mapper = mapper; &#125; @Override public void onNext(T t) &#123; U v = mapper.apply(t) actual.onNext(v); &#125; &#125;&#125; ObservableMap 包装了原来的 SourceObservable，也接受了我们进行 map 操作的 Function。当订阅发生时，仍旧会调用 subscribeActual() 方法，在这个方法中，我们把最终的观察者包装成了一个 MapObserver，然后把这个 MapObserver 订阅到了 SourceObservable。结合上面简单订阅时的分析，此时，SourceObservable 便会将 MapObserver 包装成一个发射器，开始发射事件了。再关注一下 onNext() 方法，这里会先调用 Function 进行 map 操作。 总结：我们称最开始创建的被观察者为 SourceObservable，如果中间增加一个 map 操作符，此时创建并且返回了一个 ObservableMap 包装 SourceObservable 作为新的被观察者，此时链式调用的对外开放的就是 ObservableMap 了， 当最终的观察者，我们叫他 finalObserver，被订阅到 ObservableMap 时，会将finalObserver 包装成一个 MapObserver (这个 MapObserver 在调用 onNext() 时会继续调用他包装的 finalObserver 的 onNext() 方法和对应的 Function 方法) 订阅到 SourceObservable。然后开始第一节中的流程，也就是这个 MapOserver 将会被包装成一个发射器，开始发射事件，相比之前，此时调用 OnNext() 发送事件时，会首先调用 MapObserver 的 onNext(),然后继续调用它包装的 finalObserver 的 onNext(),不过在这之间会使用 Function 指定的操作对数据进行变换 再增加一个操作符会怎么样，其实就是是一样的流程了，只不过此时对外开放的 ObservalMap 扮演了 SourceObservable 的角色。 我在 RxJava2.x开发-2 (Schedulers) 这篇文章中介绍了如何在 RxJava2.x 中如何使用线程调度，和如何判断当前方法是运行在哪个线程，强烈建议去看一下才能更明白他是怎么样使用的，之前总结了怎么做，现在看一下为什么。 subscribeOn()在 RxJava2.x开发-2 (Schedulers) 总结了 subscribeOn() 用来切换上游线程，而且只有第一次有效，后面的调用只对 doOnSubscribe()/onSubscribe() 方法有效，但是为什么会是这样呢？ 看一个简单的例子 123456789101112Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); &#125;&#125;).subscribeOn(Schedulers.io()) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer s) throws Exception &#123; log("accept -&gt; " + s); &#125; &#125;); 被观察者将会在 io 线程运行，为什么？看源码，仍旧是跟之前一样的模式，创建新的被观察者包装原来的观察者。 123456// Observable.javapublic final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));&#125; 我们还是将最开始的 Observable 称作 SourceObservable，subscribeOn() 创建并返回了 ObservableSubscribeOn 对象，没错它也是 Observable 的子类，是一个被观察者。我们再来看一下 ObservableSubscribeOn 类，创建时使用了原来的 SourceObservable 和一个线程调度器，先贴一下源代码，后面解释。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// ObservableSubscribeOn.javapublic final class ObservableSubscribeOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; &#123; final Scheduler scheduler; public ObservableSubscribeOn(ObservableSource&lt;T&gt; source, Scheduler scheduler) &#123; super(source); this.scheduler = scheduler; &#125; @Override public void subscribeActual(final Observer&lt;? super T&gt; s) &#123; final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(s); s.onSubscribe(parent); parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent))); &#125; static final class SubscribeOnObserver&lt;T&gt; extends AtomicReference&lt;Disposable&gt; implements Observer&lt;T&gt;, Disposable &#123; final Observer&lt;? super T&gt; actual; SubscribeOnObserver(Observer&lt;? super T&gt; actual) &#123; this.actual = actual; &#125; @Override public void onNext(T t) &#123; actual.onNext(t); &#125; &#125; final class SubscribeTask implements Runnable &#123; private final SubscribeOnObserver&lt;T&gt; parent; SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123; this.parent = parent; &#125; @Override public void run() &#123; source.subscribe(parent); &#125; &#125;&#125; 重点就在 subscribeActual() 方法，我们知道当订阅发生时会调用 subscribeActual() 方法，此时，创建了一个 SubscribeOnObserver 包装了真正订阅的观察者，然后调用观察者 onSubscribe() 方法，这跟之前的介绍是一样的，不同的是将新创建的 SubscribeOnObserver 订阅到 SourceObservable 这个过程，做成了一个 Task，并使用了线程调度器去执行，此时会发生什么？还是之前说的 SubscribeOnObserver 会被包装成一个发射器开始发射事件，而此时因为使用了线程调度器执行，将会运行在指定的线程。 到现在大致清楚了 RxJava 如何使用 subscribeOn() 方法切换了被观察者所运行的线程，那为什么只有第一次有效果，后面不生效呢？为什么对于 doOnSubscribe()/onSubscibe() 又是生效的呢？ 虽然我们写代码时是从被观察者一路链式编程写下去的，但是其实真正开始执行的时机是，订阅开始的时候，即 subscribe() 调用的时候。而且按照我们之前的分析，subscribe() 方法会往上一层一层的调用上去，一直到最开始创建的被观察者，然后就开始发送事件。那我们调用两次 subscribeOn() 时，每次都会在里面生成新的被观察者，然后在指定线程调用 subscribe() 方法，所以开始的被观察者被调用的线程只取决了离他最近的那个 subscribeOn() ，因为在这里面会将发送最开始的被观察者的 subscribe() 方法 到指定线程运行，就好像假如 ObserableA 在 ThreadA 线程完成订阅，接着会继续调用里面包装的 ObserableB 在 ThreadB 线程完成订阅，其实最终的 ObserableB 还是在 ThreadB 线程完成订阅发送事件的。另外可以发现 doOnSubscribe()/onSubscibe() 是在发送到指定线程执行之前就执行的，所以他仍旧受到后面指定线程的影响，doOnSubscribe() 返回的也是一个 Observable，机制大致相同。 observarOn()调用 observarOn() 可以切换下游所在线程，每次调用都会切换线程。 类似上面的原理，仍旧生成了一个新的被观察者 ObservableObserveOn 1234567// Observable.javapublic final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); ObjectHelper.verifyPositive(bufferSize, "bufferSize"); return RxJavaPlugins.onAssembly(new ObservableObserveOn&lt;T&gt;(this, scheduler, delayError, bufferSize));&#125; 订阅时，如果使用了 Schedulers.trampoline() 那么在当前线程，不需要在创建新的包装观察者，否则创建 ObserveOnObserver 包装原来的观察者。 1234567891011// ObserveOnObserver.java@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; if (scheduler instanceof TrampolineScheduler) &#123; source.subscribe(observer); &#125; else &#123; Scheduler.Worker w = scheduler.createWorker(); source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize)); &#125;&#125; 看一下 ObserveOnObserver 它实现了 Runnable 接口，在 run 方法中根据当前状态，分别调用它包装的观察者的对应方法。然后在相应的方法的最后都会调用 schedule(); 发送到指定线程操作，达到切换线程的目的，对应方法指的是 onNext/onComplete/onError 1234567891011121314151617181920212223242526272829303132333435363738394041static final class ObserveOnObserver&lt;T&gt; extends BasicIntQueueDisposable&lt;T&gt;implements Observer&lt;T&gt;, Runnable &#123; @Override public void onNext(T t) &#123; schedule(); &#125; @Override public void onError(Throwable t) &#123; if (done) &#123; RxJavaPlugins.onError(t); return; &#125; error = t; done = true; schedule(); &#125; @Override public void onComplete() &#123; if (done) &#123; return; &#125; done = true; schedule(); &#125; // 去指定线程执行 void schedule() &#123; if (getAndIncrement() == 0) &#123; worker.schedule(this); &#125; &#125; @Override public void run() &#123; // 会根据当前的状态队形执行被包装的观察者的相关方法。 if (outputFused) &#123; drainFused(); &#125; else &#123; drainNormal(); &#125; &#125;&#125; 总结说了这么多，我自己都感觉有点乱，心里明白但是写不出来的感觉真难受，还是文笔不行，想画个图表示一下，但画完感觉更复杂了。 在我看来，每次增加一个功能，比如操作符，或者线程切换，都会返回一个新的被观察者包装原来的被观察者，同时创建一个新的观察者，原来的观察者也会被包装进这个新的观察者，操作符会形成进行数据变换的被观察者和观察者，线程调度会形成线程切换的被观察者何观察者，形成一个一层一层包装的关系。 真正触发代码执行的是 subscribe() 方法，此时就会一层一层的调用更里面包装的被观察者的 subscribe() 方法，当最后一个被观察者，也就是我们最开始创建的那个的 subscribe() 方法被触发时，事件便开始发送，事件会一层一层往观察者里面传递，观察者又会调用它里面包装的观察者去处理传递这些事件，这过程中包含了事件的处理，变换，线程调度等。 感觉自己埋了个坑，说了这么多，说的也不是很明白，源码还是要自己看一下才更清楚一些。]]></content>
      <categories>
        <category>Android</category>
        <category>Library</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RxJava2.x</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2.x开发-2-Schedulers]]></title>
    <url>%2Farticle%2F8de84f35%2F</url>
    <content type="text"><![CDATA[本文主要介绍 RxJava2.x 强大的线程调度。 在 Android 开发中因为不允许阻塞主线程，所以所有的耗时请求都必须全部放在子线程来做，然后再去主线程更新UI，关于主线程和子线程的通信其实异常复杂，好在Android 给我们提供了 AsyncTask，Handler 等方式来简化这一过程。使用 RxJava 会让切换线程变得更简单。 文中部分描述可能有些混乱，为了更好的看出在哪个线程调用，我会在子线程中执行我的代码，我就称它为 MyThread，也就是调用代码所在的线程。io线程，计算线程，newThread线程就是我对 RxJava 几种内置线程的简称。上游线程就是被观察者所在的线程，下游线程是观察者所在线程，调用线程就是我调用代码的线程 MyThread。这里简单理一下，虽然还是有点乱。 Schedulers 种类RxJava 根据不同应用场景内置了多种线程调度器，可以大多数场景的后台操作需求。 Schedulers Desc Schedulers.computation() 用于计算任务，如事件循环或和回调处理，不要用于IO操作，默认线程数等于处理器的数量 Schedulers.io() 用于IO密集型任务，如异步阻塞IO操作，这个调度器的线程池会根据需要增长；对于普通的计算任务，请使用Schedulers.computation() Schedulers.newThread() 为每个任务创建一个新线程 Schedulers.trampoline() 当其它排队的任务完成后，在当前线程排队开始执行 Schedulers.from(executor) 使用指定的 Executor 作为调度器 AndroidSchedulers.mainThread() Android 主线程 AndroidSchedulers.from(looper) 从 Looper 创建 线程调度最为关键的就是两个方法 subscribeOn() 和 observeOn()，从代码的链式调用可以简单的总结为： 上游 Observable 总是默认运行在被调用的线程当中，即你在哪个线程调用就会运行在哪个线程。 下游 Onserver 总是默认运行在上游所在线程中(当然如果你没有切换上游的线程，那么下游也会运行在调用的线程中)，除非使用 observeOn() 进行线程的切换。 subscribeOn() 用来声明上游事件发送时的所在线程，当调用多次 subscribeOn() 时，上游会运行在最早的一次调用声明的线程中。当然也不是说多次的调用是完全没效果的，后面会细说。 observeOn() 用来声明下游观察者所在线程，每次调用 observeOn() 都会发生线程切换，此次调用直到下次切换线程中间的过程中的操作运行在此次调用指定的线程中。 12345678910111213141516171819202122232425262728293031323334353637log("start");Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exceptio log("Observable"); e.onNext(10); &#125;&#125;) // 第1次调用subscribeOn， Observable 将运行在io线程 .subscribeOn(Schedulers.io()) // io 线程，下游总是会默认运行在上游所在线程中 .filter(new Predicate&lt;Integer&gt;() &#123; @Override public boolean test(@NonNull Integer integer) throws Exception &#123; log("filter1"); return true; &#125; &#125;) // 第2次调用subscribeOn，不会生效 .subscribeOn(Schedulers.newThread()) // 第1次调用observeOn，切换线程，filter操作运行在主线程 .observeOn(AndroidSchedulers.mainThread()) .filter(new Predicate&lt;Integer&gt;() &#123; @Override public boolean test(@NonNull Integer integer) throws Exception &#123; log("filter2"); return true; &#125; &#125;) // 第2次调用observeOn，切换线程到子线程 .observeOn(Schedulers.newThread()) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; log("subscribe = " + integer); &#125; &#125;); 输出结果,我整个代码运行在一个我自己的子线程中，我就叫他 MyThread 好了，方便描述 12345[ThreadName:pool-13-thread-1] start // 因为在 MyThread 子线程调用[ThreadName:RxCachedThreadScheduler-1] Observable // io[ThreadName:RxCachedThreadScheduler-1] filter1 // io.由于没有切换线程，默认运行在上游线程中。[ThreadName:main] filter2 // 切换到主线程[ThreadName:RxNewThreadScheduler-2] subscribe = 10 // 切换到 newThread 线程 doOnSubscribe()当调用多次 subscribeOn() 方法时，上游将运行在最早调用指定的线程中，这个没什么问题，对于下游的 doOnNext()，doOnComplete() 来说，遵循上面说的规则，除非你使用 observerOn() 切换线程，不然运行在上游线程中。 但是 doOnSubscribe() 有点不一样，除非他后面有调用 subscribeOn() 切换线程，否则他默认运行在执行 Observable.subcribe() 语句的线程中。 其实这里的 doXXX() 方法和上一篇文章中观察者中的几个方法是一一对应的，在观察者的中 onSubscribe() 方法也有同样的属性，他在订阅发生的一瞬间首先执行，并且它运行在订阅发生的线程。其他几个方法也是一样，除非你使用 observerOn() 切换线程，不然运行在上游线程中。 12345678910111213141516171819202122232425262728293031323334353637383940log("start");Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; log("Observable"); e.onNext(10); e.onComplete(); &#125;&#125;) // 计算线程，因此 Observable 将会运行在计算线程 .subscribeOn(Schedulers.computation()) .observeOn(Schedulers.newThread()) .doOnNext(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; log("doOnNext"); &#125; &#125;) .doOnSubscribe(new Consumer&lt;Disposable&gt;() &#123; @Override public void accept(@NonNull Disposable disposable) throws Exception &#123; // 后面没有调用 subscribeOn() 因此将运行在 Observable.subscribe() 执行的线程 log("doOnSubscribe"); &#125; &#125;) .doOnComplete(new Action() &#123; @Override public void run() throws Exception &#123; log("doOnComplete"); &#125; &#125;) .observeOn(Schedulers.newThread()) // doOnSubscribe() 运行的线程取决于在哪里执行订阅 // 除非后面有调用 subscribeOn() 进行线程的切换 .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; log("subscribe = " + integer); &#125; &#125;); 输出结果，我整个代码运行在一个我自己的子线程中，我就叫他 MyThread 好了，方便描述 1234567891011// MyThread 子线程运行[ThreadName:pool-16-thread-1] start // 因为 subscribe() 方法也同样运行在 MyThread 子线程，所以 doSunscribe() 页运行在 MyThread 子线程[ThreadName:pool-16-thread-1] doOnSubscribe // 由于调用 subscribeOn(Schedulers.computation()) 所以上游运行在计算线程[ThreadName:RxComputationThreadPool-1] Observable // 遵循上面说的规则，运行在 observerOn() 指定的 newThread 中。[ThreadName:RxNewThreadScheduler-1] doOnNext// 同上 [ThreadName:RxNewThreadScheduler-1] doOnComplete [ThreadName:RxNewThreadScheduler-2] subscribe = 10 切换 doOnSubscribe() 所在线程再换一个更改 doOnSubscribe() 运行线程的例子，跟上面不同的是在 doOnSubscribe() 之后我们使用 subscribeOn(Schedulers.io()) 切换了线程，因此 doOnSubscribe() 将运行在 io 线程。 123456789101112131415161718192021222324252627282930log("start");Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; log("Observable"); e.onNext(10); e.onComplete(); &#125;&#125;) // 计算线程，因此 Observable 将会运行在计算线程 .subscribeOn(Schedulers.computation()) .observeOn(Schedulers.newThread()) .doOnSubscribe(new Consumer&lt;Disposable&gt;() &#123; @Override public void accept(@NonNull Disposable disposable) throws Exception &#123; // doOnSubscribe 之后第一次调用 subscribeOn(Schedulers.io()) 切换到了io线程 // 因此 doOnSubscribe 运行在 io 线程。 log("doOnSubscribe"); &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(Schedulers.newThread()) // doOnSubscribe() 运行的线程取决于在哪里执行订阅 // 除非后面有调用 subscribeOn() 进行线程的切换 .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; log("subscribe = " + integer); &#125; &#125;); 运行结果 12345678// MyThread[ThreadName:pool-16-thread-1] start// 由于后面调用了 subscribeOn(io) 因此运行在 io 线程[ThreadName:RxCachedThreadScheduler-1] doOnSubscribe// 运行在上游线程中[ThreadName:RxComputationThreadPool-1] Observable// 使用 observeOn(Schedulers.newThread()) 切换到了 newThread[ThreadName:RxNewThreadScheduler-2] subscribe = 10 举个🌰有啥用呢？模拟一个场景，1⃣️上游发送网络请求，要求在子线程执行，2⃣️ 但是请求刚开始的时候我们要显示 dialog 提示用户等待，需要在主线程执行，3⃣️ 完成之后又要在子线程处理数据，4⃣️ 然后去主线程更新UI。 123456789101112131415161718192021222324252627282930313233343536log("开始操作，为了搞复杂点，我在我自己创建子线程操作");Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; log("子线程发起网络请求"); e.onNext(10); e.onComplete(); &#125;&#125;) // 在子线程发起请求 .subscribeOn(Schedulers.newThread()) .doOnSubscribe(new Consumer&lt;Disposable&gt;() &#123; @Override public void accept(@NonNull Disposable disposable) throws Exception &#123; log("请求之前，主线程弹起dialog"); &#125; &#125;) // 切换到主线程弹 dialog .subscribeOn(AndroidSchedulers.mainThread()) // 切换到计算线程 处理数据 .observeOn(Schedulers.computation()) .filter(new Predicate&lt;Integer&gt;() &#123; @Override public boolean test(@NonNull Integer integer) throws Exception &#123; log("计算线程处理数据"); return true; &#125; &#125;) // 切换到主线程更新UI .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; log("主线程更新UI"); &#125; &#125;); 输出结果 12345[ThreadName:pool-13-thread-1] 开始操作，为了搞复杂点，我在我自己创建子线程操作[ThreadName:main] 请求之前，主线程弹起dialog[ThreadName:RxNewThreadScheduler-1] 子线程发起网络请求[ThreadName:RxComputationThreadPool-1] 计算线程处理数据[ThreadName:main] 主线程更新UI 总之，如何判断到底在什么线程运行综上所述，总结几条公式，其实就是把上面说的再说一遍： 几个概念 ： 上游，上游指的是 数据发射源，Observable 中的代码。 下游，下游指的是 操作符方法，Observable 调用方法，观察者中的方法 调用线程，我在哪个线程运行该代码，这个线程就是调用线程。 1⃣️、上游总是默认运行在被 调用线程 当中，即你在哪个线程调用就会运行在哪个线程。 2⃣️、 下游总是默认运行在上游所在线程中 (当然如果你没有切换上游的线程，那么下游也会运行在 调用线程 中) ，除非使用 observeOn() 进行线程的切换。 3⃣️、 subscribeOn() 用来声明上游事件发送时的所在线程，当调用多次 subscribeOn() 时，上游会运行在 最早 的一次调用声明的线程中。 4⃣️、 observeOn() 用来声明下游观察者所在线程，每次调用 observeOn() 都会发生线程切换，此次切换 到 下次切换 之间运行在 此次切换 的线程中。 5⃣️、 对于 doOnNext()/onNext()，doOnComplete()/onComplete()，doOnError()/onError() 几个方法 (前者是 被观察者 调用的方法，后者是 观察者 接口里面的对应方法) ，他们都和操作符一样，遵循 2⃣️ 中的规则。 6⃣️、对于 doOnSubscribe()/onSubscribe() 方法 (前者是 被观察者 调用的方法，后者是 观察者 接口里面的对应方法) 来说，如果他后面有调用 subscribeOn() 切换线程，那么它运行在切换的线程，否则他默认运行在执行 Observable.subcribe() 语句的线程中。 为什么是这样上面只是总结一些规则，一个方法是运行在什么线程，使用上面的规则可以更简单判断出来，我们其实是在通过一些表象来总结如何判断，那为什么会是这样的规则呢？我现在也还没研究明白，，，，，，所以，待办 ～ ok了～关于 RxJava2.x 的一些源码分析见RxJava2.x开发 (源码解析)]]></content>
      <categories>
        <category>Android</category>
        <category>Library</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RxJava2.x</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[坚持]]></title>
    <url>%2Farticle%2FInfinity%2F</url>
    <content type="text"><![CDATA[2017年7月2日，早9点10分，周日，天气不错，稍微有点热。 今天周日，转眼一周过来了，这周都尽量能在早上7点到8点起床到公司，算是坚持下来了，以后继续，然后把时间控制在7点多，现在起床之后墨迹的时间太多了，7点多睁眼，都要快9点钟才有状态。 这周主要看了一下 Kotlin 的一点内容，然后 Retrofit 网络请求，简单的开始了解了一下，后面会继续深入，今天重点看 RxJava，加油 ！ TODO LIST : Kotlin 剩余部分继续推进。 OkHttp + Retrofit + RxJava 还是要继续了解。 看了几篇面经，EventBus，Glide，OkHttp，Retrofit 源码看一下原理。 博客继续整理。 更多…]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2.x开发-1-基础]]></title>
    <url>%2Farticle%2F3251baff%2F</url>
    <content type="text"><![CDATA[开始总结记录 RxJava 的相关内容，本文中所有涉及 RxJava 的地方均指 Rxjava2.0。 本文主要以 Observable 和 Flowable 为例介绍如何创建被观察者和观察者，并连接他们。 RxJava https://github.com/ReactiveX/RxJava RxJava https://github.com/ReactiveX/RxAndroid 推荐文章记录一下看过的几篇还不错的关于 RxJava 的文章，感谢他们的总结和分享。 RxJava1 - 《 给 Android 开发者的 RxJava 详解 》- 扔物线)，这篇文章是对 RxJava1 的讲解，很不错，图文并茂，看了一遍之后仍旧有些疑惑，建议多看几遍，很多关于原理的介绍可以加强对 Rx 的理解。 RxJava2 - 《 给初学者的RxJava2.0教程(一) 》- 掘金 以及 RxJava2 - 《 给初学者的RxJava2.0教程(二) 》- 掘金，特点就是作者使用水管上游下游的描述方式，简化了对观察者模式和事件发送的理解，浅显易懂，也很全面，适合入门。 《 RxJava2.0 你不知道的事》- 简书 是对 RxJava1.x 和 RxJava2.x 的对比，文章中对 2.x 的部分 api，进行了列举，对比起来看就清晰多了，另外很好的解释了背压的问题，受益匪浅。 《关于RxJava最友好的文章》- 知乎 RxJava2.x APi 文档 我的理解上面推荐的文章中对 RxJava 的相关原理都做了部分说明，我就不做过多描述，说一下我的一些理解吧。 RxJava 最关键的两个点就是 观察者模式 和 异步。在 RxJava 中被观察者作为事件的产生方，是 主动 的，是整个事件流程的起点。观察者作为事件的处理方，是 被动 的，是整个事件流程的终点。在起点和终点之间，即事件传递的过程中是可以被加工，过滤，转换，合并等等方式处理的。 Observable，被观察者，被订阅者，可被观察的，他是数据和事件发射的源，他在 RxJava 中是有多种实现方式，这里不是说的哪个类，而是一种泛指。 Observer／Subscriber，观察者，订阅者，他是事件接受者。 整体来看，可以理解为一条事件流，被观察者在上游发送事件，观察者在下游接受事件，中游会有很多针对事件的处理和变换，这样理解更简单一些，也更有助于理解背压(Backpressure)的存在。为了更好的理解，避免叙述的混乱，文章中我会用 上游 和 下游 这样的描述来代替 被观察者 和 观察者。 使用 Observable创建一个最简单的 Observable，发送 Integer 类型的数据，RxJava 有很多创建 Observable 的简单方法，我们暂时就使用最原始的那种，方便理解。 ObservableEmitter 继承 Emitter，是一个数据发射器，用来向观察者发送数据。 123456789101112// 创建 ObservableObservable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; // 发射数据 e.onNext(1); e.onNext(2); // 结束发送 e.onComplete(); e.onNext(3); &#125;&#125;); 创建一个 Observer，接受数据并打印。 123456789101112131415161718Observer&lt;Integer&gt; observer = new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(@NonNull Disposable d) &#123; log("onSubscribe"); &#125; @Override public void onNext(@NonNull Integer integer) &#123; log("onNext == &gt; " + integer); &#125; @Override public void onError(@NonNull Throwable e) &#123; log("onError"); &#125; @Override public void onComplete() &#123; log("onComplete"); &#125;&#125;; 实现订阅，查看结果。 123456789observable.subscribe(observer);// 结果如下，3 不会被打印---------------[ThreadName:pool-13-thread-1] onSubscribe[ThreadName:pool-13-thread-1] onNext == &gt; 1[ThreadName:pool-13-thread-1] onNext == &gt; 2[ThreadName:pool-13-thread-1] onComplete--------------- 这样我们就实现了一个简单的订阅流程，完成了数据的传递，总结以下要点： ObservableEmitter 继承 Emitter，是一个发射器，用来向下游发送事件，它可以发送如下3种事件，也对应下游订阅者的相关方法。 12345public interface Emitter&lt;T&gt; &#123; void onNext(@NonNull T value); void onError(@NonNull Throwable error); void onComplete();&#125; 上游和下游的所有方法都默认运行在当前所在线程内，如上运行结果，我在子线程运行则所有方法会在子线程调用。 订阅发生在 observable.subscribe(observer); 时，此时上游才开始发送事件，并且 onSubscribe() 方法会在开始订阅时首先执行。 上游可以发送无数个 onNext(T t) 事件，下游都可以接受到。 当上游发送 onComplete() 事件之后，上游的事件会继续发送，但是下游在接受到 onCompelete() 事件之后就会切换事件流，不会在接受后续的事件，因此发送多个 onComplete() 虽然不会导致程序 crash，但是是无意义的。 当上游发送 onError() 事件之后，上游的事件会继续发送，但是下游在接受到 onError() 事件之后就会切换事件流，不会在接受后续的事件，当你发送第二个 onError() 事件时会导致程序 crash。 发送 onComplete() 和 onError() 事件不是必须的。 onComplete() 和 onError() 是唯一且互斥的，你不能发送多个 onComplete() 或多个 onError()，也不能不能发送一个 onCompelete() 事件再发送 onError()，反过来也是。 中断事件流Disposable 对象可用用来切断事件流，在 onSubscribe() 被调用时会返回 Disposable 对象，我们在获取到数字 4 时切断事件流。将上面的代码稍微简化一下 12345678910111213141516171819202122232425262728293031323334353637// 创建 ObservableObservable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; // 发射数据 e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onNext(5); // 结束发送 e.onComplete(); e.onNext(6); &#125;&#125;).subscribe(new Observer&lt;Integer&gt;() &#123; Disposable mDisposable; @Override public void onSubscribe(@NonNull Disposable d) &#123; mDisposable = d; log("onSubscribe"); &#125; @Override public void onNext(@NonNull Integer integer) &#123; log("onNext == &gt; " + integer); if (integer == 4) &#123; mDisposable.dispose(); &#125; &#125; @Override public void onError(@NonNull Throwable e) &#123; log("onError"); &#125; @Override public void onComplete() &#123; log("onComplete"); &#125;&#125;); 结果为 12345[ThreadName:pool-13-thread-1] onSubscribe[ThreadName:pool-13-thread-1] onNext == &gt; 1[ThreadName:pool-13-thread-1] onNext == &gt; 2[ThreadName:pool-13-thread-1] onNext == &gt; 3[ThreadName:pool-13-thread-1] onNext == &gt; 4 其他订阅方法在实际应用过程中我们可能并不关注下游所有的接受事件的方法，因此 RxJava 提供了多种订阅方式来简化订阅过程。 这里说一下 Action 和 Consumer，与 RxJava1.x 不同，没有使用 ActionN 这种命名方式。 Action 是无参无返回值的接口，它可以用来替代类似 onComplete() 这种无参无返回值值的方法。 123public interface Action &#123; void run() throws Exception;&#125; Consumer 是单个参数无返回值的接口，它可以用来代替类似 onSubscribe(@NonNull Disposable d)，onNext(@NonNull Integer integer)，onError(@NonNull Throwable e) 这类单个参数无返回值的方法。 123public interface Consumer&lt;T&gt; &#123; void accept(@NonNull T t) throws Exception;&#125; 重载的订阅方法，除了以 Observer 的方式订阅之外，其他方法都返回 Disposable 对象用来中断事件流。 1234567891011121314151617// 下游不关注上游的任何事件public final Disposable subscribe()// 观察者public final void subscribe(Observer&lt;? super T&gt; observer)// 只关注 onNext() 事件public final Disposable subscribe(Consumer&lt;? super T&gt; onNext) // 只关注 onNext() onError() public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError)// 只关注 onNext() onError() onComplete()public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError,Action onComplete)// 只关注 onNext() onError() onComplete() onSubscribe()public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete, Consumer&lt;? super Disposable&gt; onSubscribe) 使用只关注 onNext() 事件的订阅方法实现订阅。 123456789101112131415Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; // 发射数据 e.onNext(1); e.onNext(2); // 结束发送 e.onComplete(); &#125;&#125;).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; log("use Consumer onNext = &gt; " + integer); &#125;&#125;); 对 Observable 的介绍相对详细，下面的介绍会简单一些，因为很多相似的地方，就不再赘述了。 使用 FlowableFlowable 与 Observable 的区别就是实现了 背压(Backpressure) 的管理，讲真，我对背压这个概念也理解的不是很全面，概括的讲背压就是上游发送的事件太多，下游处理事件的速度太慢，导致上游事件堆积，此时如何处理堆积的事件，就是背压处理的策略。 背压处理策略，在 RxJava2.x 中 Observable 不再支持背压，需要支持背压时需要使用 Flowable 创建被观察者，并要求明确指定背压处理策略。 关于 Flowable 和 Backpressure 的内容后面作单独研究，这里不展开。 123456public enum BackpressureStrategy &#123; ERROR, BUFFER, DROP, LATEST&#125; 实现一个订阅，支持背压时，需要在下游调用 request(long n) 来向上游请求，自己要多少数据，请求多少数据上游就会发多少数据过来，如下实例中，只会获取到一次事件。 123456789101112131415161718192021222324252627Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull FlowableEmitter&lt;Integer&gt; e) throws Exception &#123; for (int i = 0; i &lt; 10; i++) &#123; e.onNext(i); &#125; e.onComplete(); &#125;&#125;, BackpressureStrategy.BUFFER).subscribe(new FlowableSubscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; log("onSubscribe"); s.request(1); &#125; @Override public void onNext(Integer integer) &#123; log("onNext == &gt; " + integer); &#125; @Override public void onError(Throwable t) &#123; log("onError"); &#125; @Override public void onComplete() &#123; log("onComplete"); &#125;&#125;); 中断事件流Subscription 类似于 Observable 中的 Disposable，可以用来中断事件流，不同的是需要使用 cancel() 方法，另外有另一个 request(long n) 方法用来向上游请求数据。 1234public interface Subscription &#123; public void request(long n); public void cancel();&#125; 如下，使用 Subscription 中断事件。 12345678910111213141516171819202122232425262728Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull FlowableEmitter&lt;Integer&gt; e) throws Exception &#123; for (int i = 0; i &lt; 10; i++) &#123; e.onNext(i); &#125; e.onComplete(); &#125;&#125;, BackpressureStrategy.BUFFER).subscribe(new FlowableSubscriber&lt;Integer&gt;() &#123; Subscription mSubscription; @Override public void onSubscribe(Subscription s) &#123; log("onSubscribe"); mSubscription = s; s.request(1); &#125; @Override public void onNext(Integer integer) &#123; log("onNext == &gt; " + integer); mSubscription.request(5); if (integer == 5) &#123; mSubscription.cancel(); &#125; &#125; // ... &#125;); 关于 request下游请求多少就会收到多少事件，但是不会阻塞上游事件发送的过程，上游的事件会一直发，但是下游没请求的话接受不到事件。 request(long n) 中的数量是会累加的，累加的数量就是请求的总量，如果请求的总量超过了发送的总量，则上游事件会被全部接受到，但是不会多出来。 如下实例中，总共请求了 1 + 2 + 2 = 5 次事件，因此只收到了 5 次事件，但是上游的事件发送并没有停止。 1234567891011121314151617181920212223242526Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull FlowableEmitter&lt;Integer&gt; e) throws Exception &#123; for (int i = 0; i &lt; 10; i++) &#123; log("send next " + i); e.onNext(i); &#125; e.onComplete(); &#125;&#125;, BackpressureStrategy.BUFFER).subscribe(new FlowableSubscriber&lt;Integer&gt;() &#123; Subscription mSubscription; @Override public void onSubscribe(Subscription s) &#123; log("onSubscribe"); mSubscription = s; s.request(1); &#125; @Override public void onNext(Integer integer) &#123; log("onNext == &gt; " + integer); if(integer == 0 || integer == 1) &#123; mSubscription.request(2); &#125; &#125; // ...&#125;); 输出结果 12345678910111213141516[ThreadName:pool-13-thread-1] onSubscribe[ThreadName:pool-13-thread-1] send next 0[ThreadName:pool-13-thread-1] onNext == &gt; 0[ThreadName:pool-13-thread-1] send next 1[ThreadName:pool-13-thread-1] onNext == &gt; 1[ThreadName:pool-13-thread-1] send next 2[ThreadName:pool-13-thread-1] onNext == &gt; 2[ThreadName:pool-13-thread-1] send next 3[ThreadName:pool-13-thread-1] onNext == &gt; 3[ThreadName:pool-13-thread-1] send next 4[ThreadName:pool-13-thread-1] onNext == &gt; 4[ThreadName:pool-13-thread-1] send next 5[ThreadName:pool-13-thread-1] send next 6[ThreadName:pool-13-thread-1] send next 7[ThreadName:pool-13-thread-1] send next 8[ThreadName:pool-13-thread-1] send next 9 其他订阅方法Flowable 跟 Observable 一样对订阅操作也有很多重载方法，可以参照Obervable#其他订阅方法。 更多被观察者实现我现在还不太清楚它们之间的关系，就先列举一下 API，后面有机会再仔细看看 Maybe 123456789101112131415161718Maybe.create(new MaybeOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull MaybeEmitter&lt;Integer&gt; e) throws Exception &#123; &#125;&#125;).subscribe(new MaybeObserver&lt;Integer&gt;() &#123; @Override public void onSubscribe(@NonNull Disposable d) &#123; &#125; @Override public void onSuccess(@NonNull Integer integer) &#123; &#125; @Override public void onError(@NonNull Throwable e) &#123; &#125; @Override public void onComplete() &#123; &#125;&#125;); Completable 123456789101112131415Completable.create(new CompletableOnSubscribe() &#123; @Override public void subscribe(@NonNull CompletableEmitter e) throws Exception &#123; &#125;&#125;).subscribe(new CompletableObserver() &#123; @Override public void onSubscribe(@NonNull Disposable d) &#123; &#125; @Override public void onComplete() &#123; &#125; @Override public void onError(@NonNull Throwable e) &#123; &#125;&#125;); Single 123456789101112131415Single.create(new SingleOnSubscribe&lt;Object&gt;() &#123; @Override public void subscribe(@NonNull SingleEmitter&lt;Object&gt; e) throws Exception &#123; &#125;&#125;).subscribe(new SingleObserver&lt;Object&gt;() &#123; @Override public void onSubscribe(@NonNull Disposable d) &#123; &#125; @Override public void onSuccess(@NonNull Object o) &#123; &#125; @Override public void onError(@NonNull Throwable e) &#123; &#125;&#125;);]]></content>
      <categories>
        <category>Android</category>
        <category>Library</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RxJava2.x</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Retrofit开发-1-基础]]></title>
    <url>%2Farticle%2Fe57450c6%2F</url>
    <content type="text"><![CDATA[Retrofit 本文介绍 OkHttp 和 Retrofit 的基本使用，包括： 创建和配置 OkHttpClient 创建和配置 Retrofit 如何使用 Retrofit 定义接口发起请求 关于 Retrofit 中 method，path，query param，body，Header 注解声明的介绍。 添加依赖1234567891011121314// 网络请求okhttp3 : 'com.squareup.okhttp3:okhttp:3.4.2',// 单元测试，未用okhttp3Mockwebserver : 'com.squareup.okhttp3:mockwebserver:3.4.2',// 调试工具类库stetho : 'com.facebook.stetho:stetho:1.4.2',stetho_okhttp3 : 'com.facebook.stetho:stetho-okhttp3:1.4.2',// json解析gson : 'com.google.code.gson:gson:2.6.1',// retrofit 2.0retrofit : 'com.squareup.retrofit2:retrofit:2.3.0',converter_gson : 'com.squareup.retrofit2:converter-gson:2.1.0',// 日志打印logging_interceptor : 'com.squareup.okhttp3:logging-interceptor:3.8.0', 创建 OkHttpRetrofit 是对 OkHttp 的封装，提供了使用注解更简单的构建各种请求，配置各种参数的方式。本质发起网络请求的还是 OkHttp，但 Retrofit 让这一操作更加的简单优雅。 创建一个 OkHttpClent 并进行简单配置 12345678910111213141516171819202122232425262728/** * 创建 OkHttpClient * * @return OkHttpClient */private OkHttpClient buildOkHttpClient() &#123; OkHttpClient.Builder okHttpBuilder = new OkHttpClient.Builder(); // 连接超时 okHttpBuilder.connectTimeout(5 * 1000, TimeUnit.MILLISECONDS); // 读超时 okHttpBuilder.readTimeout(5 * 1000, TimeUnit.MILLISECONDS); // 写超时 okHttpBuilder.writeTimeout(5 * 1000, TimeUnit.MILLISECONDS); // 清除 interceptors okHttpBuilder.interceptors().clear(); okHttpBuilder.networkInterceptors().clear(); // 自定义 Interceptor，用来添加全局 Header okHttpBuilder.addNetworkInterceptor(new HeaderInterceptor()); // 自定义 Interceptor，进行日志打印，扩展自 HttpLoggingInterceptor okHttpBuilder.addNetworkInterceptor(new LogInterceptor(LogInterceptor.Level.BOTH)); // 失败后重试 okHttpBuilder.retryOnConnectionFailure(true); // face book 调试框架 okHttpBuilder.addNetworkInterceptor(new StethoInterceptor()); // token校验，返回 403 时 okHttpBuilder.authenticator(new TokenAuthenticator()); return okHttpBuilder.build();&#125; 创建 RetrofitOkHttp 只负责发起网络请求，维护网络连接等操作，而 Retrofit 帮我们将网络传输的数据转换为可用的 model 对象，并且提供简单的数据处理方式。 配置 CallAdapterFactory 为 RxJava2CallAdapterFactory.createWithScheduler(Schedulers.io()) 用来将返回的数据转换为 RxJava 的 Observable 对象，但是本文还没涉及到 RxJava 的部分。 配置 ConverterFactory 为 GsonConverterFactory.create(new Gson()) 用来使用 GSON 将网络数据序列化为可用对象。 ps：baseUrl 要求以 / 结尾，而请求的 path 要求不以 / 开头，也就是说我们需要类似 https://www.baidu.com/ 的形式。 12345678910111213141516171819/** * 创建 retrofit * * @param okHttpClient client * @return retrofit */private Retrofit buildRetrofit(OkHttpClient okHttpClient) &#123; final Retrofit.Builder retrofitBuilder = new Retrofit.Builder(); // client retrofitBuilder.client(okHttpClient); // baseUrl retrofitBuilder.baseUrl(BASE_URL); // rxJava 调用 adapter retrofitBuilder.addCallAdapterFactory( RxJava2CallAdapterFactory.createWithScheduler(Schedulers.io())); // 数据转换 adapter retrofitBuilder.addConverterFactory(GsonConverterFactory.create(new Gson())); return retrofitBuilder.build();&#125; 创建 api 服务接口创建接口类，使用注解声明网络请求的方法和相关参数，这里只是一个简单的例子，更多参数和配置将在后面说明，如： 1234567public interface ApiService &#123; String GET_USER_INFO = "api/v1/user/info"; @GET(GET_USER_INFO) Call&lt;UserInfoDTOResponse&gt; getUser(@Header("Authorization") String auth);&#125; 使用 Retrofit 初始化 ApiService，获取到 ApiService 的实例之后就可以使用该实例发起请求。 我使用 ApiRequest 持有 ApiService 的实例，同时 ApiRequest 是一个单例，作为发起网络请求的管理者。 1234private void createService() &#123; Retrofit retrofit = buildRetrofit(buildOkHttpClient()); mApiService = retrofit.create(ApiService.class);&#125; 发起请求 12345678910111213141516171819public static void getUserInfo() &#123; // 从单例中获取 ApiService ApiService service = ApiRequest.getService(); // 创建请求 Call&lt;UserInfoDTOResponse&gt; userCall = service.getUser(); // 发起请求 userCall.enqueue(new Callback&lt;UserInfoDTOResponse&gt;() &#123; @Override public void onResponse(@NonNull Call&lt;UserInfoDTOResponse&gt; call,@NonNull Response&lt;UserInfoDTOResponse&gt; response) &#123; UserInfoDTOResponse body = response.body(); if (body != null &amp;&amp; body.getData() != null) &#123; L.e(TAG, body.getData().toString()); &#125; &#125; @Override public void onFailure(@NonNull Call&lt;UserInfoDTOResponse&gt; call,@NonNull Throwable t) &#123; &#125; &#125;);&#125; 下面对 Retrofit 中 method,path,qurey,body,header几个部分分别说明。 MethodRetrofit 支持 GET，POST，PUT，DELETE，HEAD，OPTION 等请求方式，并有对应的注解。 12345@GET(GET_USER_INFO)Call&lt;UserInfoDTOResponse&gt; getUser();@DELETE(DELETE_RM_BABY)Call&lt;BaseResponse&gt; deleteBaby(@Path(PATH_BABY_ID) Long babyId); PATH请求路径，请求路径中可以包含参数，并在参数中使用 @PATH 注解来动态改变路径，比如路径 api/v1/user/{id}，使用注解 @PATH(&quot;id&quot;) Long id 即可改变路径中 {id} 请求时的值。 12345678910// path 中不包含参数@GET(GET_USER_INFO)Call&lt;UserInfoDTOResponse&gt; getUser();String PATH_BABY_ID = "babyId";String PUT_EDIT_BABY = "api/v2/baby/doEdit/&#123;" + PATH_BABY_ID + "&#125;";@PUT(PUT_EDIT_BABY)Call&lt;BaseResponse&gt; putEditBaby(@Path(PATH_BABY_ID) Long babyId); Body发送 POST 、PUT 请求时通常需要携带 body 数据，使用 @Body 注解，如下： 12@PUT(PUT_EDIT_BABY)Call&lt;BaseResponse&gt; putEditBaby(@Body BabyParam babyParam); Query配置 UrlQuery 参数，比如 api/v1/user/list?limit=100&amp;offset=10 这种类型。有两种配置方式： 第一种使用 @Query 注解，如 @Query(&quot;userId&quot;) Long userId 的形式。这种形式可以传递 null 值，如果某个参数为 null，将不会拼接在 url 后面。 第二种使用 @QueryMap 注解，如 @QureyMap Map&lt;String,String&gt; params 的形式。这种形式传递一个 map 作为参数，但是 map 中 value 不能为 null，否则会抛出异常。 12345@GET(GET_BABY_RELATION_LIST)Call&lt;UserBabyRelationResp&gt; getBabyRelationList(@Query("babyId") Long babyId, @Query("limit") int limit, @Query("offset") Long offset);@GET(GET_BABY_RELATION_LIST)Call&lt;UserBabyRelationResp&gt; getBabyRelationList(@QueryMap Map&lt;String,String&gt; map); Header静态 Header，使用 @Headers 注解添加在请求接口上，用法如下： 123456789101112@Headers(&#123;"key:value","key:value"&#125;)@Headers("key:value")eg:@Headers(&#123;"Authorization: authValue", "User-Agent: Retrofit-Sample-App"&#125;)@GET(GET_USER_INFO)Call&lt;UserInfoDTOResponse&gt; getUser();@Headers("Authorization: authValue")@GET(GET_USER_INFO)Call&lt;UserInfoDTOResponse&gt; getUser(); 局部动态 Header，使用 @Header(&quot;key&quot;) 和 @HeaderMap 注解添加在请求参数上，动态配置，用法如下： 12345678910@Header("Authorization") String auth// retrofit:2.1.0 添加@HeaderMap Map&lt;String, String&gt; headerseg:@GET(GET_USER_INFO)Call&lt;UserInfoDTOResponse&gt; getUser(@Header("Authorization") String auth);@GET(GET_USER_INFO)Call&lt;UserInfoDTOResponse&gt; getUser(@HeaderMap Map&lt;String, String&gt; headers); 全局配置 Header，为 OkHttp 添加 Interceptor，需要注意的是 addNetWorkIntercepror() 和 addInterceptor() 的区别。当进入 netWorkInterceptor 时已经添加了 User-Agent 等 Header，此时要把自己的 Header 一个一个 addHeader() 进去，防止把原来的冲掉。 1234567891011121314151617181920212223242526272829public final class HeaderInterceptor implements Interceptor &#123; public static final String TAG = HeaderInterceptor.class.getSimpleName(); // 到达 netWorkInterceptor 时，默认 header 已经添加，不能使用替换的方式，要使用 addHeader 的方式 // 到达 interceptor 时，还没有添加默认 header ,可以直接替换原来的 header ，后面会追加默认 header @Override public Response intercept(@NonNull Chain chain) throws IOException &#123; Request request = chain.request(); L.e(TAG, "添加全局 header "); Request.Builder builder = request.newBuilder(); Map&lt;String, String&gt; headersMap = ApiRequest.getHeadersMap(); for (String key : headersMap.keySet()) &#123; builder.addHeader(key, headersMap.get(key)); &#125; Response response; try &#123; response = chain.proceed(builder.build()); &#125; catch (Exception e) &#123; e.printStackTrace(); throw e; &#125; return response; &#125;&#125;OkHttpClient.Builder okHttpBuilder = new OkHttpClient.Builder();okHttpBuilder.addNetworkInterceptor(new HeaderInterceptor()); Todo更多内容还没有涉及… 1234567891011// 表单提交@FormUrlEncoded@POST("user/edit")@HEADCall&lt;User&gt; updateUser(@Field("first_name") String first, @Field("last_name") String last);// 文件上传@Multipart@PUT("user/photo")Call&lt;User&gt; updateUser(@Part("photo") RequestBody photo, @Part("description") RequestBody description);]]></content>
      <categories>
        <category>Android</category>
        <category>Library</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Library</tag>
        <tag>Retrofit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[改变]]></title>
    <url>%2Farticle%2F3443742407%2F</url>
    <content type="text"><![CDATA[2017年6月29日早8点 小雨 上周周末看了《变形金刚5》，然后睡了整整两天，周日的晚上有种强烈的负罪感，感觉简直就是在浪费生命，于是就把今日头条、微博、爱奇艺、哔哩哔哩、土豆等软件全都卸载了，留下了脉脉、CSDN、知乎… 到今天已经是第四天，这几天一直坚持晚上11点钟左右睡觉，早上7点钟到8点钟之间起床，有点危机感，这样下去终归是不行的。今天早上7点多睁眼看了一篇文章，是一篇面经，看了他总结的面试知识点，十之八九都答不上来。感觉一直在工作的过程中都是实现为主，堆砌代码，原理、算法什么的好久没去管过，很早之前还会去看一眼源码，分析一下，现在根本没那个积极性，是时候得改变一下，多学点东西才有选择的权力。 总有一天我也要变的很🐂x。革命尚未成功，同志仍需努力。 附面经 一年Android工作经验，一举拿下百度、网易、美团、小米、快手等Offer面经 查到了这个🐂人的博客地址，不过貌似打不开CSDN]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我为什么要写博客]]></title>
    <url>%2Farticle%2Fd8c55445%2F</url>
    <content type="text"><![CDATA[2017年11月21日晚22:13 又下雨 我为什么要写博客？ 很早之前在 CSDN 写，那个时候单纯的还是整理知识，然后写点东西出来，马上去各种群里推广，增加浏览量，也为了虚荣心。再后来，用 Hexo + NexT 搭建了这个博客，自己做域名解析，有那么一段时间，也会很希望，自己的博客被别人看见，就去做 SEO，结果不算理想，因为我的博客总的来说还是笔记形式的，可能没有太多很深入的东西，内容不足够吸引人，到现在，我已经完全把这个博客自己的笔记来用，遇到问题，如果以前整理过就打开自己的博客，搜索一下，就能找到原本忘记的答案。 很多东西我都是在初学阶段，像前端，像 weex还有 Kotlin 等，都是看官方文档，然后写 demo，再整理成我的博客，我有时候就在想，我所写的东西，官方文档明明都有，我还有必要再去写一篇博客去整理吗？ 答案肯定是有必要，不然我也不会一直坚持写。 慢慢的我发现，每次学一个东西，学完了整理成我自己的文档已经成为了习惯，否则就好像没学过一样，为什么有必要，我有以下几点考虑： 官方文档确实全面，相比我自己的博客，不可能把全部内容都摘到我的博客中，但我想的是，文档是给所有人看的，我的博客是给我看的，里面不光有文档里面的知识点，还有我初学这个东西一路踩的坑和我找到的解决方案，我把它做重点在博客中提醒自己，对我而言更容易避免再出现类似的错误。 官方文档会一直更新，有人维护，也许有一天我当初学习的时候记下的这篇博客里面的内容已经慢慢落后了，我觉得实际上应该是，当官方做了更新，我再去学习这些更新的地方，并把它转化，更新到我自己的博客中，不过，这点总会有些力不从心。 总而言之，我学习别人的东西，看一遍，甚至是敲一遍代码，转眼过去就跟喝凉水一样，什么都记不住，我一边学，一边把要点、心得记录下来，当然这并不能阻止我忘记那些东西，但是当我忘记时，不需要再去查找很久，只需要打开我的博客，找到对应的地方， 看一下当时是如何理解，如何思考记忆的，就会想起来。长远来说这对我对学习的东西的理解和沉淀都有好处。 写这些，是希望有一天我对整理博客感到厌倦或者又开始怀疑这样做的必要性时，能提醒自己，这样做是对的，要坚持。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebView]]></title>
    <url>%2Farticle%2F3518734228%2F</url>
    <content type="text"><![CDATA[本文记录 Android 中 WebView 控件的相关使用，不断完善中… 主要包括： 基本属性的配置 WebView 缓存相关内容 Java 与 Js 的交互 打开本地应用(支付宝等) 加载远程网页，本地网页，assert 目录下的网页 支持自定义下载 自定义 WebChromeClient 本地化弹窗、文件选择 更详细的扩展实现都可以在 GitHub-WebKit 中找到。 基本配置汇总汇总的记录一下 WebView 的配置方法，重要的属性后面会展开说明。 123456789101112131415161718192021222324252627282930313233343536373839@SuppressLint("SetJavaScriptEnabled")public static void initWebViewSettings(WebView mWebView) &#123; //支持获取手势焦点 mWebView.requestFocusFromTouch(); // 触觉反馈，暂时没发现用处在哪里 mWebView.setHapticFeedbackEnabled(false); WebSettings settings = mWebView.getSettings(); // 支持插件 settings.setPluginState(WebSettings.PluginState.ON); // 允许js交互 settings.setJavaScriptEnabled(true); // 设置WebView是否可以由 JavaScript 自动打开窗口，默认为 false // 通常与 JavaScript 的 window.open() 配合使用。 settings.setJavaScriptCanOpenWindowsAutomatically(true); // 允许中文编码 settings.setDefaultTextEncodingName("UTF-8"); // 使用大视图，设置适应屏幕 settings.setUseWideViewPort(true); settings.setLoadWithOverviewMode(true); // 支持多窗口 settings.setSupportMultipleWindows(true); // 隐藏自带缩放按钮 settings.setBuiltInZoomControls(false); // 支持缩放 settings.setSupportZoom(true); // 设置可访问文件 settings.setAllowFileAccess(true); // 当WebView调用requestFocus时为WebView设置节点 settings.setNeedInitialFocus(true); //支持自动加载图片 settings.setLoadsImagesAutomatically(true); // 指定WebView的页面布局显示形式，调用该方法会引起页面重绘。 // NORMAL,SINGLE_COLUMN 过时, NARROW_COLUMNS 过时 ,TEXT_AUTOSIZING settings.setLayoutAlgorithm(WebSettings.LayoutAlgorithm.SINGLE_COLUMN); // 从Lollipop(5.0)开始WebView默认不允许混合模式，https当中不能加载http资源，需要设置开启 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; settings.setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW); &#125;&#125; WebView 缓存清除缓存，true 表示清除磁盘缓存，这个方法是全局的，也就是说会清除掉整个应用所有的 网页缓存。 1mWebView.clearCache(true); 清除历史记录 1mWebView.clearHistory(); 网上有介绍说，设置缓存的目录，清除缓存时删除掉缓存文件，但是使用下面的方法设置缓存路径后，发现文件并没有缓存到指定的目录，不知道是怎么回事？求指教 缓存模式 描述 LOAD_DEFAULT 默认的缓存使用模式。在进行页面前进或后退的操作时，如果缓存可用并未过期就优先加载缓存，否则从网络上加载数据。这样可以减少页面的网络请求次数。 LOAD_CACHE_ELSE_NETWORK 只要缓存可用就加载缓存，哪怕它们已经过期失效。如果缓存不可用就从网络上加载数据。 LOAD_NO_CACHE 不加载缓存，只从网络加载数据。 LOAD_CACHE_ONLY 不从网络加载数据，只从缓存加载数据。 123456789101112131415161718private static void initWebViewCache(WebView mWebView) &#123; String cachePath = new File(Environment.getExternalStorageDirectory() , "webCache").getAbsolutePath(); WebSettings settings = mWebView.getSettings(); settings.setAppCacheEnabled(true); settings.setAppCachePath(cachePath); settings.setDatabaseEnabled(true); // 过时 settings.setDatabasePath(cachePath); // 开启dom缓存 settings.setDomStorageEnabled(true); // 加载模式 settings.setCacheMode(WebSettings.LOAD_NO_CACHE); // 缓存最大值，过时 settings.setAppCacheMaxSize(1000 * 1024);&#125; 加载 Url加载网络路径，headers 不是必选的 123Map&lt;String,String&gt; headers = new HashMap&lt;&gt;();headers.put("auth","110");mWebView.loadUrl("https://www.baidu.com/",headers); 加载 assert 路径 123456// WebViewUtil.javapublic static String getAssertUrl(String fileUrl) &#123; return "file:///android_asset/" + fileUrl;&#125;mWebView.loadUrl(WebViewUtil.getAssertUrl("index.html")); 加载 sd 卡路径 123456// WebViewUtil.javapublic static String getSdUrl(String fileUrl) &#123; return "file://" + Environment.getExternalStorageDirectory() + "/" + fileUrl;&#125;mWebView.loadUrl(WebViewUtil.getSdUrl("index.html")); Js 调用 JavaJava 与 Js 交互需要定义一个带有 @JavascriptInterface 注解方法的对象，如下： 123456789101112public class JsBridge &#123; @JavascriptInterface public void toast(String msg) &#123; ToastUtils.show(msg); &#125; @JavascriptInterface public void log(String msg) &#123; Log.e(TAG, msg); &#125;&#125; 使用 JsBridge 连接 Java 和 Js，使用 mWebView.addJavascriptInterface(obj, name); 方法。 obj：带有 JavascriptInterface 注解方法的对象实例。 name：一个标志符，js 将会使用该标志来调用 java 层的方法。 12mWebView.getSettings().setJavaScriptEnabled(true);mWebView.addJavascriptInterface(new JsBridge(), "android"); 在添加调用接口时，我们添加了一个标记，如上面代码中添加的是 android，它相当于调用接口对象的一个别名，因此在 js 中调用 java 方法时，只需要使用 window 对象，如下: 1window.android.log('test js invoke java method'); Java 调用 Js使用 java 调用 js 方法相对简单，假如在 js 中应该声明如下 function， 123456789101112&lt;script&gt;// 有参无返回值 function funcParam(param)&#123; alert(param+""); &#125; // 有参有返回值 function newFunc(param1,param2,param3)&#123; alert((param1 + param2) + " " + param3); return param3; &#125;&lt;/script&gt; 在 java 层调用时只需 loadUrl(&quot;Javascript:js方法名()) 即可，但是 Android 4.4 之后在调用 js 方法时可以获取返回值，写一个方法兼容一下 12345678910111213public static final String JS_FUNC_PREFIX = "javascript:";public void invokeJs(String jsFunc, final ValueCallback&lt;String&gt; callback) &#123; if (!jsFunc.startsWith(JS_FUNC_PREFIX)) &#123; jsFunc = JS_FUNC_PREFIX + jsFunc; &#125; // api 19 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; mWebView.evaluateJavascript(jsFunc, callback); &#125; else &#123; mWebView.loadUrl(jsFunc); &#125;&#125; 在与 js 进行参数传递时，基本数据类型可以直接传递，字符串类型要使用引号包含，而且直接拼接字符串不太好，因此写一个简化构建 js 方法，自动按顺序进行参数的拼接。 123456789101112131415161718// 创建一个 js 方法public static String generateJsFunc(String funcName, Object... params) &#123; StringBuilder sb = new StringBuilder(funcName).append("("); for (int i = 0; i &lt; params.length; i++) &#123; if (params[i] != null) &#123; if (params[i] instanceof String) &#123; sb.append("'").append(params[i]).append("'"); &#125; else &#123; sb.append(params[i]); &#125; if (i != params.length - 1) &#123; sb.append(","); &#125; &#125; &#125; sb.append(")"); return sb.toString();&#125; 简单调用 123456789101112// 调用有参有返回值的方法String jsFunc = JsBridge.generateJsFunc("newFunc", "str", 100, 100);mJsBridge.invokeJs(jsFunc, new ValueCallback&lt;String&gt;() &#123; @Override public void onReceiveValue(String value) &#123; Log.e(TAG, "value = " + value); &#125;&#125;);// 调用有参无返回值方法String funcParam = JsBridge.generateJsFunc("funcParam", 100);mJsBridge.invokeJs(funcParam, null); 拦截 Url 打开应用(支付宝)主要原理是由于某些应用会暴露一些页面出来供别的 app 唤起，因此我们只需要拦截这种 Url，然后使用 intent 打开即可，下面以支付宝为例说明： 前端使用支付宝进行支付时，需要打开手机支付宝客户端，断点看到支付宝会加载一个 scheme 为 alipays 的url，链接中配置了支付的相关信息，客户端要做的就是拦截该 Url，使用 intent 打开支付宝。 当 html 加载网页之前会先走 shouldOverrideUrlLoading() 方法，此时截断不使用 webView 加载，而是使用 intent 打开，此方法不仅适用支付宝，也适用打开其他应用。 12345678910111213141516171819202122232425262728293031323334mWebView.setWebViewClient(new WebViewClient() &#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; // 如果不使用 intent 覆盖加载这个链接，就走原来 if (!shouldOverrideIntentUrl(getContext(), url)) &#123; view.loadUrl(url, Api.makeHttpHeaders(getContext())); &#125; return true; &#125;&#125;);public static final String ALIPAY_SCHEME = "alipays";public static boolean shouldOverrideIntentUrl(Context context, String url) &#123; Uri uri = Uri.parse(url); if (uri != null &amp;&amp; uri.getScheme() != null &amp;&amp; uri.getScheme().equals(ALIPAY_SCHEME)) &#123; try &#123; Intent intent = Intent.parseUri(url, Intent.URI_INTENT_SCHEME); intent.addCategory(Intent.CATEGORY_BROWSABLE); intent.setComponent(null); intent.setSelector(null); context.startActivity(intent); &#125; catch (Exception e) &#123; e.printStackTrace(); if (e instanceof ActivityNotFoundException) &#123; ToastUtil.show("未检测到支付宝客户端"); &#125; return true; &#125; return true; &#125; return false;&#125; 支持下载链接当网页中加载一个下载的链接，如 http://xxx.apk 这种链接，会走 shouldOverrideUrlLoading() 方法，但是，它是无法加载一个网页的，结果就是没有任何反应，此时需要设置 DownloadListener，需要下载的链接会进入监听，你可以在监听中自己进行网络下载保存到文件，下面我使用直接打开浏览器的方式，更简单一些。 12345678910111213141516171819public static void setDefDownloadListener(final WebView webView) &#123; webView.setDownloadListener(new DownloadListener() &#123; @Override public void onDownloadStart(String url, String userAgent, String contentDisposition, String mimetype, long contentLength) &#123; //去下载 Intent intent = new Intent(Intent.ACTION_VIEW); String downLoadUrl = url; if (!downLoadUrl.contains("http://")) &#123; downLoadUrl = "http://" + downLoadUrl; &#125; intent.setData(Uri.parse(downLoadUrl)); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); webView.getContext().startActivity(intent); &#125; &#125;);&#125; WebChromeClient本地化弹窗WebView 默认是无法弹出 alert() 的，需要设置 WebChromeClient 1mWebView.setWebChromeClient(new WebChromeClient()); 从网页上弹起的弹窗与设备整体风格不是很搭，需要重载 onJsAlert()、onJsConfirm() 和 onJsPrompt() 来将弹窗本地化。JavaScript 与本地方法对应如下： 123456// 提示 返回值为 undefind - onJsAlert()var result = alert("test");// 确认和取消 返回值为 true | falsevar result = confirm("test"); - onJsConfirm()// 用户输入 返回值为用户输入的内容 - onJsPrompt()var result = prompt("message","default"); 以 onJsConfirm() 为例实现响应用户输入的方法，使用 JsResult 向 JavaScript 返回值，否则网页端会一直阻塞，不能操作。 1234567891011121314151617181920212223@Overridepublic boolean onJsConfirm(WebView view, String url, String message, final JsResult result) &#123; new AlertDialog.Builder(view.getContext()) .setCancelable(false) .setMessage(message) .setPositiveButton("确定", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; result.confirm(); dialog.dismiss(); &#125; &#125;) .setNegativeButton("取消", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; result.cancel(); dialog.dismiss(); &#125; &#125;) .create() .show(); return true;&#125; 文件选择需要重载 onShowFileChooser() 方法，使用 Intent 打开文件选择，然后返回文件，在 api21 以上提供了一些特有的方法，在这个版本以下要自己适配。 123456789101112131415161718192021222324252627@Overridepublic boolean onShowFileChooser(WebView webView, ValueCallback&lt;Uri[]&gt; filePathCallback, FileChooserParams fileChooserParams) &#123; if (mActivity == null) return false; /* How to use: 1. Build an intent using &#123;@link #createIntent&#125; 2. Fire the intent using &#123;@link android.app.Activity#startActivityForResult&#125;. 3. Check for ActivityNotFoundException and take a user friendly action if thrown. 4. Listen the result using &#123;@link android.app.Activity#onActivityResult&#125; 5. Parse the result using &#123;@link #parseResult&#125; only if media capture was not requested. 6. Send the result using mFilePathCallback of &#123;@link WebChromeClient#onShowFileChooser&#125; * */ Intent intent; if (AppUtils.isOver(Build.VERSION_CODES.LOLLIPOP)) &#123; intent = fileChooserParams.createIntent(); &#125; else &#123; intent = new Intent(Intent.ACTION_GET_CONTENT); intent.addCategory(Intent.CATEGORY_OPENABLE); intent.setType("*/*"); &#125; mActivity.startActivityForResult(intent, MyWebView.WEB_REQ_CODE); mMyWebView.mFilePathCallback = filePathCallback; return true;&#125; 在 onActivityResult() 中接受返回的数据. 123456789101112public void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if (requestCode != WEB_REQ_CODE) return; Uri[] uris; if (AppUtils.isOver(Build.VERSION_CODES.LOLLIPOP)) &#123; uris = WebChromeClient.FileChooserParams.parseResult(resultCode, data); &#125; else &#123; uris = new Uri[]&#123;data.getData()&#125;; &#125; mFilePathCallback.onReceiveValue(uris); mFilePathCallback = null;&#125; todo更多内容补充中 …]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android编译FFmpeg之命令行]]></title>
    <url>%2Farticle%2F4043209466%2F</url>
    <content type="text"><![CDATA[上篇文章介绍了 FFmpeg 大体的编译流程，并在 Java 层进行 JNI 接口的调用，借此了解 Android 编译底层 so 库的方式，本文主要介绍如何在 Android 平台使用 FFmoeg 命令行对音视频进行操作。 承接上文，本文从编译好各个 so 文件之后，编写 Java 层调用的 c 文件开始。 源代码 GitHub - FFmpegAndroidSupport(注意在 try_cmd 分支) Java 层 Native 方法首先进行 Java 层代码的编写，创建 FFmpegSupport 类，加载 so 文件，声明 native 方法。 123456789101112131415161718192021222324252627282930313233343536public class FFmpegSupport &#123; static &#123; try &#123; System.loadLibrary("avdevice-57"); System.loadLibrary("avfilter-6"); System.loadLibrary("avformat-57"); System.loadLibrary("avutil-55"); System.loadLibrary("avcodec-57"); System.loadLibrary("postproc-54"); System.loadLibrary("swresample-2"); System.loadLibrary("swscale-4"); System.loadLibrary("ffmpegjni"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static int ffmpegRunCommand(String command) &#123; if (command.isEmpty()) &#123; return 1; &#125; String[] args = command.split(" "); return ffmpegRunCommand(args); &#125; static int ffmpegRunCommand(String[] commands) &#123; for (String command : commands) &#123; Log.d("ffmpeg-jni", command); &#125; return ffmpegRun(commands.length, commands); &#125; public static native int ffmpegRun(int argc, String[] args);&#125; 生成 .h 头文件使用 javah 命令根据你的 java 文件自动生成 .h 文件，javah 命令需要 class 文件，所以首先你需要对工程进行编译，生成 class 文件，它位于 project/app/build/intermediates/classes/debug 目录下。 比如我的类叫做 FFmpegSupport，包名 com.march.fas，运行命令后生成了 com_march_fas_FFmpegSupport.h 文件，这个 .h 文件的名字应该是可以自定义的，现在是默认的包名类名，我还没有查到相关参数。 123456javah -d &lt;.h文件生成的目录&gt; -classpath &lt;class文件存储的目录&gt; &lt;包名.类名&gt;// 如下javah -d /Users/march/AndroidPro/FFmpegAndroidSupport/app/src/main/jni \-classpath /Users/march/AndroidPro/FFmpegAndroidSupport/app/build/intermediates/classes/debug \com.march.fas.FFmpegSupport 查看 .h 文件的内容，将 jclass 改为 jobject，原因的话我也不知道为什么，不是很懂这一块儿，也是查资料慢慢总结的。 123456789101112131415161718192021/* DO NOT EDIT THIS FILE - it is machine generated */#include &lt;jni.h&gt;/* Header for class com_march_fas_FFmpegSupport */#ifndef _Included_com_march_fas_FFmpegSupport#define _Included_com_march_fas_FFmpegSupport#ifdef __cplusplusextern "C" &#123;#endif/* * Class: com_march_fas_FFmpegSupport * Method: ffmpegRun * Signature: (I[Ljava/lang/String;)I */JNIEXPORT jint JNICALL Java_com_march_fas_FFmpegSupport_ffmpegRun (JNIEnv *, jobject, jint, jobjectArray);#ifdef __cplusplus&#125;#endif#endif 编写对应 c 文件根据生成的 .h 编写 c 文件，其中 logjni.h 是一个打印日志的工具类，详细可以参考 github 上面的源文件。 123456789101112131415161718192021222324252627282930313233343536#include "logjni.h"#include "com_march_fas_FFmpegSupport.h"#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;int main(int argc, char **argv);JNIEXPORT jint JNICALL Java_com_march_fas_FFmpegSupport_ffmpegRun(JNIEnv *env, jobject obj, jint argc, jobjectArray args) &#123; int i = 0; char **argv = NULL; jstring *strr = NULL; if (args != NULL) &#123; argv = (char **) malloc(sizeof(char *) * argc); strr = (jstring *) malloc(sizeof(jstring) * argc); for (i = 0; i &lt; argc; ++i) &#123; strr[i] = (jstring)(*env)-&gt;GetObjectArrayElement(env, args, i); argv[i] = (char *)(*env)-&gt;GetStringUTFChars(env, strr[i], 0); LOGD("args: %s", argv[i]); &#125; &#125; LOGD("Run ffmpeg"); int result = main(argc, argv); LOGD("ffmpeg result %d", result); for (i = 0; i &lt; argc; ++i) &#123; (*env)-&gt;ReleaseStringUTFChars(env, strr[i], argv[i]); &#125; free(argv); free(strr); return result;&#125; 准备工作如上代码中，我们使用 ffmpeg.c 中的 main() 函数，因此需要将 ffmpeg.c 和 ffmpeg.h 拷贝到 jni 目录中，同时 ffmpeg.c 又引用了多个文件，大致有以下几个文件，这些文件都需要拷贝到 jni 目录中 12345678config.hffmpeg.cffmpeg.hffmpeg_filter.cffmpeg_opt.ccmdutils_common_opts.hcmdutils.hcmdutils.c 跟上一篇文章说的一样，我们还是要将编译好的 so 文件拷贝到 jni 目录，同时编写 Android.mk 和 Application.mk 文件。为了让结构更加清晰，我对目录做了些许改动。在 jni 目录下新建了 prebuilt/armeabi 文件夹，用来存放 so 文件。同时 Android.mk 和 Application.mk 文件也需要做相应修改。 Android.mk 文件， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172LOCAL_PATH:= $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE:= avcodec-prebuilt-armeabiLOCAL_SRC_FILES:= prebuilt/armeabi/libavcodec-57.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE:= avdevice-prebuilt-armeabiLOCAL_SRC_FILES:= prebuilt/armeabi/libavdevice-57.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE:= avfilter-prebuilt-armeabiLOCAL_SRC_FILES:= prebuilt/armeabi/libavfilter-6.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE:= avformat-prebuilt-armeabiLOCAL_SRC_FILES:= prebuilt/armeabi/libavformat-57.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := avutil-prebuilt-armeabiLOCAL_SRC_FILES := prebuilt/armeabi/libavutil-55.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := swresample-prebuilt-armeabiLOCAL_SRC_FILES := prebuilt/armeabi/libswresample-2.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := swscale-prebuilt-armeabiLOCAL_SRC_FILES := prebuilt/armeabi/libswscale-4.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := postproc-prebuilt-armeabiLOCAL_SRC_FILES := prebuilt/armeabi/libpostproc-54.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := libffmpegjniLOCAL_ARM_MODE := armLOCAL_SRC_FILES := com_march_fas_FFmpegSupport.c \ ffmpeg.c \ cmdutils.c \ ffmpeg_opt.c \ ffmpeg_filter.cLOCAL_LDLIBS := -L$(SYSROOT)/usr/lib -llog -lzLOCAL_SHARED_LIBRARIES:= avcodec-prebuilt-armeabi \ avdevice-prebuilt-armeabi \ avfilter-prebuilt-armeabi \ avformat-prebuilt-armeabi \ avutil-prebuilt-armeabi \ swresample-prebuilt-armeabi \ swscale-prebuilt-armeabi \ postproc-prebuilt-armeabiLOCAL_C_INCLUDES += -L$(SYSROOT)/usr/includeLOCAL_C_INCLUDES += /Users/march/AndroidPro/FFmpegAndroidSupport/ffmpeg-3.3.1LOCAL_CFLAGS := -DUSE_ARM_CONFIGinclude $(BUILD_SHARED_LIBRARY) Application.mk 文件 12APP_ABI := armeabi-v7aAPP_PLATFORM := android-14 修改 ffmpeg 源代码]]></content>
      <categories>
        <category>Android</category>
        <category>Ndk</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Ndk</tag>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin开发-5-类与对象]]></title>
    <url>%2Farticle%2F2717980190%2F</url>
    <content type="text"><![CDATA[本文主要介绍 Kotlin 类与对象。 看了官方文档的相关描述，发现很多名词在 Kotlin 中和 Java 都有不太一样，在 Kotlin 中 方法 被称为 函数，而像 open , final 这种关键字被称为注解(annotation)，在我之前的认知当中只有 @Inject 这种才是注解。因此文章中的描述都尽量使用 Kotlin 中的术语。 构造器Kotlin 中的类可以有一个 主构造器 (primary constructor), 以及一个或多个 次构造器 (secondary constructor)。主构造器是类头部的一部分, 位于类名称(以及可选的类型参数)之后。 主构造器主构造器紧跟在类名后面进行声明，声明的一般形式如下，可见度修饰符默认为 public，(如果主构造器是 public 的，同时没有注解那么可以省略 constructor 关键字)。当然如果类内部没有具体的实现，{} 也是可以省略的。 12345678// 完整的写法class Engineer private @Inject constructor(name: String, age: Int, language: String)// 简化写法，由于是public的，同时没有注解，省略了constructor关键字class Engineer (name: String, age: Int, language: String)// 默认生成一个public的无参构造器class Engineer 由于主构造器中无法使用初始化代码，可以在类内进行属性的初始化，使用 init{} 关键字表示。 123456789101112class Engineer (name: String, age: Int, language: String) &#123; var name: String = "" var age:Int = 0 var language:String = "" init &#123; this.name = name this.age = age this.language = language log("name = $name,age = $age, lan = $language") &#125;&#125; 在主构造器内可以直接使用 val 和 var 声明和初始化属性，他们都是类的成员属性。 123class Engineer(val name: String = "", age: Int = 0, language: String = "") &#123;&#125; 注意: 在 JVM 中, 如果主构造器的所有参数都指定了默认值, 编译器将会产生一个额外的无参数构造器, 这个无参数构造器会使用默认参数值来调用既有的构造器. 有些库(比如 Jackson 或 JPA) 会使用无参数构造器来创建对象实例, 这个特性将使得 Kotlin 比较容易与这种库协同工作. 次级构造器如果类有主构造器, 那么每个次级构造器都必须委托给主构造器, 要么直接委托, 要么通过其他次级构造器间接委托. 委托到同一个类的另一个构造器时, 使用 this 关键字实现。 12345class Engineer(val name: String = "", age: Int = 0, language: String = "") &#123; constructor(name: String, age: Int) : this(name, age, "en")&#123; log("次级构造器") &#125;&#125; 创建对象构造器中的属性指定初始值后在创建对象时可以省略，使用如下方法，避免重载构造方法，主构造器中具有默认值的属性不是必须赋值的。 123val en = Engineer("",12)val en1 = Engineer(name = "test")val en2 = Engineer(name = "test",age = 12,language = "") 继承kotlin 中所有的类默认继承自超类 Any,Any 不是 java.lang.Object; 尤其要注意, 除 equals() , hashCode() 和 toString() 之外, 它没有任何成员。 Kotlin 中所有的类都是 fnial 的，也就是不允许继承，这点和 Java 正好相反，如果你想继承一个类必须使用 open 关键字声明。 Kotlin 使用 : 表示继承，子类和父类构造器调用分为以下两种情况 如果类有主构造器, 那么必须在主构造器中使用主构造器的参数来初始化基类。 12345open class Engineer(var name: String = "", var age: Int = 0, var language: String = "") &#123;&#125;class BigEngineer(var level: Int) : Engineer("name",12) &#123;&#125; 如果类没有主构造器, 那么所有的次级构造器都必须使用 super 关键字来初始化基类, 或者委托到另一个构造器, 由被委托的构造器来初始化基类。 注意, 这种情况下, 不同的次级构造器可以调用基类中不同的构造器。 12345678910open class Engineer(var name: String = "", var age: Int = 0, var language: String = "") &#123; &#125;class BigEngineer : Engineer &#123; var level = 0 constructor(name:String,age:Int,level:Int):super(name,age,"en")&#123; this.level = level &#125;&#125; 方法的覆盖和类一样，类中的所有方法都默认是 final 的，即不允许在子类中进行重写，如果想要在子类中更改，需要使用 open 注解声明，如实例中 3。 如果子类想要覆盖父类的方法，必须添加 override 注解。 如果遗漏了这个注解，编译器将会报告错误。 如果一个函数没有标注 open 注解， 那么在子类中声明一个同名同参的方法将是非法的, 无论是否添加 override 注解， 都不可以，如实例中 4。 当一个子类成员标记了 override 注解来覆盖父类成员时， 覆盖后的子类成员本身也将是 open 的, 也就是说， 子类成员可以被自己的子类再次覆盖，如实例中 1。 如果你希望禁止这种再次覆盖，可以使用 final 注解，如实例中 2。 实例： 12345678910111213141516171819202122open class Engineer(var name: String = "", var age: Int = 0, var language: String = "") &#123; open fun test() &#123;&#125; open fun test2() &#123;&#125; // 此函数不允许在子类覆盖 fun test3() &#123;&#125;&#125;open class BigEngineer(name: String = "", age: Int = 0, var level: Int = 0) : Engineer(name, age, "en") &#123; // 1. 此函数覆盖了超类中的函数，他将默认是open的，他的子类可以覆盖该方法。 override fun test() &#123;&#125; // 2. 此函数在子类中将不会被覆盖，因为显式的添加了final注解 final override fun test2() &#123;&#125; // 3. 这句是编译错误的，因为test3()不是open的 // override fun test3() &#123;&#125; // 4. 这句是编译错误的，超类中test3()是final的，在子类中声明同名同参的函数是非法的 // fun test3()&#123;&#125;&#125; 在一个 final 类(比如， 一个没有添加 open 注解的类)中， 声明 open 成员是没有意义的。 123456class Test&#123; // 警告⚠️open has no effect in a final class。 // 在一个final类中声明open成员是无意义的，因为类无法被继承，成员函数和变量也无法被重写。 open fun test()&#123;&#125; open val a = 0&#125; 属性的覆盖前提，属性的覆盖方式与方法覆盖类似，同样必须在父类中声明为 open，当超类中声明的属性在后代类中再次声明时，必须使用 override 关键字来标记，而且覆盖后的属性数据类型必须与超类中的属性数据类型兼容。 可以使用带初始化器的属性来覆盖超类属性， 也可以使用带取值方法(getter)的属性来覆盖。 可以在主构造器的属性声明中使用 override 关键字，覆盖主构造器中的属性。 可以使用一个 var 属性覆盖一个 val 属性，但不可以反过来使用一个 val 属性覆盖一个 var 属性。 允许这种覆盖的原因是， val 属性本质上只是定义了一个 get 方法，使用 var 属性来覆盖它， 只是向后代类中添加了一个 set 方法。 123456789101112131415161718192021222324// name属性是open的，它可以在子类中被覆盖open class Engineer(open var name: String = "", var age: Int = 0, var language: String = "") &#123; open val a: Int get() = 100 open val b: Int = 100 open var c:Int = 100&#125;// 覆盖了超类中的name属性open class BigEngineer(override var name: String = "", age: Int = 0, var level: Int = 0) : Engineer(name, age, "en") &#123; // 可以使用初始化器或getter方法对属性进行覆盖，都是允许的。 override val a: Int = 100 override var b = 0 get() = 1 // 这句是编译错误的，因为val变量不能覆盖var变量 // override val c:Int = 1&#125; 覆盖的原则在 Kotlin 中， 类继承中的方法实现问题, 遵守以下规则: 如果一个类从它的直接超类中继承了同一个成员的多个实现，那么这个子类必须覆盖这个成员，并提供一个自己的实现，这样在子类中消除歧义，为了表示使用的方法是从哪个超类继承得到的， 我们使用 super 关键字, 将超类名称放在尖括号类, 比如 super&lt;父类&gt;。 12345678910111213141516171819202122232425open class ClsA &#123; open val a = 100 open fun test() &#123;&#125;&#125;interface ClsB &#123; val a: Int get() = 200 fun test() &#123;&#125;&#125;class ClsC : ClsA(), ClsB &#123; // 属性必须进行初始化，因此不存在这样的问题 override val a = 300 // 方法的覆盖 // 此时编译器强制必须实现test()方法,因为可以从超类中继承多个实现 override fun test() &#123; // 明确的调用父类中的方法 super&lt;ClsA&gt;.test() super&lt;ClsB&gt;.test() &#125;&#125;]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin开发-4-接口]]></title>
    <url>%2Farticle%2F6a146f82%2F</url>
    <content type="text"><![CDATA[本文主要介绍 Kotlin 接口。 声明接口使用 interface 关键字声明； 接口中可以包含抽象方法的声明，也可以包含方法的实现。 接口与抽象类的区别在于， 接口不能存储状态数据。 接口可以有属性， 但这些属性必须是抽象的，不能使用初始化器来初始化，或者必须提供访问器的自定义实现。 接口不支持 Backing Field，因此 var 变量无法定义访问器，因此 var 类型的属性必定是抽象的。 123456789101112131415161718192021222324252627interface FirstInterface &#123; // 可以具有属性，但是属性必须是抽象的 // 或者必须提供访问器的自定义实现 val testVal1: Int var testVar2: Int val testVal3: Int get() = 100 // 编译错误，接口不支持 backing field // 因此 var 类型的属性不能自定义访问器 var testVar4: Int get() = 100 // 编译错误，属性必须是抽象的 // 或者必须提供访问器的自定义实现 val testVal10: Int = 1 var testVar10: Int = 1 // 可以包含抽象方法的声明 fun testFun1() // 也可以包含方法的实现 fun testFun2(param: Int): String &#123; return "test fun 2" &#125;&#125; 实现接口12345678910111213141516171819202122232425class SecondInterface:FirstInterface&#123; // 使用初始化器覆盖接口抽象属性 override val testVal1: Int = 10 // 使用自定义访问器覆盖接口抽象属性 override var testVar2: Int get() = 100 set(value) &#123;&#125; // 覆盖接口非抽象属性 override val testVal3: Int get() = super.testVal3 // 覆盖接口抽象方法 override fun testFun1() &#123; &#125; // 覆盖接口非抽象方法 override fun testFun2(param: Int): String &#123; return super.testFun2(param) &#125;&#125; 解决接口覆盖冲突由于接口是可以多继承的，如果实现多个接口，同时接口中有相同方法的声明，就会出现覆盖冲突，使用官网的一个例子来说明一下覆盖冲突的解决。单继承时自然要实现接口中所有抽象方法，当实现多个接口时，如果实现的接口中具有同名的抽象方法，即使在接口中对该方法都已经有了实现，那么在子类中也必须实现该方法，并使用super&lt;接口名称&gt;.方法名，如下面的 super&lt;A&gt;.bar() 来在子类中显式的声明到底是继承哪一个实现。 123456789101112131415161718192021222324252627interface A &#123; fun foo() &#123; print("A") &#125; fun bar()&#125;interface B &#123; fun foo() &#123; print("B") &#125; fun bar() &#123; print("bar") &#125;&#125;class C : A &#123; override fun bar() &#123; print("bar") &#125;&#125;class D : A, B &#123; // 重名函数必须实现，即使继承的接口中已经有了具体实现 override fun foo() &#123; super&lt;A&gt;.foo() super&lt;B&gt;.foo() &#125; override fun bar() &#123; super&lt;B&gt;.bar() // 由于 A 中对 bar 没有实现，可以如下简写 // super.bar() &#125;&#125;]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin开发-3-属性与域]]></title>
    <url>%2Farticle%2F12ba0671%2F</url>
    <content type="text"><![CDATA[本文主要介绍 Kotlin 属性和域的相关内容。 Kotlin 中，使用 val 声明常量(不可变)，使用 var 声明变量(可变)。 12345public val a = 100 // 常量，不可变，当你再想改变他的值时会报错private var b = 1000 // 变量，可变b = -100val c:Int? = null 属性的声明声明属性的完整语法如下，其中的初始化器(initializer)， 取值方法(getter)， 以及设值方法(setter)都是可选的。Kotlin 具有类型自动推断得特性，如果属性类型可以通过初始化器自动推断得到， 或者可以通过这个属性覆盖的基类成员属性推断得到， 则属性类型的声明也可以省略。 标准的初始化方法，需要清楚其中几个概念 propertyName ：变量名 PropertyType ：变量类型，如果可以推断得到，可以省略 property_initializer ：初始化器，它可以是一个固定值或一个表达式 getter ：取值方法，访问器的一种 setter ：设值方法，访问器的一种 123var &lt;propertyName&gt;: &lt;PropertyType&gt; [= &lt;property_initializer&gt;] [&lt;getter&gt;] [&lt;setter&gt;] 注意，如下注释 1 处，对于 var 变量来说，初始化器，设值，取值方法都是允许同时存在的；如下注释 2 处，对于 val 变量来说，不允许有设值方法，同时 getter 方法和 初始化器 不允许同时指定，因为只读变量只允许初始化一次。 使用 注解 和 可见度修饰符，如下注释 3 处，，如果不想在外界访问属性的 set／get 方法，可以使用可见度修饰符来避免外部访问。同样也可以在 set／get 方法前使用注解。 1234567891011121314151617181920212223242526open class ClsA &#123; // 1 var x: Int = 100 get() = 100 set(value) &#123; field = value &#125; // 2. 不允许有设值方法，同时get方法和初始化器不允许同时指定，因为只读变量只允许初始化一次 val y: Int get() = 100 // 这是不允许的，因为val只读的 // set(value) &#123; // field = value // &#125; // 3. 在set/get方法前使用可见度修饰符和注解 var z: Int = 100 @Inject get private set&#125;eg:val param:ClsA = ClsA()// 编译错误，因为不允许访问z的设值方法param.z = 100 Backing FieldsKotlin 我们可以直接使用属性名称对类的属性进行访问，但是实际上我们并没有直接访问该属性的引用，而是在编译时被转换成了 getter/setter 方法来进行访问，如注释中 1 处代码，这样我们既可以简化代码，又保持了类的封闭性。 Kotlin 的类中不允许拥有域(Field)，也就是说你在类内部也无法直接使用属性的名称对属性进行访问，而是都会转换为 getter/getter 方法。因此当你在 set 方法中调用该属性为他赋值时又会调用 set 方法，导致 堆栈溢出，如实例中 2，这是我在开始写的时候遇到的问题。 12345678910// 1 伪代码ClsA().x = 100 相当于 ClsA().setX(100)val a = ClsA.x 相当于 val a = ClsA().getX()// 2var xx: Int = 100 set(value) &#123; // 再次调用 set 方法 xx = value + 1 &#125; 但是自定义属性的访问器时不可避免的要使用 域变量，因此 Kotlin 提供了 Backing Fields 的特性，使用关键字 field 表示，field 标识符只允许在属性的访问器函数内使用，如下代码中，使用 field 即可真实的访问(不经过getter/setter) 变量 xx，完成赋值操作。 12345var xx: Int = 100 get() = field++ set(value) &#123; field = value - 1 &#125; Backing Property有时隐含的后端域属性不足以解决某些情况的问题，此时可以使用自定义的 Backing Property。如下实例中，Backing Property 就是另外定义一个属性 _yy 用来存储数据，而外界访问的属性 yy 只是提供了一个访问器方法而已，本身已经不具备什么意义啦，将访问器的声明和数据的存储放在两个地方，就不会发生之前的冲突（我的理解😊） 12345678910111213141516private var _yy: String? = nullvar yy: String get() &#123; if (_yy == null) &#123; _yy = "init str" &#125; return _yy ?: "be changed" &#125; set(value) &#123; _yy = "this is $value" &#125; // 访问yyval param: ClsA = ClsA()param.yy 编译期常数如果属性值在编译期间就能确定, 则可以使用 const 修饰符, 将属性标记为 编译期常数值(compile time constants)。 这类属性必须满足以下所有条件: 必须是顶级属性， 或者是一个 object 的成员。 值被初始化为 String 类型, 或基本类型(primitive type)。 不存在自定义的取值方法。 1234567// 顶级属性const val TEST_CONST = "TEST_CONST"// 声明在 object 中object Const&#123; const val TEST_CONST_IN_OBJ = "TEST_CONST_IN_OBJ"&#125; 属性初始化 - 延迟(lateinit)lateinit 关键字表示当前 变量 不会在声明时进行初始化操作，初始化操作会在后面进行，像是一种协议机制，告知编译器我会在后面使用该变量之前的恰当时机初始化该变量，不要进行警告⚠️。在一个 lateinit 属性被初始化之前访问它， 会抛出一个特别的异常，这个异常将会指明被访问的属性，以及它没有被初始化这一错误。 需要注意的是使用 lateinit 关键字有很多限制: 必须是变量，即使用 var 关键字进行声明。 不能修饰可为 null 的类型，比如 lateinit var str:String? 是编译不通过的。 不能修饰基本数据类型。例如 Int,Float等 123lateinit var stuLateInit:StudentstuLateInit = Student("name",11) 属性延迟初始化 - 代理(by lazy)by lazy 是属性代理的基本运用，是经过简化后的属性代理，他为属性提供初始化方法。这里不扩展属性代理的相关问题。 因为他只提供取值方法所以仅可以用在常量的初始化中，使用 by lazy 当属性被第一次访问时，就会触发初始化流程。 只有常量，也就是使用 val才能使用 by lazy 延迟初始化 1234567891011val stuByLazy:Student by lazy &#123; Student("name",11)&#125;val mMyMsgTv:TextView by lazy &#123; findViewById(R.id.mTestTv) as TextView&#125;// 当常量被使用时才进行初始化logError(stuByLazy.myCls)mMyMsgTv.text="文本"]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin开发-2-基础-控制流]]></title>
    <url>%2Farticle%2F57e86c00%2F</url>
    <content type="text"><![CDATA[本篇主要介绍 Kotlin 中 控制流的使用，if , when , for , while 等关键字在 Kotlin 中的新特性。 如何在函数中返回和跳转，return , continue , break 等关键字的使用。 if 判断结构123456789101112131415var a = 0if (a == 0) a = 100if (a == 0) a = 100 else a = 1000// 作为表达式时必须有else分支val rst1 = if (a == 0) 100 else 1000// 具有多行语句必须使用&#123;&#125;val rst2 = if (a == 0) &#123; logError(100) 100&#125; else &#123; logError(1000) 1000&#125; when 分支结构Kotlin 使用 when 关键字实现分支结构。 当 when 作为表达式出现时，必须具有 else 分支，除非你的分支已经包含了所有的情况，这是因为作为表达式时他必须有一个返回值，而 else 分支将会在所有条件都不满足时执行。 when 作为表达式 12345678910111213fun testFun3(param: Int): Int = when (param) &#123; // 一般用法 0 -&gt; 0 // 使用 in 操作符匹配范围 in 1..5 -&gt; 1 !in 100..105 -&gt; -1 // 使用多个匹配 5, 6, 7 -&gt; 2 // 类型判断 is Int -&gt; 3 // 作为表达式必须有else分支 else -&gt; 100&#125; 在函数中使用 when 12345678// 作为函数时不需要必须有 else 分支fun testFun5() &#123; val param: Any? = 100 when (param) &#123; // 自动的类型推断，此时param 是 String 类型 is String -&gt; param.startsWith("") &#125;&#125; for 循环结构任何值, 只要能够产生一个迭代器( iterator), 就可以使用 for 循环进行遍历。 能够产生一个迭代器是指： 存在一个成员函数- 或扩展函数 iterator(), 它的返回类型应该 存在一个成员函数- 或扩展函数 next(), 并且 存在一个成员函数- 或扩展函数 hasNext(), 它的返回类型为 Boolean 类型。 遍历数组和 List 12345678910111213141516171819202122232425262728// 遍历临时数组for (item in (1..4)) &#123; logError(item)&#125;// 遍历listval lists = mutableListOf(1, 2, 4)// 遍历itemfor (item in lists) &#123; logError(item)&#125;// 使用下标遍历for (i in lists.indices) &#123; logError(lists.get(i))&#125;// 获取下标和值for((i,item) in lists.withIndex())&#123; logError("$i = $item")&#125;// 遍历数组也是一样的val arrays = arrayOf(1,2,3)for (item in arrays)&#123; logError(item)&#125;for (i in arrays.indices)&#123; logError(arrays[i])&#125; 遍历 map 12345// 遍历mapval maps = mapOf(Pair("a", "b"), Pair("a1", "b1"))for ((key, value) in maps) &#123; logError("map($key-&gt;$value)")&#125; 遍历字符串 12345// 遍历字符串val str = "test"for (s in str)&#123; logError("$s in str")&#125; while 循环结构用法与其他语言是一致的。 12345678910var a = 0while (a &gt; 100) &#123; logError("a is $a") a++&#125;do &#123; logError("a is $a") a++&#125; while (a &gt; 100) 返回与跳转Kotlin 中有三种标签可以跳出程序流程 return. 默认行为是, 从最内层的函数或 匿名函数 中返回。break. 结束最内层的循环。continue. 在最内层的循环中, 跳转到下一次循环。 Kotlin 中的任何表达式都可以用 label 标签来标记。标签的形式与标识符相同, 后面附加一个 @ 符号,如 loopOut@,使用标签标记位置，就可以使用程序跳出操作符跳出指定位置，如 break@loopOut,continue@loopOut,return@loopOut。需要注意的是中间不需要有空格，他们是一体的。如果有标签的同时又有返回值，使用 return@loopOut 100 这样的形式，意为跳出到 loopOut 标签位置，返回值是 100 。 12345678910111213fun testFun6() &#123; loopOut@ for (i in 1..10) &#123; loopIn@ for (j in 10..100) &#123; if (i * j == 100) break@loopOut if (i * j &lt; 10) continue@loopIn if (i * j == 101) break@loopIn logError("result = $&#123;i * j&#125;") &#125; &#125;&#125; 在 Kotlin 中, 通过使用字面值函数(function literal), 局部函数(local function), 以及对象表达式(object expression), 允许实现函数的嵌套。通过标签限定的 return 语句, 可以从一个外层函数中返回. 最重要的使用场景是从 Lambda 表达式中返回。 如下面的例子中，默认会从函数 testFun61() 中返回，返回值为9，而且你写 return 语句时，编译器会提示你必须返回一个 Int 类型。这种非局部的返回(non-local return), 仅对传递给 内联函数(inline function) 的 Lambda 表达式有效。 123456789// 函数会返回 9fun testFun61(): Int &#123; val arrays = Array(10, &#123; i -&gt; i * i &#125;) arrays.forEach &#123; if (it == 9) return it &#125; return 0&#125; 如果需要从内部 Lambda 表达式跳出而不是从函数中返回，可以使用标签指定跳出目标。使用隐含标签会更方便一些, 隐含标签的名称与 Lambda 表达式被传递去的函数名称相同。如下面的隐含标签为 forEach@。 12345678910111213141516171819// 此时返回 0fun testFun62():Int&#123; val arrays = Array(10, &#123; i -&gt; i * i &#125;) arrays.forEach signal@&#123; if (it == 9) return@signal &#125; return 0&#125;// 使用隐含标签fun testFun63():Int&#123; val arrays = Array(10, &#123; i -&gt; i * i &#125;) arrays.forEach &#123; if (it == 9) return@forEach &#125; return 0&#125;]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin开发-2-基础-数据类型]]></title>
    <url>%2Farticle%2F6eea2c65%2F</url>
    <content type="text"><![CDATA[本篇介绍 Kotlin 的内建数据类型，包括数值类型，字符类型，布尔类型，数组类型，字符串类型等。 同一性 和 相等性同一性：对象的地址，数据类型，内容都相同，在 Kotlin 中使用 === 运算符进行比较，它相当于 Java 中的 == 运算符，他要求对象是完全相同的对象，即指向同一地址。 相等性：内容相等，在 Kotlin 中使用 == 运算法进行比较，相当于 Java 中的 equals() 方法，这里涉及自定义运算符的一点内容， 在 Kotlin 中当你对一个对象使用 == 运算符，会自动查找 equals() 方法进行调用。 数值类型Kotlin 数值使用内建对象表示，所有数值类型继承自 Number 抽象类，Number 中定义了数值在各个类型之间转换的方法。 Long 类型需要在数字末尾追加 大写 的 L 表示，如 123L； Float 类型需要在数字末尾追加 f／F 表示，如 123.5F 进制： 默认十进制计数，如： 123；十六进制以 0x 开头，如 0x1FA；二进制以 0b 开头，如 0b001101；不支持 八进制表示。 默认类型： 小数默认是 Double 类型，如果需要显式声明为 Float，需要加 f/F 后缀；整型如果在 Int 范围内默认为 Int 类型，需要显式声明为 Long 需要添加 L 后缀。 Double (64 bit) ；Float (32 bit) ；Long (64 bit) ；Int (32 bit) ；Short (16 bit) ；Byte (8 bit) ； 数值装箱在 Kotlin 中是没有像 Java 中那样的基本数据类型，但是内建的数值类型具有和基本数据类型相似的特性，如 Int 和 int 在比较操作上是完全一样的，可以像基本数据类型那么对待他。 123456789val aInt1 = 10val bInt1 = 10Log(aInt1 == bInt1) // trueLog(aInt1 === bInt1) // trueval aInt2 = 129val bInt2 = 129Log(aInt2 == bInt2) // trueLog(aInt2 === bInt2) // true 在 Java 中有基本数据类型的包装类型，区别在于包装类型是对象，可以为 null ，在 Kotlin 中使用 Type? 声明可以为空的类型，如 Int? ，这种类型在比较操作上和 Java 中的包装类型是一样的， 可以类比来看。 和 Java 一样存在着数值常量池的概念，当数值在 [-128,127] 之间的数值会缓存在常量池中，因为当值为 10 时，比较起来是相等的。 123456789101112131415val aInt3: Int? = 10val bInt3: Int? = 10Log(aInt3 == bInt3) // trueLog(aInt3 === bInt3) // trueval aInt4: Int? = 129val bInt4: Int? = 129Log(aInt4 == bInt4) // trueLog(aInt4 === bInt4) // false val num = 129val aInt5:Int? = numval bInt5:Int? = numLog(aInt5 == bInt5) // trueLog(aInt5 === bInt5) // false 类型转换在 Java 中的类型转换已经相对严格，它允许将低精度类型隐式转换为高精度类型，但是高精度类型转换为低精度类型时需要进行强制转换，但是 Kotlin 在类型转换上更加严格，他不允许进行任何形式的隐式类型转换，也就是说任何的类型转换一定是你主动的操作，不过 Kotlin 使用扩展方法提供了一种相对优雅的方式。 123456val bb : Byte = 1val ll:Long = 1// 低精度转高精度val ii1:Int = bb.toInt()// 高精度转低精度val ii2:Int = ll.toInt() 数值运算符1234567shl(bits) – 带符号左移 (等于 Java 的&lt;&lt;)shr(bits) – 带符号右移 (等于 Java 的 &gt;&gt;)ushr(bits) – 无符号右移 (等于 Java 的 &gt;&gt;&gt;)and(bits) – 按位与(and)or(bits) – 按位或(or)xor(bits) – 按位异或(xor)inv() – 按位取反 字符类型Char 类型不是 Number 的子类，也就是说 Char 类型并不是数值类型。 Char 类型使用 单引号 如 &#39;a&#39; 表示。特殊字符使用反斜线转义表达。Kotlin支持的转义字符包括: \t, \b, \n, \r, \&#39;, \&quot;, \\, \$ 。 其他任何字符, 都可以使用 Unicode 转义表达方式: &#39;\uFF00&#39;。 Char 类型也具有一系列的类型转换方法，你可以使用 &#39;0&#39;.toInt() 这样的语法将 Char 类型转换为数值类型。 可以使用 Char? 类型对 Char 类型进行装箱操作，与数值类型一样，装箱操作不能保持对象同一性。 布尔类型Boolean 类型用来表示布尔值, 有两个可能的值: true 和 false. 当需要一个可为 null 的布尔值引用时, 布尔值也会被装箱(box). 布尔值的计算与 Java 相同。 数组类型Kotlin 中的数组通过 Array 类表达, 这个类拥有 get 和 set 函数(这些函数通过运算符重载转换为 [] 运算符), 此外还有 size 属性, 以及其他一些有用的成员函数。 Kotlin 中也有专门的类来表达基本数据类型的数组: ByteArray, ShortArray, IntArray 等等, 这些数组可以避免数值对象装箱带来的性能损耗。这些类与 Array 类之间不存在继承关系, 但它们的方法和属性是一致的. 各个基本数据类型的数组类都有对应的工厂函数。 1234567891011121314151617181920// 初始化一个 Arrayval array1 = arrayOf(1, 2, 4)// 初始化一个全为 null 的 Arrayval array2 = arrayOfNulls&lt;Int&gt;(10)// IntArray类型val array3 = intArrayOf(1, 2, 3)// ShortArray类型val array4 = shortArrayOf(1, 2, 3)// 使用工厂函数初始化val array5 = Array(10, &#123; i -&gt; i * i&#125;)// 推荐下标访问logError(array5[0])logError(array5.get(0))logError(array5.size) 字符串类型使用双引号 &quot;abc&quot; 表示转移字符串，支持转义字符。 使用三个双引号 &quot;&quot;&quot;abc&quot;&quot;&quot; 表示原生字符串，原生字符串不支持转义，可以包含任何转义字符。 下面的 trimMargin() 函数会将 | 替换掉，这样保持在编码时期的整洁，但是在运行期间不会输出。 1234567891011121314// 默认使用 | 分割val text = """ |Tell me and I forget\n. |Teach me and I remember\t. |Involve me and I learn. |(Benjamin Franklin) """.trimMargin()logError(text)// 输出Tell me and I forget\n.Teach me and I remember\t.Involve me and I learn.(Benjamin Franklin) 字符串模板，转义字符串和原生字符串都支持字符串模板，使用 ${表达式} 的方式可以在字符串中间插入数据。只有一个简单值时可以省略 {} ,同时也支持复杂表达式的计算。转义字符串中你可以使用 \$ 来写入 $ 字符，原生字符串中由于不支持转义字符，你可以使用 ${&quot;$&quot;} 的方式写入 $ 字符。 12345val user = User()val param = 100var str = "test str template like $param"str = "test str template like $&#123;user.name&#125; "str = "test str template like $&#123;if (user.age &lt;= 0) 100 else user.age&#125;"]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin开发-2-基础-可见度修饰符]]></title>
    <url>%2Farticle%2F70650835%2F</url>
    <content type="text"><![CDATA[可见度修饰符用来表达类、接口、属性等被开放的程度，即在什么位置可以访问，在什么位置被限制访问。 本篇主要介绍 Kotlin 中的四种可见度修饰符，分别为 public，protected、internal 和 private。 类，对象，接口，构造器，函数，属性以及属性访问器设值方法(访问器取值方法总与属性本身可见度相同，因此不需要控制其可见度)，都可以使用 可见度修饰符 。 四种可见度修饰符：private、protected、internal、public，默认为 public。与 Java 不同的是少了 default 多了 internal。 注意：局部变量，局部函数，以及局部类，都不能指定可见度修饰符。 top-leveltop-level， 像 class 这种可以直接声明在包下。在 Kotlin 中，函数, 属性, 类, 对象, 接口都可以声明为 top-level。比如扩展函数和扩展属性就是 声明为 top-level 的。注意，这里说的是 top-level 级别声明，在这些声明内部再声明别的函数或者属性，不在讨论范畴，将在下一部分说明，对于 top-level 中的声明来说： public ：意为该声明在任何位置都可以访问，public 是默认的，可以省略。If you do not specify any visibility modifier, public is used by default, which means that your declarations will be visible everywhere; private ：意为该声明只能在同一个源代码文件中访问。If you mark a declaration private, it will only be visible inside the file containing the declaration; internal ：意为该声明在同一个module的任意位置是可以访问的。If you mark it internal, it is visible everywhere in the same module; protected ：对 top-level 的声明是无效的。protected is not available for top-level declarations. 12345678910111213// 类声明class MyCls // 接口声明，同 module 访问internal interface MyInter // 函数声明，只允许在文件内访问private fun MyFun()&#123;&#125; // 属性声明，所有地方都可以访问，默认 public 可以省略public var MyVal = 10 // 设置方法只有文件内可以访问 private set 类与接口在类和接口内部使用可见度修饰符 private ：在类内(以及它的所有成员之间)可以访问。private means visible inside this class only (including all its members); protected ：和 private 相同，而且在子类中也可以访问。protected — same as private + visible in subclasses too; internal ：在同一个 module 内，能访问该类的地方，也能访问该类的 internal 成员。any client inside this module who sees the declaring class sees its internal members; public ：在任何位置凡是能访问该类，则也能访问该类的 public 成员。any client who sees the declaring class sees its public members. 注意： 在 Kotlin 中，外部类不能访问其内部类的 private 成员。如果你覆盖一个 protected 成员，并且没有明确指定可见度，那么覆盖后成员的可见度也将是 protected。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475open class OuterCls &#123; // 类内可访问 private var a = 1 // 类内可访问，子类可访问 protected open val b = 2 // 模块内可以访问该类的地方，都可以访问该属性 internal val c = 3 // 默认为 public,任何位置，可以访问该类的地方都可以访问该属性 var d = 4 fun test() &#123; a = 1 // 外部类访问嵌套类pubic成员 NestedCls().publicVar // 编译错误，外部类不能访问嵌套类 private 成员 NestedCls().privateVar // 编译错误，外部类不能访问嵌套类 protected 成员 NestedCls().protectedVar // 外部类访问内部吧类public成员 InnerCls().publicVar // 编译错误，外部类不能访问内部类 protected 成员 InnerCls().privateVar // 编译错误，外部类不能访问内类 protected 成员 InnerCls().protectedVar &#125; // 嵌套类 private class NestedCls &#123; public var publicVar: Int = 5 private var privateVar: Int = 5 protected var protectedVar: Int = 5 // 嵌套类，不能访问外部类成员，不论 private public fun test() &#123; // 编译错误 a = 1 // 编译错误 d = 10 &#125; &#125; inner class InnerCls &#123; public var publicVar: Int = 5 private var privateVar: Int = 5 protected var protectedVar: Int = 5 // 内部类，可以访问外部类成员，不论 private public fun test() &#123; a = 1 d = 10 &#125; &#125;&#125;class Subclass : OuterCls() &#123; // a 不可访问 // b, c 和 d 可以访问 // Nested 和 e 可以访问 // 覆盖了父类中的 b，b可见度仍然为 protected，可以被子类覆盖 override val b = 5 fun testSub()&#123; // 编译错误，子类不可以访问 NestedCls 因为他是 private 的 NestedCls().publicVar // 可以访问 InnerCls，他是 public 的 InnerCls().publicVar &#125;&#125;class Unrelated(o: OuterCls) &#123; // o.a, o.b 不可访问 // o.c 和 o.d 可以访问(属于同一模块) // Outer.Nested 不可访问, Nested::e 也不可访问&#125; 构造器注意，指定类构造器可见度，你需要明确添加一个 constructor 关键字。 private ：表示构造器只在类内可以访问。 protected ：类构造器可见度不支持 protected。 internal ：表示同模块内可以访问该构造器。 public ：在任何位置都可访问，构造器默认 public。 1234567891011121314class MyCls1 private constructor()&#123; fun test()&#123; // 类内可以访问 MyCls1() &#125;&#125;class MyCls2 public constructor()class MyCls3 internal constructor()class MyCls4 internal constructor()&#123; fun test()&#123; // 编译错误，private 的构造器同文件内不能访问 MyCls1() &#125;&#125;]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin开发-2-基础]]></title>
    <url>%2Farticle%2F811551029%2F</url>
    <content type="text"><![CDATA[本篇主要介绍 Kotlin 的基础语法，控制流，内建数据类型等内容… import 语句和包的相关概念。 可见度修饰符的使用。 大部分内建数据类型的介绍。包括数值类型，字符类型，布尔类型，数组类型，字符串类型。 控制流的使用，if , when , for , while 等关键字在 Kotlin 中的新特性。 如何在函数中返回和跳转，return , continue , break 等关键字的使用。 go~ 包123456// 导包import com.march.ktexample.model.Student// 导包时使用别名，然后就可以使用别名调用import android.util.Log as LL.e(TAG, str) 可见度修饰符类，对象，接口，构造器，函数，属性以及属性访问器设值方法(访问器取值方法总与属性本身可见度相同，因此不需要控制其可见度)，都可以使用 可见度修饰符 。Kotlin 中的四种可见度修饰符：private、protected、internal、public，默认为 public。与 Java 不同的是少了 default 多了 internal。 注意：局部变量， 局部函数，以及局部类，都不能指定可见度修饰符。 top-leveltop-level， 像 class 这种可以直接声明在包下。在 Kotlin 中，函数, 属性, 类, 对象, 接口都可以声明为 top-level。比如扩展函数和扩展属性就是 声明为 top-level 的。注意，这里说的是 top-level 级别声明，在这些声明内部再声明别的函数或者属性，不在讨论范畴，将在下一部分说明，对于 top-level 中的声明来说： public ：意为该声明在任何位置都可以访问，public 是默认的，可以省略。If you do not specify any visibility modifier, public is used by default, which means that your declarations will be visible everywhere; private ：意为该声明只能在同一个源代码文件中访问。If you mark a declaration private, it will only be visible inside the file containing the declaration; internal ：意为该声明在同一个module的任意位置是可以访问的。If you mark it internal, it is visible everywhere in the same module; protected ：对 top-level 的声明是无效的。protected is not available for top-level declarations. 1234567891011121314151617package com.march.ktexample// filename:VisibilityModifiersTest.kt// 类声明class MyCls // 接口声明，同 module 访问internal interface MyInter // 函数声明，只允许在文件内访问private fun MyFun()&#123;&#125; // 属性声明，所有地方都可以访问，默认 public 可以省略public var MyVal = 10 // 设置方法只有文件内可以访问 private set 类与接口在类和接口内部使用可见度修饰符 private ：在类内(以及它的所有成员之间)可以访问。private means visible inside this class only (including all its members); protected ：和 private 相同，而且在子类中也可以访问。protected — same as private + visible in subclasses too; internal ：在同一个 module 内，能访问该类的地方，也能访问该类的 internal 成员。any client inside this module who sees the declaring class sees its internal members; public ：在任何位置凡是能访问该类，则也能访问该类的 public 成员。any client who sees the declaring class sees its public members. 注意： 在 Kotlin 中，外部类不能访问其内部类的 private 成员。如果你覆盖一个 protected 成员，并且没有明确指定可见度，那么覆盖后成员的可见度也将是 protected。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475open class OuterCls &#123; // 类内可访问 private var a = 1 // 类内可访问，子类可访问 protected open val b = 2 // 模块内可以访问该类的地方，都可以访问该属性 internal val c = 3 // 默认为 public,任何位置，可以访问该类的地方都可以访问该属性 var d = 4 fun test() &#123; a = 1 // 外部类访问嵌套类pubic成员 NestedCls().publicVar // 编译错误，外部类不能访问嵌套类 private 成员 NestedCls().privateVar // 编译错误，外部类不能访问嵌套类 protected 成员 NestedCls().protectedVar // 外部类访问内部吧类public成员 InnerCls().publicVar // 编译错误，外部类不能访问内部类 protected 成员 InnerCls().privateVar // 编译错误，外部类不能访问内类 protected 成员 InnerCls().protectedVar &#125; // 嵌套类 private class NestedCls &#123; public var publicVar: Int = 5 private var privateVar: Int = 5 protected var protectedVar: Int = 5 // 嵌套类，不能访问外部类成员，不论 private public fun test() &#123; // 编译错误 a = 1 // 编译错误 d = 10 &#125; &#125; inner class InnerCls &#123; public var publicVar: Int = 5 private var privateVar: Int = 5 protected var protectedVar: Int = 5 // 内部类，可以访问外部类成员，不论 private public fun test() &#123; a = 1 d = 10 &#125; &#125;&#125;class Subclass : OuterCls() &#123; // a 不可访问 // b, c 和 d 可以访问 // Nested 和 e 可以访问 // 覆盖了父类中的 b，b可见度仍然为 protected，可以被子类覆盖 override val b = 5 fun testSub()&#123; // 编译错误，子类不可以访问 NestedCls 因为他是 private 的 NestedCls().publicVar // 可以访问 InnerCls，他是 public 的 InnerCls().publicVar &#125;&#125;class Unrelated(o: OuterCls) &#123; // o.a, o.b 不可访问 // o.c 和 o.d 可以访问(属于同一模块) // Outer.Nested 不可访问, Nested::e 也不可访问&#125; 构造器注意，指定类构造器可见度，你需要明确添加一个 constructor 关键字。 private ：表示构造器只在类内可以访问。 protected ：类构造器可见度不支持 protected。 internal ：表示同模块内可以访问该构造器。 public ：在任何位置都可访问，构造器默认 public。 1234567891011121314class MyCls1 private constructor()&#123; fun test()&#123; // 类内可以访问 MyCls1() &#125;&#125;class MyCls2 public constructor()class MyCls3 internal constructor()class MyCls4 internal constructor()&#123; fun test()&#123; // 编译错误，private 的构造器同文件内不能访问 MyCls1() &#125;&#125; 内建数据类型介绍 Kotlin 的内建数据类型，包括数值类型，字符类型，布尔类型，数组类型，字符串类型。 数值类型Kotlin 数值使用内建对象表示，所有数值类型继承自 Number 抽象类，Number 中定义了数值在各个类型之间转换的方法。 Long 类型需要在数字末尾追加 大写 的 L 表示，如 123L；Float 类型需要在数字末尾追加 f／F 表示，如 123.5F。默认十进制计数，如： 123；十六进制以 0x 开头，如 0x1FA；二进制以 0b 开头，如 0b001101；不支持 八进制表示。 小数默认是 Double 类型，如果需要显式声明为 Float，需要加 f/F 后缀。 Double (64 bit) ；Float (32 bit) ；Long (64 bit) ；Int (32 bit) ；Short (16 bit) ；Byte (8 bit) ； 同一性：对象的类型，内容相同，使用 === 运算符比较为 true 相等性：内容相等，使用 == 运算法比较为 true 数值装箱 Kotlin 中一切皆为对象，因此内建的数值类型也为对象，但是他们具有如同基本数据类型的特性，即 同一性，数值内建对象就如同 Java 中的基本数据类型，他们的值是不能为 null 的，你可以使用像 Int? 这样来进行数值装箱，这里可以参考 Java 中数值装箱的概念。装箱之后的数值会保持 相等性 但无法保持 同一性 12345678910111213141516// 内建对象的同一性val aInt = 10val bInt = 10logError("$&#123;aInt === bInt&#125;")// truelogError("$&#123;aInt == bInt&#125;")// true// 数值装箱后保持相等性，但是不保持同一性val aOrigin:Int = 10000val aBoxInt: Int? = aOriginval bBoxInt: Int? = aOriginlogError("$&#123;aBoxInt === bBoxInt&#125;")// falselogError("$&#123;aBoxInt == bBoxInt&#125;")// true困惑：当aOrigin = 10时，aBoxInt === bBoxInt 为 true，当aOrigin = 10000时，aBoxInt === bBoxInt 为 false 类型转换 Kotlin 不会将较小的数据类型隐式地转换为较大的数据类型. 也就是说, 如果不进行显式类型转换, 我们就不能将一个 Byte 类型值赋给一个 Int 类型的变量。你需要使用 toInt() 显式扩大为更大的类型， Number 类中定义了向各个数据类型转换的方式。 123456val bb : Byte = 1val ll:Long = 1// 扩大val ii1:Int = bb.toInt()// 缩小val ii2:Int = ll.toInt() 数值运算符 1234567shl(bits) – 带符号左移 (等于 Java 的&lt;&lt;)shr(bits) – 带符号右移 (等于 Java 的 &gt;&gt;)ushr(bits) – 无符号右移 (等于 Java 的 &gt;&gt;&gt;)and(bits) – 按位与(and)or(bits) – 按位或(or)xor(bits) – 按位异或(xor)inv() – 按位取反 字符类型Char 类型不是 Number 的子类，也就是说 Char 类型并不是数值类型。 Char 类型使用 单引号 如 &#39;a&#39; 表示。特殊字符使用反斜线转义表达. Kotlin支持的转义字符包括: \t, \b, \n, \r, \&#39;, \&quot;, \\, \$ 。 其他任何字符, 都可以使用 Unicode 转义表达方式: &#39;\uFF00&#39;。 Char 类型也具有一系列的类型转换方法，你可以使用 &#39;0&#39;.toInt() 这样的语法将 Char 类型转换为数值类型。 可以使用 Char? 类型对 Char 类型进行装箱操作，与数值类型一样，装箱操作不能保持对象同一性。 布尔类型Boolean 类型用来表示布尔值, 有两个可能的值: true 和 false. 当需要一个可为 null 的布尔值引用时, 布尔值也会被装箱(box). 布尔值的计算与 Java 相同。 数组类型Kotlin 中的数组通过 Array 类表达, 这个类拥有 get 和 set 函数(这些函数通过运算符重载转换为 [] 运算符), 此外还有 size 属性, 以及其他一些有用的成员函数。 Kotlin 中也有专门的类来表达基本数据类型的数组: ByteArray, ShortArray, IntArray 等等, 这些数组可以避免数值对象装箱带来的性能损耗. 这些类与 Array 类之间不存在继承关系, 但它们的方法和属性是一致的. 各个基本数据类型的数组类都有对应的工厂函数。 1234567891011121314151617181920// 初始化一个 Arrayval array1 = arrayOf(1, 2, 4)// 初始化一个全为 null 的 Arrayval array2 = arrayOfNulls&lt;Int&gt;(10)// IntArray类型val array3 = intArrayOf(1, 2, 3)// ShortArray类型val array4 = shortArrayOf(1, 2, 3)// 使用工厂函数初始化val array5 = Array(10, &#123; i -&gt; i * i&#125;)// 推荐下标访问logError(array5[0])logError(array5.get(0))logError(array5.size) 字符串类型使用双引号 &quot;abc&quot; 表示转移字符串，支持转义字符。使用三个双引号 &quot;&quot;&quot;abc&quot;&quot;&quot; 表示原生字符串，原生字符串不支持转义，可以包含任何转义字符。 1234567891011121314// 默认使用 | 分割val text = """ |Tell me and I forget\n. |Teach me and I remember\t. |Involve me and I learn. |(Benjamin Franklin) """.trimMargin()logError(text)// 输出Tell me and I forget\n.Teach me and I remember\t.Involve me and I learn.(Benjamin Franklin) 字符串模板，转义字符串和原生字符串都支持字符串模板，使用 ${表达式} 的方式可以在字符串中间插入数据。只有一个简单值时可以省略 {} ,同时也支持复杂表达式的计算。转义字符串中你可以使用 \$ 来写入 $ 字符，原生字符串中由于不支持转义字符，你可以使用 ${&quot;$&quot;} 的方式写入 $ 字符。 12345val user = User()val param = 100var str = "test str template like $param"str = "test str template like $&#123;user.name&#125; "str = "test str template like $&#123;if (user.age &lt;= 0) 100 else user.age&#125;" 控制流控制流主要包括判断结构，分支结构，循环结构 if 判断结构123456789101112131415var a = 0if (a == 0) a = 100if (a == 0) a = 100 else a = 1000// 作为表达式时必须有else分支val rst1 = if (a == 0) 100 else 1000// 具有多行语句必须使用&#123;&#125;val rst2 = if (a == 0) &#123; logError(100) 100&#125; else &#123; logError(1000) 1000&#125; when 分支结构Kotlin 使用 when 关键字实现分支结构。 当 when 作为表达式出现时，必须具有 else 分支，除非你的分支已经包含了所有的情况，这是因为作为表达式时他必须有一个返回值，而 else 分支将会在所有条件都不满足时执行。 when 作为表达式 12345678910111213fun testFun3(param: Int): Int = when (param) &#123; // 一般用法 0 -&gt; 0 // 使用 in 操作符匹配范围 in 1..5 -&gt; 1 !in 100..105 -&gt; -1 // 使用多个匹配 5, 6, 7 -&gt; 2 // 类型判断 is Int -&gt; 3 // 作为表达式必须有else分支 else -&gt; 100&#125; 在函数中使用 when 12345678// 作为函数时不需要必须有 else 分支fun testFun5() &#123; val param: Any? = 100 when (param) &#123; // 自动的类型推断，此时param 是 String 类型 is String -&gt; param.startsWith("") &#125;&#125; for 循环结构任何值, 只要能够产生一个迭代器( iterator), 就可以使用 for 循环进行遍历。 能够产生一个迭代器是指： 存在一个成员函数- 或扩展函数 iterator(), 它的返回类型应该 存在一个成员函数- 或扩展函数 next(), 并且 存在一个成员函数- 或扩展函数 hasNext(), 它的返回类型为 Boolean 类型。 遍历数组和 List 12345678910111213141516171819202122232425262728// 遍历临时数组for (item in (1..4)) &#123; logError(item)&#125;// 遍历listval lists = mutableListOf(1, 2, 4)// 遍历itemfor (item in lists) &#123; logError(item)&#125;// 使用下标遍历for (i in lists.indices) &#123; logError(lists.get(i))&#125;// 获取下标和值for((i,item) in lists.withIndex())&#123; logError("$i = $item")&#125;// 遍历数组也是一样的val arrays = arrayOf(1,2,3)for (item in arrays)&#123; logError(item)&#125;for (i in arrays.indices)&#123; logError(arrays[i])&#125; 遍历 map 12345// 遍历mapval maps = mapOf(Pair("a", "b"), Pair("a1", "b1"))for ((key, value) in maps) &#123; logError("map($key-&gt;$value)")&#125; 遍历字符串 12345// 遍历字符串val str = "test"for (s in str)&#123; logError("$s in str")&#125; while 循环结构用法与其他语言是一致的。 12345678910var a = 0while (a &gt; 100) &#123; logError("a is $a") a++&#125;do &#123; logError("a is $a") a++&#125; while (a &gt; 100) 返回与跳转Kotlin 中有三种标签可以跳出程序流程 return. 默认行为是, 从最内层的函数或 匿名函数 中返回。break. 结束最内层的循环。continue. 在最内层的循环中, 跳转到下一次循环。 Kotlin 中的任何表达式都可以用 label 标签来标记。标签的形式与标识符相同, 后面附加一个 @ 符号,如 loopOut@,使用标签标记位置，就可以使用程序跳出操作符跳出指定位置，如 break@loopOut,continue@loopOut,return@loopOut。需要注意的是中间不需要有空格，他们是一体的。如果有标签的同时又有返回值，使用 return@loopOut 100 这样的形式，意为跳出到 loopOut 标签位置，返回值是 100 。 12345678910111213fun testFun6() &#123; loopOut@ for (i in 1..10) &#123; loopIn@ for (j in 10..100) &#123; if (i * j == 100) break@loopOut if (i * j &lt; 10) continue@loopIn if (i * j == 101) break@loopIn logError("result = $&#123;i * j&#125;") &#125; &#125;&#125; 在 Kotlin 中, 通过使用字面值函数(function literal), 局部函数(local function), 以及对象表达式(object expression), 允许实现函数的嵌套。通过标签限定的 return 语句, 可以从一个外层函数中返回. 最重要的使用场景是从 Lambda 表达式中返回。 如下面的例子中，默认会从函数 testFun61() 中返回，返回值为9，而且你写 return 语句时，编译器会提示你必须返回一个 Int 类型。这种非局部的返回(non-local return), 仅对传递给 内联函数(inline function) 的 Lambda 表达式有效。 123456789// 函数会返回 9fun testFun61(): Int &#123; val arrays = Array(10, &#123; i -&gt; i * i &#125;) arrays.forEach &#123; if (it == 9) return it &#125; return 0&#125; 如果需要从内部 Lambda 表达式跳出而不是从函数中返回，可以使用标签指定跳出目标。使用隐含标签会更方便一些, 隐含标签的名称与 Lambda 表达式被传递去的函数名称相同。如下面的隐含标签为 forEach@。 12345678910111213141516171819// 此时返回 0fun testFun62():Int&#123; val arrays = Array(10, &#123; i -&gt; i * i &#125;) arrays.forEach signal@&#123; if (it == 9) return@signal &#125; return 0&#125;// 使用隐含标签fun testFun63():Int&#123; val arrays = Array(10, &#123; i -&gt; i * i &#125;) arrays.forEach &#123; if (it == 9) return@forEach &#125; return 0&#125;]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AS 升级 gradle 到2.3.1异常]]></title>
    <url>%2Farticle%2F2758264870%2F</url>
    <content type="text"><![CDATA[AndroidStudio升级gradle插件版本到2.3.1之后不能运行了，提示MultiDex找不到，由此引发了很多问题。 开始升级插件版本升级到2.3.1，配置project / build.gradle 1classpath "com.android.tools.build:gradle:2.3.1" gradle版本升级到3.3，配置project / gradle / gradle-wrapper.properties 123456#Sun Mar 05 00:36:45 CST 2017distributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/distszipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/distsdistributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip 分包引起的问题配置分包123456defaultConfig &#123; multiDexEnabled true &#125; 依赖添加compile 'com.android.support:multidex:1.0.1' 小米的问题一切都ok之后出现了新的问题，Failed to establish session然后无法安装应用，在github上面找到了回答，瞻仰一下。 最后总结就是要把开发者模式的MIUI优化选项给关闭掉，不然安装不了。之前还有一个开启允许Usb安装的选项，不打开的话也无法安装应用，总之小米手机特别一点。 123456789101112Works !for those who suffer from this:enable developer mode - In your phone, go to Settings, About phone and click on MIUI version 7 times. You’ll see a pop up which says you are a developer now. Go back to Settings, Additional settings, Developer options and enable USB Debugging. Connect your phone to your PC/Mac and on the phone authorize your computergo back to Developer options, scroll down to find Turn on MIUI optimization and disable it. Your phone will be rebootedTry it now :)]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AndroidTips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android编译FFmpeg之HelloWorld]]></title>
    <url>%2Farticle%2F3809198562%2F</url>
    <content type="text"><![CDATA[编译FFmpeg3.3.1的so文件，并在Android工程中使用。 FFmpeg版本：3.3.1 ／ OS：Mac OSX 本文博客链接 GitHub，本文介绍内容请查看hello_world分支 ps: 开始的时候我只编译出了6个so文件，缺少libavdevice.so和libpostproc.so，主要是因为build_andorid.sh的配置不同，现在可以编译出8个so文件，在文章中的图片出现的都是6个so文件，特此声明。 源代码 GitHub - FFmpegAndroidSupport(注意在 hello_world 分支) 配置 NDK 环境打开~/.bash_profile文件，添加ndk的环境变量，最后别忘了source .bash_profile更新配置，完成之后运行 ndk-build -v查看版本，没有提示找不到命令就可以了。 12# ndk export PATH=$&#123;PATH&#125;:/Users/march/AndroidRes/sdk/ndk-bundle 修改 configure修改ffmpeg-3.3.1/configure文件，这个主要是生成的lib包的包名规范成以libxxx.so的形式。 否则生成的so文件在android下是无法加载的，替换过程一定要谨慎，需要全部替换掉。这里我提供一个替换好的configure文件供参考:thumbsup: 1234567891011# 找到下面几行替换一下SLIBNAME_WITH_MAJOR='$(SLIBNAME).$(LIBMAJOR)' LIB_INSTALL_EXTRA_CMD='$$(RANLIB)"$(LIBDIR)/$(LIBNAME)"' SLIB_INSTALL_NAME='$(SLIBNAME_WITH_VERSION)' SLIB_INSTALL_LINKS='$(SLIBNAME_WITH_MAJOR)$(SLIBNAME)'# 替换后的结果SLIBNAME_WITH_MAJOR='$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)' LIB_INSTALL_EXTRA_CMD='$$(RANLIB)"$(LIBDIR)/$(LIBNAME)"' SLIB_INSTALL_NAME='$(SLIBNAME_WITH_MAJOR)' SLIB_INSTALL_LINKS='$(SLIBNAME)' 编写 build_android.sh 脚本编写ffmpeg-3.3.1/build_android.sh脚本注意,NDK后面的路径换成自己的路径，可以参考编写好的文件:smile: 关注下面的配置，不要直接拷贝--disable-avdevice加上之后将不会生成avdevice.so文件--enable-gpl加上之后将会生成postproc.so文件 123456789101112131415161718192021222324252627282930313233343536373839#!/bin/shNDK=/Users/march/AndroidRes/sdk/ndk-bundleSYSROOT=$NDK/platforms/android-23/arch-armTOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64function build_one&#123;./configure \--target-os=linux \--prefix=$PREFIX \--arch=arm \--disable-doc \--enable-shared \--disable-static \--disable-yasm \--disable-symver \--enable-gpl \--disable-ffmpeg \--disable-ffplay \--disable-ffprobe \--disable-ffserver \--disable-doc \--disable-symver \--cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \--enable-cross-compile \--sysroot=$SYSROOT \--extra-cflags="-Os -fpic $ADDI_CFLAGS" \--extra-ldflags="$ADDI_LDFLAGS" \$ADDITIONAL_CONFIGURE_FLAGmake cleanmakemake install&#125;make cleanCPU=armPREFIX=$(pwd)/android/$CPUADDI_CFLAGS="-marm"build_one 编译生成 ffmpeg so 库执行build_android.sh脚本如果没有权限可以使用chomd +x增加执行权限然后等一段时间，😯不，是很长时间，所以前面的配置要谨慎，不然编译完了之后发现有问题，就会很💔，你会发现在FFmpeg中出现了一个名为android的文件夹。目录如下 将编译生成的文件 copy 到 AS 中目录如下，jniLibs里面是最后我们编译生成好之后拷贝进去的，现在应该是空的，编译生成的so文件会生成在src/main/libs目录里面，生成好之后，如果你使用jniLibs目录加载so,就拷贝到这里。图片中的描述略有歧义。 编写 C 语言的 JNI 接口这里是拷贝了别人写好的代码，这篇文章主要还是把整个编译流程完成，因此直接用了别人已经写好的，后面的文章会对这一块详细介绍。 编写文件名为ffmpeg_support.c的c文件，声明java调用接口，函数命名需要按照Java_包名_类名_方法名的形式来编写，区分大小写。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include "libavcodec/avcodec.h"#include "libavformat/avformat.h"#include "libavfilter/avfilter.h"#ifdef ANDROID#include &lt;jni.h&gt;#include &lt;android/log.h&gt;#define LOGE(format,...) __android_log_print(ANDROID_LOG_ERROR,"myndk",format,##__VA_ARGS__)#else#define LOGE(format,...) printf("(&gt;_&lt;)"format "\n",##__VA_ARGS__)#endifJNIEXPORT jstring Java_com_march_fas_FFmpegSupport_ffmpegHello(JNIEnv *env,jobject obj)&#123; char info[40000] =&#123;0&#125;; av_register_all(); AVCodec *c_temp = av_codec_next(NULL); while(c_temp != NULL)&#123; if(c_temp-&gt;decode!=NULL)&#123; sprintf(info,"%s[Dec]",info); &#125;else&#123; sprintf(info,"%s[Enc]",info); &#125; switch(c_temp-&gt;type)&#123; case AVMEDIA_TYPE_VIDEO: sprintf(info,"%s[Video]",info); break; case AVMEDIA_TYPE_AUDIO: sprintf(info,"%s[AUDIO]",info); break; default: sprintf(info,"%s[Other]",info); break; &#125; sprintf(info,"%s[%10s]\n",info,c_temp-&gt;name); c_temp=c_temp-&gt;next; LOGE("chendong"); &#125; return (*env)-&gt;NewStringUTF(env,info);&#125; 编写 Android.mk12345678910111213141516171819202122232425262728293031323334353637383940LOCAL_PATH :=$(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := avcodecLOCAL_SRC_FILES := libavcodec-57.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := avfilterLOCAL_SRC_FILES := libavfilter-6.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := avformatLOCAL_SRC_FILES := libavformat-57.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := avutilLOCAL_SRC_FILES := libavutil-55.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := swresampleLOCAL_SRC_FILES := libswresample-2.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := swscaleLOCAL_SRC_FILES := libswscale-4.soinclude $(PREBUILT_SHARED_LIBRARY)#Programinclude $(CLEAR_VARS)LOCAL_MODULE :=sffhelloworldLOCAL_SRC_FILES := simplest_ffmpeg_helloworld.cLOCAL_C_INCLUDES += $(LOCAL_PATH)/includeLOCAL_LDLIBS := -llog -lzLOCAL_SHARED_LIBRARIES := avcodec avfilter avformat avutil swresample swscaleinclude $(BUILD_SHARED_LIBRARY) 编写 Application.mk关于Application.mk的相关配置可以查看官方文档下面android-14指的是最小支持的AndroidApi在4.0以上，具体看可以查看官方文档APP_PLATFORM这块的内容。这个跟你在manifest文件里面配置的min-sdk也有些关联，不拼配会有警告，不过现在都会在gradle文件中配置minSdk，不用在意也可以，实在强迫症就在manifest里面再声明一次。 12APP_ABI := armeabi armeabi-v7aAPP_PLATFORM := android-14 编译生成可用的 so 文件local.properties 如下配置ndk目录,通常是默认配置好的。 12ndk.dir=/Users/march/AndroidRes/sdk/ndk-bundlesdk.dir=/Users/march/AndroidRes/sdk 然后进入到terminal，cd到jni目录，执行 ndk-build 命令等待一段时间编译完成的结果应该是这样的，如果你使用jniLibs目录作为加载so的目录，将so文件拷贝到jniLibs中。 在 app/build.gradle 配置以下代码，可以将 jniLibs 目录指向 libs，这样就不需要每次拷贝 so 文件到 jniLibs 了 12345678sourceSets &#123; //定义编译时编译文件的路径 main &#123; res.srcDirs = ['src/main/res'] jniLibs.srcDirs = ['src/main/libs'] jni.srcDirs = [] &#125; &#125; 调用 JNI加载so文件以及java层的调用接口 123456789101112131415161718192021222324252627282930public class FFmpegSupport &#123; static &#123; try &#123; System.loadLibrary("avutil-55"); System.loadLibrary("swresample-2"); System.loadLibrary("avcodec-57"); System.loadLibrary("avformat-57"); System.loadLibrary("swscale-4"); System.loadLibrary("avfilter-6"); System.loadLibrary("ffmpeg_support"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static native String ffmpegHello();&#125;// 测试public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); FFmpegSupport.ffmpegHello(); &#125;&#125; 运行项目编辑app/build.gradle配置好so加载路径，将so文件拷贝进jniLibs目录，当然你如果喜欢放在libs目录里面也是可以的，一定要记得armeabi/xxx.so，abi目录不要忘记，不然会提示找不到，不要问我为什么特别提醒 :smile: 1234567sourceSets &#123; //定义编译时编译文件的路径 main &#123; res.srcDirs = [&apos;src/main/res&apos;] jniLibs.srcDirs = [&apos;src/main/jniLibs&apos;] &#125; &#125; 点击运行，出现了以下错误：Your project contains C++ files but it is not using a supported native build system。下面的配置可以解决这个问题。 123456789101112// 在gradle.properties添加Android.useDeprecatedNdk=true// 在app/build.gradle 添加jni.srcDirs = []这一行sourceSets &#123; //定义编译时编译文件的路径 main &#123; res.srcDirs = [&apos;src/main/res&apos;] jniLibs.srcDirs = [&apos;src/main/jniLibs&apos;] jni.srcDirs = [] &#125; &#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Ndk</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Ndk</tag>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin开发-1-新特性篇]]></title>
    <url>%2Farticle%2F3395269050%2F</url>
    <content type="text"><![CDATA[Google 2017 IO大会宣布 Kotlin作为 Android 一级开发语言，一时间各大技术博客网站，微信订阅号，朋友圈都被 Kotlin 刷屏了，全都是对 Kotlin 的简要介绍，现在过了大约一周感觉大家慢慢平静下来了，发布的文章的质量也更高，更有针对性，相信不久的将来再广大开发者的推动下，Kotlin 会发展的越来越好。 就像 Google 发布 Android 专用的开发工具 AndroidStudio 一样，仅仅一年多的时间，Eclipse 和 Idea 在 Android 开发领域就被完全取代了，Google 的决心是看得见的。Kotlin 能够与 Java 无缝兼容，性能更好，语法更优雅，又有类型推断，函数式编程等新特性支持，相信在 Android 开发领域，取代Java 只是时间问题，毕竟是官网支持的。 本文是对 Kotlin 的第一次接触，重点放在项目搭建和新特性的体验上，更深的细节将会放在后面的文章中研究，go ~ 推荐文章Kotlin 官网和对应中文版，这个中文版文档的风格和官网风格一样，对比看起来舒服一点，推荐。 kotlin官网文档 ／ http://kotlinlang.org Kotlin官方文档中文翻译版本 ／ http://www.liying-cn.net/kotlin/ Kotlin 的两篇推荐文章，很早就在推荐使用了 微信文章-你为什么需要kotlin Segmentfault上腾讯bugly的一篇文章，介绍了kotlin的基本特性 另外备注几份参考文档，各有优势，作补充用 kotlin官网文档中文版 ／ https://hltj.gitbooks.io &lt; kotlin for andriod developer&gt; 中文翻译版 ／ https://wangjiegulu.gitbooks.io https://huanglizhuo.gitbooks.io 基本配置AS 3.0 已经自带了Kotlin的配置，本文在 AS 2.3 基础上进行配置。 打开Setting -&gt; plugin下载插件，重启AS，创建项目 -&gt; new File -&gt; Kotlin Activity，会提示配置相关信息，点击配置即可，插件会在工程中作下面的相关配置，以上可以使用IDE很快完成，整体项目没有很大变化。 project/build.gradle文件 123456buildscript &#123; ext.kotlin_version = '1.0.6' dependencies &#123; classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version" &#125;&#125; app/build.gradle 文件 1234567891011121314151617181920212223242526272829apply plugin: 'com.android.application'apply plugin: 'kotlin-android'// 基于Android的扩展增强apply plugin: 'kotlin-android-extensions'android &#123; compileSdkVersion 25 buildToolsVersion "25.0.1" defaultConfig &#123; ... &#125; buildTypes &#123; ... &#125; // 资源路径 sourceSets &#123; main.java.srcDirs += 'src/main/kotlin' &#125;&#125;dependencies &#123; // kotlin compile "org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"&#125;// 需要加入这个repositories &#123; mavenCentral()&#125; 汇总一些细节 Kotlin 不强制在每句代码后面加 ;。 Kotlin 不支持三目运算符了，可以使用 if(condition) 表达式1 else 表达式2 的方式代替，比如 val a = if(b&gt;0) 100 else 0 不再使用 new 关键字创建对象，而是更简单的 val user = User() 与 Java 相反，Kotlin 中所有类和方法都默认是不允许继承的，也就是 final 的，如果想要继承类或重写方法可以使用 open 关键字。 Kotlin 中类名不必与文件同名，函数也不是必须声明在类中才可以，可以直接声明在文件中。 Kotlin 中注释允许嵌套。 使用 is 代替 instanceof ，如 if(str is String){...} 引用xml中的控件再也不用 findViewById() 也不用 ButterKnife 注解啦. 这种扩展在性能上和 findViewById() 是一样的，另外需要注意的是，使用这种扩展必须要在 layout 被设置好了才能使用, 在 fragment 里面, 要等到 onViewCreated() 之后才能使用. 12345678910111213141516&lt;!--在xml定义，id为 mTestTv --&gt;&lt;TextView android:id="@+id/mTestTv" android:layout_width="match_parent" android:layout_height="match_parent" android:background="#fff" android:gravity="center" android:text="test" android:textColor="#000" android:textSize="18sp"/&gt;// app/build.gradle中扩展增强插件apply plugin: 'kotlin-android-extensions' import kotlinx.android.synthetic.main.main_activity.*mTestTv.text = "test it" 空值安全(Null Safety)Kotlin 是一种空值安全的语言，他基本能帮助你告别 NPE，并且提供了大量的操作符简化判空操作，更多内容将在下一篇文章&lt;常量变量篇&gt;中详细介绍。 一个使用 safe calls 简化调用的实例 123456789val myParam1:Student? = null// java 中，在使用之前，我们通常会做一系列判空操作if(myParam1!=null &amp;&amp; myParam1.myCls!=null)&#123; Log.e(TAG,"$&#123;myParam1.myCls.length&#125;")&#125;// Kotlin safe callsLog.e(TAG,"$&#123;myParam1?.myCls?.length&#125;") 字符串模版再也不用 + 或者 StringBuilder 来回拼接和计算字符串，kotlin提供了更加优雅的实现方式。 使用 ${表达式} 的方式可以在字符串中间插入数据。只有一个简单值时可以省略 {} ,同时也支持复杂表达式的计算。 12345val user = User()val param = 100var str = "test str template like $param"str = "test str template like $&#123;user.name&#125; "str = "test str template like $&#123;if (user.age &lt;= 0) 100 else user.age&#125;" 扩展函数和属性Kotlin 提供了向一个类扩展新功能的能力，而且不必从这个类继承, 也不必使用任何设计模式, 比如 Decorator 模式之类。 这种功能是通过一种特殊的声明来实现的, Kotlin 中称为 扩展(extension)。 Kotlin 支持 扩展函数(extension function) 和 扩展属性(extension property)。 另外我刚开始看这个地方的时候，是将扩展函数声明在使用它的类中，在另一个类中要使用就无法引用了，难道每次都要重新写？那不是很鸡肋。其实由于 java 的惯性，我觉得所有的方法必须声明在类中，java 中确实是这样的， 但是 Kotlin 不必这样做，你的类文件的名字可以不和文件名相同，函数也可以直接声明在文件中，而不是某个类中。 注意：不需要声明 class，扩展方法和属性是静态加载的， 直接写在 .kt 文件中即可。 注意：在扩展属性的 get() 方法中不要访问该属性，因为你一旦访问该属性，就会调用 get() 方法，从而造成堆栈溢出。 新建 ContextExtensions.kt 文件，在里面声明该扩展函数和扩展属性 12345678910111213// 扩展函数fun Context.logError(msg: String) &#123; Log.e(this.javaClass.simpleName, msg)&#125;// 扩展属性var Context.extensionProperty: String get() &#123; return javaClass.simpleName &#125; set(value) &#123; extensionProperty = value &#125; 接下来就可以在任何 Context 的实现类，比如 Activity 中使用 logError() 函数和 extensionProperty 属性 1234// 扩展函数logError("方法扩展")// 扩展属性logError(extensionProperty) 自动类型推断Kotlin支持自动的类型推断，比如我们可以如下声明一个常量，那么常量 myStr 的类型被推断为 String 类型。可以使用 String 的API。 12val myStr = ""Log.e(tag,"str length = $&#123;myStr.length&#125;") 当进行显示类型转换时，自动进行类型推断，下面声明了两个类，Student 继承自 User ,在 stuUser is Student 的判断之后，stuUser 的类型被推断为 Student ，因此可以直接访问 myClass 属性。 123456789101112open class User(val name: String, val age: Int) &#123; // 二级构造函数 constructor() : this("", 0)&#125;class Student(name: String, age: Int,val myCls: String) : User(name, age)// 自动类型推断val stuUser = User()if (stuUser is Student) &#123; // 这里stuUser已经是Student类型，不需要进行强制转换。 Log.e(tag, stuUser.myCls)&#125; 支持 lambda 表达式使用 lambda 表达式可以使代码更加清晰，原来一层一层的 {} 都被省略掉了，不可否认的是可读性要比原来差一点，不过习惯了就好多了。 另外 Kotlin 也为 lambda 表达式提供了很多扩展支持，来强化 lambda 表达式的使用，在kotlin中,如果函数的最后一个参数是函数，那么这个参数可以直接写在圆括号外面（要用花括号），如果只有一个函数参数，可以直接省略圆括号！而且当参数只有一个时可以省略参数而使用 it 来代替。 12345678910111213141516171819mTestTv.setOnClickListener &#123; v -&gt; run &#123; logError("test" + v.id) &#125;&#125;mTestTv.setOnClickListener &#123; v -&gt; if (v.id == 0) &#123; logError("test$&#123;v.id&#125;)") &#125; else &#123; logError( "test$&#123;v.id&#125;)") &#125;&#125;mTestTv.setOnClickListener &#123; logError("test$&#123;it.id&#125;)")&#125; 函数是一等公民函数是一等公民指的是函数和对象，基本数据类型一样，可以作为变量，可以作为参数传递，可以作为返回值。 函数不依赖于类，可以独立存在。 Kotlin支持函数式编程。函数声明的方式为 (参数名:参数类型...)-&gt; 返回值类型 ，比如 (param:String)-&gt;Int ，指的是一个参数为 String 类型，返回值是 Int 类型的函数，如果没有返回值则使用 Unit 关键字。 刚开始尝试像使用变量一样使用函数，有些不太适应，当你需要将函数进行传递赋值时，先写一个 {}，将函数声明在 {} 中即可； 尝试简单声明函数 12345678fun myFun(param: String): Int &#123; logError("函数") return param.hashCode()&#125;fun myFunReturnVoid(param: String): Unit &#123; logError("声明函数返回空")&#125; 函数作为变量 12345678// 函数作为变量val funVal: (param: String) -&gt; Int = &#123; // 参数param param: String -&gt; // 返回hashcode param.hashCode()&#125;funVal("测试函数作为变量调用") 函数作为参数，下面的函数接受一个参数为 String 返回值为 Int 的函数作为参数，并调用他。lis 是形参，(String) -&gt; Int)是函数类型。下面的两个重载函数的例子，是为了展示只有一个函数参数时的简化写法，多个参数时使用常规写法。结合上面 lambda 表达式的相关用法。 12345678910111213141516171819// 只有一个函数做参数，并且只有一个参数fun testFunOneFunParam(lis: (String) -&gt; Int): Int &#123; return lis("测试函数作为参数传递,只有一个函数作为参数")&#125;// 有多个参数，并且函数不是最后一个fun testFunMultiParam(lis: (String) -&gt; Int, param: String): Int &#123; return lis("测试函数作为参数传递,第一个参数是函数")&#125;// 调用testFunOneFunParam &#123; param -&gt; param.hashCode()&#125;testFunMultiParam(&#123; param -&gt; param.hashCode()&#125;, "测试函数不是作为第一个参数的情况") 函数作为返回值 12345678910// 函数作为返回值fun returnFun(param: String): ((intParam: Int) -&gt; String) &#123; return &#123; intParam -&gt; "int param is $intParam param is $param" &#125;&#125;// 调用returnFun("执行完返回一个函数")(100) 单表达式函数，当函数的返回值只有一个简单表达式时，可以使用单表达式函数，简化代码 123456789// 单表达式函数fun testFun2() = 100// 单表达式函数结合whenfun testFun3(param: Int) = when (param) &#123; 0 -&gt; 0 in 1..5 -&gt; 1 5, 6, 7 -&gt; 2 else -&gt; 100&#125; 数据类我们经常会创建一些数据类, 什么功能也没有, 而仅仅用来保存数据. 在这些类中, 某些常见的功能经常可以由类中保存的数据内容即可自动推断得到. 在 Kotlin 中, 我们将这样的类称为 数据类, 通过 data 关键字标记； 定义一个数据类，只需要一行代码即可，{} 可以省略掉，数据类会默认生成 equals() ，toString() ， copy() 等方法，这里特别提一下 copy() ，可以生成一个新的数据，这个特性是相当不错的。 当然数据类也有很多限制 主构造器至少要有一个参数;主构造器的所有参数必须标记为 val 或 var;数据类不能是abstract类, open 类, 封闭(sealed)类, 或内部(inner)类;数据类不能继承自任何其他类(但可以实现接口). 1234data class DataModel(val param1: String, val param2: Int)// 使用val dataModel = DataModel("p1",100)dataModel.copy("p2",99) 数据类添加成员方法 123456data class DataModel(val param1: String, val param2: Int) &#123; fun speak(msg: String) &#123; Log.e("DataModel", "speak$msg") &#125;&#125;dataModel.speak("haha")]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL]]></title>
    <url>%2Farticle%2F1299261529%2F</url>
    <content type="text"><![CDATA[1. 前言SQL，指结构化查询语言，全称是(Structured Query Language)，SQL 语句是大小写不敏感的。 说明： 使用db_name作为数据库名，使用tb_name作为表名。 使用col_name作为列名，使用row_name作为行名。 使用alias_name作为别名。 [xxx]表示可选使用的属性。 (a…|b…|c…)表示三种情况任选一种使用。 2. 数据库配置123456789编辑 ./bash_profile 文件，加入别名open ~/.bash_profile# mysqlalias mysql=/usr/local/mysql/bin/mysql连接到mysql服务mysql -u root -p MySQL123sudo /usr/local/mysql/support-files/mysql.server startsudo /usr/local/mysql/support-files/mysql.server stopsudo /usr/local/mysql/support-files/mysql.server restart 3. 库操作语句1234567891011121314显示数据库列表SHOW databases;创建数据库CREATE DATABASE db_name; 使用数据库USE db_name; 删除数据库DROP database db_name;使用字符集SET names utf8; 4. 表操作语句关于表字段约束的讲解见附2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546创建表CREATE TABLE table_name(col_name1 data_type(size) [约束],col_name2 data_type(size) [约束],col_name3 data_type(size) [约束],....);eg:CREATE TABLE Persons(PersonID int,LastName varchar(255),FirstName varchar(255),Address varchar(255),City varchar(255));删除表DROP TABLE tb_name;删除表数据，但是保留表结构TRUNCATE TABLE tb_name增加一列ALTER TABLE tb_name ADD col_name 数据类型 [约束]删除一列ALTER TABLE tb_name DROP COLUMN col_name;修改一列ALTER TABLE tb_name ALTER old_col_name new_col_name 数据类型 [约束]修改一列的数据类型/* SQL Server / MS Access */ALTER TABLE tb_nameMODIFY COLUMN col_name 数据类型/* My SQL / Oracle */ALTER TABLE tb_nameALTER COLUMN col_name 数据类型添加主键ALTER TABLE tb_name ADD PRIMARY KEY(col_name);删除主键ALTER TABLE tb_name DROP PRIMARY KEY(col_name); 5. 增删改查语句5.1 SELECT 语句123456基本查询语句[DISTINCT] 可选，用于返回唯一不同的值。SELECT [DISTINCT] * FROM tb_name;SELECT [DISTINCT] col_name1,col_name2 FROM tb_name;eg:SELECT name,country FROM Websites; 5.2 SELECT INTO 语句使用SELECT INTO和 INSERT INTO SELECT 语句，复制表数据。MySQL 数据库不支持 SELECT INTO 语句，但支持 INSERT INTO SELECT。新表将会使用 SELECT 语句中定义的列名称和类型进行创建。您可以使用 AS 关键字来应用新名称。 12345678910111213141516171819复制全部数据或者使用WHERE子句筛选SELECT *INTO new_tb_name [IN db_name]FROM old_tb_name;or复制指定列数据或者使用WHERE子句筛选SELECT col_name...INTO new_tb_name [IN db_name]FROM old_tb_name;复制全部数据或者使用WHERE子句筛选INSERT INTO new_tb_nameSELECT * FROM old_tb_name;or复制指定列数据或者使用WHERE子句筛选INSERT INTO new_tb_name(col_name...)SELECT col_name...FROM old_tb_name; 5.3 INSERT INTO 语句1234567891011// 不指定列名插入INSERT INTO tb_nameVALUES (value1,value2,value3,...);// 指定列名插入INSERT INTO tb_name (col_name1,col_name2,col_name3,...)VALUES (value1,value2,value3,...);eg:INSERT INTO Websites (name, url, country)VALUES ('stackoverflow', 'http://stackoverflow.com/', 'IND'); 5.4 UPDATE 语句12345678910使用UPDATE语句时，一定要添加WHERE条件，否则会更新所有的数据。UPDATE tb_nameSET col_name1=value1,col_name2=value2,...WHERE (这里参照WHERE子句，匹配指定数据);eg:UPDATE Websites SET alexa='5000', country='USA' WHERE name='aasdfghjkl'; 5.5 DELETE 语句123456789DELETE FROM tb_nameWHERE (这里参照WHERE子句，匹配指定数据);DELETE * FROM tb_nameWHERE (这里参照WHERE子句，匹配指定数据);eg:DELETE FROM WebsitesWHERE name='百度' AND country='CN'; 6. WHERE 子句1234SELECT col_name1,col_name2FROM tb_nameWHERE col_name1 operator value1 [逻辑运算符 col_name2 operator value2...]; 6.1 逻辑运算符1234567891011逻辑运算符NOT 非操作AND 与操作，表达式前后条件必须都成立才为trueOR 或操作，表达式前后操作有一个成立即为true逻辑运算的优先级：() NOT AND OReg:SELECT * FROM WebsitesWHERE alexa &gt; 15AND (country='CN' OR country='USA'); 6.2 比较运算符123456789101112131415161718192021222324252627282930313233343536373839/*比较运算符=,&gt;,&lt;,&gt;=,&lt;=,&lt;&gt;(不等于，一些版本中写作!=),BETWEEN...AND(在范围内),LIKE(模糊查询),IN(指定所有可能值进行匹配),IS NULL(空值判断)*/eg:空值查询 IS NULLSELECT * FROM tb)nae WHERE col_name IS NULL;存在查询 INSELECT * FROM tb_name WHERE col_name IN (5000,3000,1500);SELECT * FROM tb_name WHERE col_name IN ('abc','tyu','test');区间查询 BETWEEN...AND...区间查询两边都是闭区间，类似[1,100]SELECT * FROM tb_name WHERE col_name BETWEEN 100 AND 200;模糊查询 LIKESELECT * FROM tb_name WHERE col_name LIKE 'M%';todo 模糊查询通配符% 表示多个字值，_ 下划线表示一个字符。 M% : 为能配符，正则表达式，表示的意思为模糊查询信息为 M 开头的。 %M% : 双百分号表示查询的信息在内容中间。 %M_% : 表示查询的字母在内容的倒数第二位。 7. JOIN 子句(表连接)JOIN 子句用于基于这些表之间的共同字段把来自两个或多个表的行结合起来。 连接方式 描述 INNER JOIN 如果表中有至少一个匹配，则返回行 LEFT JOIN 即使右表中没有匹配，也从左表返回所有的行 RIGHT JOIN 即使左表中没有匹配，也从右表返回所有的行 FULL JOIN 只要其中一个表中存在匹配，则返回行 7.1 INNER JOIN 内连接INNER JOIN 也可以简写为 JOININNER JOIN关键字在表中存在至少一个匹配时返回行。1234SELECT col_nameFROM tb_name1INNER JOIN tb_name2ON tb_name1.col_name=tb_name2.col_name; 7.2 LEFT OUTER JOIN 左外连接LEFT OUTER JOIN也可以简写为 LEFT JOINLEFT JOIN 关键字从左表返回所有的行，即使右表中没有匹配，如果右表中没有匹配，则结果为 NULL。1234SELECT col_nameFROM tb_name1LEFT OUTER JOIN tb_name2ON tb_name1.col_name=tb_name2.col_name; 7.3 RIGHT OUTER JOIN 右外连接RIGHT OUTER JOIN 也可以简写为 RIGHT JOINRIGHT JOIN 关键字从右表返回所有的行，即使左表中没有匹配，如果左表中没有匹配，则结果为NULL。1234SELECT col_nameFROM tb_name1RIGHT OUTER JOIN tb_name2ON tb_name1.col_name=tb_name2.col_name; 7.4 FULL OUTER JOIN 全外连接FULL OUTER JOIN 关键字只要左表 和右表 其中一个表中存在匹配，则返回行.FULL OUTER JOIN 关键字结合了 LEFT JOIN 和 RIGHT JOIN 的结果。1234SELECT col_nameFROM tb_name1FULL OUTER JOIN tb_name2ON tb_name1.col_name=tb_name2.col_name; 8. 关键字8.1 AS 关键字,使用别名使用AS关键字，可以为表名称或列名称指定别名，基本上，创建别名是为了让列名称的可读性更强，以下情况使用别名很有用。 在查询中涉及超过一个表 在查询中使用了函数 列名称很长或者可读性差 需要把两个列或者多个列结合在一起 ps:别名如果包含空格，要求使用双引号或方括号。 12345678910111213141516列别名用法使用列别名查询之后的展示数据将使用别名来展示SELECT col_name AS alias_nameFROM tb_name;eg:SELECT name AS n, country AS cFROM Websites;表别名用法SELECT col_nameFROM tb_name AS alias_name;eg:SELECT w.name, w.url, a.count, a.date FROM Websites AS w, access_log AS a WHERE a.site_id=w.id and w.name="百度"; 8.2 ORDER BY 关键字12345678910ORDER BY 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字。SELECT col_name1,col_name2FROM tb_nameORDER BY col_name (ASC|DESC)[,col_name (ASC|DESC)...];eg:SELECT * FROM WebsitesORDER BY alexa DESC; 8.3 LIMIT 关键字12345使用limit关键字，可以跳过m条数据，查询n条数据，m可以省略，表示从头开始查询。SELECT * FROM tb_name LIMIT [m,]n;eg：SELECT * FROM Websites LIMIT 3,2; 8.4 UNION 关键字UNION 操作符用于合并两个或多个 SELECT 语句的结果集。UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。UNION 只会选取不同的值。请使用 UNION ALL 来选取重复的值！ 1234567SELECT col_name FROM tb_name1UNIONSELECT col_name FROM tb_name2;SELECT col_name FROM tb_name1UNION ALLSELECT col_name FROM tb_name2; 9. 函数9.1 CONCAT()连接函数结果将会拼接CONCAT()函数中的全部值 1234下面的例子将会拼接三个字段的值(结果：'www.baidu.com,100,china')，并作为一列(site_info)显示SELECT name, CONCAT(url, ', ', alexa, ', ', country) AS site_infoFROM Websites; 10. 索引在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据。在表中创建索引，以便更加快速高效地查询数据。用户无法看到索引，它们只能被用来加速搜索/查询。更新一个包含索引的表需要比更新一个没有索引的表花费更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。 10.1 创建索引12345678910111213141516创建一个简单的索引。允许使用重复的值：CREATE INDEX index_nameON table_name (column_name)在表上创建一个唯一的索引。不允许使用重复的值：唯一的索引意味着两个行不能拥有相同的索引值。 CREATE UNIQUE INDEX index_nameON table_name (column_name)注释：用于创建索引的语法在不同的数据库中不一样。因此，检查您的数据库中创建索引的语法。 eg:创建索引CREATE INDEX PIndexON Persons (LastName)在多个列上创建索引CREATE INDEX PIndexON Persons (LastName, FirstName) 10.2 删除索引12345678/* MS Access */DROP INDEX index_name ON table_name/* MS SQL Server */DROP INDEX table_name.index_name/* DB2/Oracle */DROP INDEX index_name/* MySQL */ALTER TABLE table_name DROP INDEX index_name 附1. 模糊查询附1.1. 通配符 通配符 描述 示例 % 代替0个或者多个字符 chen%,匹配chen开头的全部数据 _ 代替一个字符 ch_n,匹配类似chan,chbn,chcn这种数据 [charlist] 字符序列中的任一个单个字符 [ABC],匹配A,B,C [^charlist] or [!charlist] 不在字符序列中的任一个字符 [!ABC],匹配除了A,B,C以外的其他字符 123SELECT col_nameFROM tb_nameWHERE col_name LIKE pattern; 附1.2 正则表达式1todo 附2. 表约束 约束 描述 NOT NULL 指示某列不能存储 NULL 值。 UNIQUE 保证某列的每行必须有唯一的值。 PRIMARY KEY NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。 FOREIGN KEY 保证一个表中的数据匹配另一个表中的值的参照完整 性。 CHECK 保证列中的值符合指定的条件。 DEFAULT 规定没有给列赋值时的默认值。 附2.1 NOT NULL 非空约束NOT NULL 约束强制列不接受NULL值。NOT NULL 约束强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或者更新记录。 1234567CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255)); 附2.2 UNIQUE 唯一约束UNIQUE 约束唯一标识数据库表中的每条记录。UNIQUE和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。PRIMARY KEY 约束拥有自动定义的 UNIQUE 约束。请注意，每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。 1234567891011121314151617181920212223242526272829303132/* MySQL */CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),UNIQUE (P_Id))/* SQL Server / Oracle / MS Access */CREATE TABLE Persons(P_Id int NOT NULL UNIQUE,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255))命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),CONSTRAINT uc_PersonID UNIQUE (P_Id,LastName)) 更改UNIQUE约束12345678910111213ALTER TABLE PersonsADD UNIQUE (P_Id)如需命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束，请使用下面的 SQL 语法：ALTER TABLE PersonsADD CONSTRAINT uc_PersonID UNIQUE (P_Id,LastName)撤销 UNIQUE 约束 MySQL：ALTER TABLE PersonsDROP INDEX uc_PersonIDSQL Server / Oracle / MS Access：ALTER TABLE PersonsDROP CONSTRAINT uc_PersonID 附2.3 PRIMARY KEY 主键约束PRIMARY KEY 约束唯一标识数据库表中的每条记录。主键必须包含唯一的值。主键列不能包含 NULL 值。每个表都应该有一个主键，并且每个表只能有一个主键。 123456789101112131415161718192021222324252627282930313233/* MySQL */CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),PRIMARY KEY (P_Id))/* SQL Server / Oracle / MS Access */CREATE TABLE Persons(P_Id int NOT NULL PRIMARY KEY,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255))命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束 CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),CONSTRAINT pk_PersonID PRIMARY KEY (P_Id,LastName))注释：在上面的实例中，只有一个主键 PRIMARY KEY（pk_PersonID）。然而，pk_PersonID 的值是由两个列（P_Id 和 LastName）组成的。 更改PRIMARY KEY约束123456789101112131415ALTER TABLE PersonsADD PRIMARY KEY (P_Id)如需命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束，请使用下面的 SQL 语法：ALTER TABLE PersonsADD CONSTRAINT pk_PersonID PRIMARY KEY (P_Id,LastName)注释：如果您使用 ALTER TABLE 语句添加主键，必须把主键列声明为不包含 NULL 值（在表首次创建时）。撤销 PRIMARY KEY 约束/* MySQL */ALTER TABLE PersonsDROP PRIMARY KEY/* SQL Server / Oracle / MS Access */ALTER TABLE PersonsDROP CONSTRAINT pk_PersonID 附2.4 FOREIGN KEY 外键约束一个表中的 FOREIGN KEY 指向另一个表中的 PRIMARY KEY。FOREIGN KEY 约束用于预防破坏表之间连接的行为。FOREIGN KEY 约束也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。 例如：我们现在有Persons表用来存储用户信息，Persons表主键P_Id表示用户id，Orders表用来存储用户订单，Orders表外键P_Id指向 Persons表的主键P_Id，来约束Orders表中所有订单的用户id必须是在用户表中出现的。 Orders 表中的 P_Id 列指向 Persons 表中的 P_Id 列。 Persons 表中的 P_Id 列是 Persons 表中的 PRIMARY KEY。 Orders 表中的 P_Id 列是 Orders 表中的 FOREIGN KEY。 1234567891011121314151617181920212223242526272829/* MySQL */CREATE TABLE Orders(O_Id int NOT NULL,OrderNo int NOT NULL,P_Id int,PRIMARY KEY (O_Id),FOREIGN KEY (P_Id) REFERENCES Persons(P_Id))/* SQL Server / Oracle / MS Access */CREATE TABLE Orders(O_Id int NOT NULL PRIMARY KEY,OrderNo int NOT NULL,P_Id int FOREIGN KEY REFERENCES Persons(P_Id))命名 FOREIGN KEY 约束，并定义多个列的 FOREIGN KEY 约束CREATE TABLE Orders(O_Id int NOT NULL,OrderNo int NOT NULL,P_Id int,PRIMARY KEY (O_Id),CONSTRAINT fk_PerOrders FOREIGN KEY (P_Id)REFERENCES Persons(P_Id)) 更改外键约束 1234567891011121314151617ALTER TABLE OrdersADD FOREIGN KEY (P_Id)REFERENCES Persons(P_Id)如需命名 FOREIGN KEY 约束，并定义多个列的 FOREIGN KEY 约束，请使用下面的 SQL 语法：ALTER TABLE OrdersADD CONSTRAINT fk_PerOrdersFOREIGN KEY (P_Id)REFERENCES Persons(P_Id)撤销 FOREIGN KEY 约束 /* MySQL */ALTER TABLE OrdersDROP FOREIGN KEY fk_PerOrders/* SQL Server / Oracle / MS Access */ALTER TABLE OrdersDROP CONSTRAINT fk_PerOrders 附2.5 CHECK 约束CHECK 约束用于限制列中的值的范围。如果对单个列定义 CHECK 约束，那么该列只允许特定的值。如果对一个表定义 CHECK 约束，那么此约束会基于行中其他列的值在特定的列中对值进行限制。1234567891011121314151617181920212223242526272829303132/* MySQL */CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),CHECK (P_Id&gt;0))/* SQL Server / Oracle / MS Access */CREATE TABLE Persons(P_Id int NOT NULL CHECK (P_Id&gt;0),LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255))如需命名 CHECK 约束，并定义多个列的 CHECK 约束 CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),CONSTRAINT chk_Person CHECK (P_Id&gt;0 AND City='Sandnes')) 更改CHECK约束1234567891011121314ALTER TABLE PersonsADD CHECK (P_Id&gt;0)如需命名 CHECK 约束，并定义多个列的 CHECK 约束ALTER TABLE PersonsADD CONSTRAINT chk_Person CHECK (P_Id&gt;0 AND City='Sandnes')撤销 CHECK 约束 /* MySQL */ALTER TABLE PersonsDROP CHECK chk_Person/* SQL Server / Oracle / MS Access */ALTER TABLE PersonsDROP CONSTRAINT chk_Person 附2.6 DEFAULT 约束DEFAULT 约束用于向列中插入默认值。如果没有规定其他的值，那么会将默认值添加到所有的新记录。1234567891011121314151617CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255) DEFAULT 'Sandnes')通过使用类似 GETDATE() 这样的函数，DEFAULT 约束也可以用于插入系统值CREATE TABLE Orders(O_Id int NOT NULL,OrderNo int NOT NULL,P_Id int,OrderDate date DEFAULT GETDATE()) 更改DEFAULT约束1234567891011121314151617181920添加 DEFAULT 约束/* MySQL */：ALTER TABLE PersonsALTER City SET DEFAULT 'SANDNES'/* SQL Server / MS Access */ALTER TABLE PersonsALTER COLUMN City SET DEFAULT 'SANDNES'/* Oracle */ALTER TABLE PersonsMODIFY City DEFAULT 'SANDNES'撤销 DEFAULT 约束 /* MySQL */ALTER TABLE PersonsALTER City DROP DEFAULT/* SQL Server / Oracle / MS Access */ALTER TABLE PersonsALTER COLUMN City DROP DEFAULT 附2.7 AUTO INCREMENT]]></content>
      <categories>
        <category>Db</category>
      </categories>
      <tags>
        <tag>Database</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment懒加载]]></title>
    <url>%2Farticle%2F2799403346%2F</url>
    <content type="text"><![CDATA[ViewPager 结合 Fragment 使用时，由于 ViewPager 的特性，会预先加载当前显示页面左右两边的页面，也就是说默认会缓存3个页面，（也可以使用 mViewPager.setOffscreenPageLimit(3); 这个方法来改变这个设置。）]]></content>
      <categories>
        <category>Android</category>
        <category>todo</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo加密文章示例]]></title>
    <url>%2Farticle%2F684233485%2F</url>
    <content type="text"><![CDATA[本文使用Hexo加密]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Extensions</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo]]></title>
    <url>%2Farticle%2F185805107%2F</url>
    <content type="text"><![CDATA[本文主要介绍如何使用 Hexo+NexT 搭建自己的博客之后，和在建站期间遇到的一些问题以及优化方式。 推荐阅读Hexo+Next主题优化 弄懂 NexTpost.md 中 bool 属性默认值是 false BugFix错误 Cannot set property &#39;lastIndex&#39; of undefined，修改 hexo/config.yml 设置 auto_detect: false 12345highlight: enable: true line_number: true auto_detect: false tab_replace: 异常 Cannot find module &#39;./build/Release/DTraceProviderBindings&#39; 不影响使用，但是看着难受，尝试 1234npm install hexo --no-optional// 如果上面的命令有效，可以不执行以下两条npm uninstall hexo-cli -gnpm install hexo-cli -g SEO优化 Hexo NexT主题SEO优化 SEO优化，Google收录 加快访问速度因为是放在 GitHub 上面的，所以访问难免会慢。 可以发布以后检查一下网页加载的瓶颈在哪里，然后做相应的优化。 需要注意的是，放在本地的图片访问会变的很慢，因为资源在 GitHub 上面，所以尽量用七牛等的云存储，文章中使用 url。 fontawsome 访问慢，替换 _config.yml 中的源，效果会好很多 12345678910111213141516171819202122vendors: # Internal path prefix. Please do not edit it. _internal: vendors # Internal version: 2.1.3 jquery: //cdn.bootcss.com/jquery/2.1.3/jquery.min.js # Internal version: 2.1.5 # Fancybox: http://fancyapps.com/fancybox/ fancybox: //cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js fancybox_css: //cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css # Internal version: 1.0.6 fastclick: //cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js # Internal version: 1.9.7 lazyload: //cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js # Internal version: 1.2.1 velocity: //cdn.bootcss.com/velocity/1.3.1/velocity.min.js # Internal version: 1.2.1 velocity_ui: //cdn.bootcss.com/velocity/1.3.1/velocity.ui.min.js # Internal version: 0.7.9 ua_parser: //cdn.bootcss.com/UAParser.js/0.7.12/ua-parser.min.js # Internal version: 4.4.0 # http://fontawesome.io/ fontawesome: //cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css 页面简单加密访问找到文件themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig在&lt;meta&gt;标签之后添加如下js代码 12345678910&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误！'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 在文章的Front-matter定义password 123456789---layout: posttitle: Hexo加密文章示例date: 2017-03-02category: tags: keywords:password: 123456--- 添加留言界面添加page，在博客根目录下执行如下命令，会在source目录下面创建msg/index.md文件。 1hexo new page msg 配置文字和图标，打开themes/next/_config.yml文件，进行如下配置，才能使留言的界面显示 1234567menu: home: / #about: /about archives: /archives tags: /tags categories: /categories guestbook: /guestbook 配置图标，打开themes/next/_config.yml文件，进行如下配置，可以自定义显示在侧边栏的留言的图标，图标的配置使用key-value的形式，下面代码中home``calendar等都是key，使用这个key可以从这个网站-FontAwesome获取图标，如果想更换图标，只需要去那个网站获取图标的名字去掉头部的icon作为key添加到下面代码中即可。 12345678910menu_icons: enable: true home: home about: user categories: th schedule: calendar tags: tags guestbook : comments archives: archive commonweal: heartbeat 打开themes/next/language/zh-CN.yml文件，进行如下配置，才能显示为 留言 字样 123456789menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 guestbook: 留言 过滤文件不进行渲染在给站点添加 README.md 和 Google，百度相关的验证文件时，我们希望这个文件不要被主题渲染，而是源文件直接拷贝到 public 文件夹中，只需要在 hexo/_config.yml 中进行如下配置。 1234skip_render: - 'README.*' - 'google26933bad87c2b3ba.*' - 'baidu_verify_HnYctWkkrH.*' category 分级在头部如下写入 categories 标签 123categories: - Extensions - Hexo 链接唯一化安装 hexo-abbrlink 插件 1npm install hexo-abbrlink --save 配置 hexo/_config.yml，添加如下，完成后打开文件，保存几次，会自动添加 abbrlink 属性，如果已经有值了则不会更改。 123456permalink: article/:abbrlink/ # article/ 可自行更换# abbrlink configabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex 文章压缩安装插件 hexo-all-minifier 1npm install hexo-all-minifier 配置 hexo/_config.yml，添加如下 1234567891011121314151617181920212223242526# 文章压缩html_minifier: enable: true ignore_error: false exclude:css_minifier: enable: true exclude: - &apos;*.min.css&apos;js_minifier: enable: true mangle: true output: compress: exclude: - &apos;*.min.js&apos;image_minifier: enable: true interlaced: false multipass: false optimizationLevel: 2 pngquant: false progressive: false 添加 fork me on github修改 hexoBlog/themes/next/layout/_layout.swig 文件，在 header标签之前添加图片，图片样式可以到丝带状的Fork 或者是 三角形的的Fork选择颜色和位置等。href 中需要修改你为的 github 地址12345678910&lt;div class=&quot;&#123;&#123; container_class &#125;&#125; &#123;% block page_class %&#125;&#123;% endblock %&#125; &quot;&gt; &lt;div class=&quot;headband&quot;&gt;&lt;/div&gt; &lt;!--- add Fork me on Github --&gt; &lt;div class=&quot;forkme&quot;&gt; &lt;a target=&quot;_blank&quot; href=&quot;https://github.com/chendongMarch&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; left: 0; border: 0;&quot; src=&quot;https://camo.githubusercontent.com/567c3a48d796e2fc06ea80409cc9dd82bf714434/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f6461726b626c75655f3132313632312e706e67&quot; alt=&quot;Fork me on GitHub&quot; data-canonical-src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_left_darkblue_121621.png&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;!--- add Fork me on Github --&gt; &lt;header id=&quot;header&quot; class=&quot;header&quot; itemscope itemtype=&quot;//schema.org/WPHeader&quot;&gt; 在 head 标签内添加 style 使小屏幕访问时不显示这个图片 123456789101112131415&lt;head&gt; &#123;% include '_partials/head.swig' %&#125; &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt;&lt;style&gt; .forkme&#123; display: none; &#125;@media (min-width: 768px) &#123; .forkme&#123; display: inline; &#125;&#125; &lt;/style&gt; &#123;% include '_third-party/analytics/index.swig' %&#125;&lt;/head&gt; 代码风格处理查看 hexoBlog/themes/next/source/css/_common/components/highlight/highlight.styl 文件，是对高亮代码的相关配置。找到标签修改既可。 1234567// 行内代码code&#123; // 分行时是不是根据单词划分 word-wrap: break-all/break-word; // 代码颜色 color:#fff;&#125; 添加本地搜索安装插件 hexo-generator-searchdb 1npm install hexo-generator-searchdb --save 配置 hexo/_config.yml 12345search: path: search.xml field: post format: html limit: 10000 配置 next/_config.yml 123# Local searchlocal_search: enable: true 添加加载进度在 Next 主题下打开 /next/layout/_partials/head.swig 文件，在最后追加进度条 下面的代码只在浏览器显示，手机上不显示进度条 1234567891011121314151617181920212223242526272829303132&#123;# 添加进度条 #&#125;&lt;script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"&gt;&lt;/script&gt;&lt;link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"&gt;&lt;style&gt; .pace .pace-progress &#123; background: #0000; /*进度条颜色*/ height: 0px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 0px #0000, 0 0 0px #0000; /*阴影颜色*/ &#125; .pace .pace-activity &#123; display: none; border-top-color: #00d9cf; /*上边框颜色*/ border-left-color: #00d9cf; /*左边框颜色*/ &#125; @media screen and (min-width: 800px) &#123; .pace .pace-progress &#123; background: #00d9cf; /*进度条颜色*/ height: 2px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #00d9cf, 0 0 5px #00d9cf; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #00d9cf; /*上边框颜色*/ border-left-color: #00d9cf; /*左边框颜色*/ &#125; &#125; &lt;/style&gt; 解决表格被等分文件 themes/next/source/css/_common/scaffolding/tables.styl 1table-layout: auto; 添加 Leancloud 统计今天发现网页访问很慢，查了之后发现不蒜子统计访问太慢，换成leancloud,但是只有pv统计。 参考文章 指定文章不在首页显示文件 /Users/march/Documents/hexoBlog/themes/next/layout/index.swig 修改。 123456789101112&lt;section id=&quot;posts&quot; class=&quot;posts-expand&quot;&gt; &#123;% for post in page.posts %&#125; &#123;%if !post.hide %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endif %&#125; &#123;% endfor %&#125;&lt;/section&gt;// render 之前判断&#123;%if !post.hide %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125;&#123;% endif %&#125; 然后在文章文件头部，增加 1234---...hide: true--- 网站背景/Users/march/Documents/hexoBlog/themes/next/source/css/_custom/custom.styl 123body&#123; background-image: url(/images/background.png);&#125; 头部显示/Users/march/Documents/hexoBlog/themes/next/source/css/_schemes/Mist/_header.styl 1.header &#123; background: $whitesmoke; &#125; 更改全局字体/Users/march/Documents/hexoBlog/themes/next/source/css/_variables/custom.styl 1234$font-size-base = 15.5px; // 默认是 16px 大小$font-family-headings = Georgia, sans // 标题，修改成你期望的字体族$font-family-base = &quot;Microsoft YaHei&quot;, Verdana, sans-serif // 修改成你期望的字体族 文章中加图片，首页不显示图片/Users/march/Documents/hexoBlog/themes/next/layout/_macro/post.swig 上面有个 gallery support，加上 not is_index 就可以不再首页显示，然后 md 文件顶部使用 photos 声明图片链接 photos: ‘./img.png’，可以多张 123456789101112131415&#123;% if not is_index and post.photos and post.photos.length %&#125; &lt;div class=&quot;post-gallery&quot; itemscope itemtype=&quot;http://schema.org/ImageGallery&quot;&gt; &#123;% set COLUMN_NUMBER = 3 %&#125; &#123;% for photo in post.photos %&#125; &#123;% if loop.index0 % COLUMN_NUMBER === 0 %&#125;&lt;div class=&quot;post-gallery-row&quot;&gt;&#123;% endif %&#125; &lt;a class=&quot;post-gallery-img fancybox&quot; href=&quot;&#123;&#123; url_for(photo) &#125;&#125;&quot; rel=&quot;gallery_&#123;&#123; post._id &#125;&#125;&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot; itemprop=&quot;url&quot;&gt; &lt;img src=&quot;&#123;&#123; url_for(photo) &#125;&#125;&quot; itemprop=&quot;contentUrl&quot;/&gt; &lt;/a&gt; &#123;% if loop.index0 % COLUMN_NUMBER === 2 %&#125;&lt;/div&gt;&#123;% endif %&#125; &#123;% endfor %&#125; &#123;# Append end tag for `post-gallery-row` when (photos size mod COLUMN_NUMBER) is less than COLUMN_NUMBER #&#125; &#123;% if post.photos.length % COLUMN_NUMBER &gt; 0 %&#125;&lt;/div&gt;&#123;% endif %&#125; &lt;/div&gt; &#123;% endif %&#125; 头像为圆形，可移动themes/next/source/css/_common/components/sidebar/sidebar-author.syl 123456789101112131415161718192021222324.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; // 修改头像边框 border-radius: 50%; -webkit-border-radius: 50%; -moz-border-radius: 50%; // 设置旋转 transition: 1.4s all;&#125;// 可旋转的圆形头像,`hover`动作.site-author-image:hover &#123; -webkit-transform: rotate(360deg); -moz-transform: rotate(360deg); -ms-transform: rotate(360deg); -transform: rotate(360deg);&#125; 主页文章添加卡片背景themes/next/source/css/_custom/custom.styl 12345678// 主页文章添加阴影效果.post&#123; margin-top: 0px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(180, 180, 180, .5); -moz-box-shadow: 0 0 5px rgba(180, 180, 180, .5);&#125; copyrightthemes/next/layout/_macro/post-copyright.swig 123&#123;&#123; __(&apos;post.copyright.license_content&apos;, theme.post_copyright.license_url, theme.post_copyright.license) &#125;&#125; 文章内链接themes/next/source/css/_custom/custom.styl 123456789101112131415// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; padding-left:5px; padding-right:5px; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; text-decoration: none; border-radius:0; &#125;&#125; 统一添加“本文结束”标记在路径 /themes/next/layout/_macro 中新建 passage-end-tag.swig 文件,并添加以下内容： 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #aaa;font-size:14px;margin-top:2rem;&quot;&gt;------ 本文结束 🎉🎉 谢谢观看 ------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 打开 themes/next/layout/_macro/post.swig 文件,添加： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125; &lt;/div&gt; 然后打开主题配置文件 _config.yml,在末尾添加： 123# 文章末尾添加“本文结束”标记passage_end_tag:enabled: true 键盘触发侧栏/Users/march/Documents/hexoBlog/themes/next/source/js/src/motion.js 123456789$(document).ready(function () &#123; NexT.motion = &#123;&#125;; window.onkeydown=function()&#123; if(13 == event.keyCode)&#123; NexT.utils.displaySidebar(); &#125; &#125;;&#125; 添加 live2d 看板娘添加一个小姐姐 https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md 1npm install --save hexo-helper-live2d hexo/_config.yml 1234567891011121314151617181920212223live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ model: use: live2d-widget-model-z16 scale: 1 hHeadPos: 1 vHeadPos: 1 display: superSample: 3 width: 60 height: 120 position: right hOffset: 120 vOffset: -40 mobile: show: false react: opacityDefault: 1 opacityOnHover: 1]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH 命令]]></title>
    <url>%2Farticle%2Ff225b262%2F</url>
    <content type="text"><![CDATA[命令行工具 SSH 命令记录 本地生成 ssh 密钥对，使用时本机存放 id_rsa，远端存放 id_rsa.pub 公钥 1ssh-keygen -t rsa -b 4096 -C 'email' 本地命令行信任 ssh，不用每次都输入密码 123ssh-agent bashssh-add id_rsa 连接远程服务 1ssh root@ip]]></content>
      <categories>
        <category>bash</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速实现Fragment切换功能]]></title>
    <url>%2Farticle%2F4099568815%2F</url>
    <content type="text"><![CDATA[一个app首页通常是使用Activity + Fragment的形式展示，控制Fragment的显示和隐藏基本有两种实现方法:&emsp;&emsp;1. ViewPager , 比如微信 , 优势是手势操作更加方便，官方提供了FragmentPagerAdapter可以很方便帮助我们实现数据加载（Fragment要使用懒加载的方式，避免浪费资源），劣势就是当你的第一个Fragment中已经使用了ViewPager，两层套一起事件会冲突，而且操作也不友好啦。&emsp;&emsp;2. FragmentManager , 比如头条，针对使用ViewPager组合Fragment的问题，使用FragmentManager控制Fragment的显示和隐藏，不需要考虑懒加载的问题，不过不能支持滑动啦。&emsp;&emsp;3. 本文主要是封装FragmentManager切换页面的相关操作。 设计思路设计一个管理类，负责 Fragment 的创建，显示，隐藏，回收等逻辑，想要进行 Framgnet 切换的界面，只需要创建这个管理类实现监听即可，从而将这些逻辑分离出来，达到复用的目的。 定义接口首先定义 FragmentOperator 接口，这个接口的目的是在完成 Framgent 切换之后能够告知所在的 Activity 作出相应响应操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061interface FragmentOperator &#123; /** * 获取放置fragment的控件id * * @return id */ int getFragmentContainerId(); /** * 构建fragment * * @param showItem 将要展示的fragment pos * @return fragment */ Fragment makeFragment(int showItem); /** * 进行转换之前做操作,实现该方法可以自定义fragment切换的动画效果等 * * @param transaction transaction */ void beginTransaction(FragmentTransaction transaction); /** * 切换成功之后会回调这个方法，同步选中之后的显示状态 * 比如改变按钮的颜色等操作 * * @param selectImage 被选中的item */ void syncSelectState(int showItem); /** * 当点击显示同一个，当两次切换到了同一个fragment，返回true时会进行此次切换 * * @param showItem 显示的item * @return 返回false表示忽略此次点击的切换 */ boolean whenShowSameFragment(int showItem); /** * 当点击显示的不是同一个，用于需要针对切换到某个fragment时的场景 * * @param showItem 显示的item * @return 返回false表示忽略此次点击的切换 */ boolean whenShowNotSameFragment(int showItem);&#125;// 上面的接口中不是所有的方法都是必须的，下面是一个简单的实现public static abstract class SimpleFragmentOperator implements FragmentOper @Override public boolean whenShowNotSameFragment(int showItem) &#123; return true; &#125; @Override public boolean whenShowSameFragment(int showItem) &#123; return false; &#125; @Override public void syncSelectState(int showItem) &#123; &#125; @Override public void beginTransaction(FragmentTransaction transaction) &#123; &#125;&#125; 核心方法使用 tag 作为标记添加 fragment ,避免重复创建 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465private static final String FRAGMENT_ATG = "FragmentHelper";private static final String ITEM_HIDE = "mHideItem";private static final String ITEM_SHOW = "mShowItem";private FragmentOperator operator;private Fragment mCurrentFragment;private FragmentManager mFragmentManager;private int mShowItem, mHideItem;private int mExactlyItem = 0; /** * 隐藏当前显示的fragment,显示将要显示的fragment * * @param hideItem 需要隐藏的fragment * @param showItem 需要显示的fragment * @param isOnCreate 是否是第一次从OnCreate中启动,点击都是false */private void performSelectItem(int hideItem, int showItem, boolean isOnCreate) &#123; // 获得将要显示页的tag String currentTag = getFragmentTag(hideItem); // 隐藏当前的的fragment FragmentTransaction transaction = mFragmentManager.beginTransaction(); operator.beginTransaction(transaction); // 第一次创建，一个都没有，不需要隐藏，直接显示 if (mFragmentManager.getFragments() == null) &#123; mShowItem = showItem; mExactlyItem = showItem; mCurrentFragment = operator.makeFragment(showItem); transaction.add(operator.getFragmentContainerId(), mCurrentFragment, getFragmentTag( .show(mCurrentFragment); &#125; else &#123; // 优化，如果被杀后再进来，全部的fragment都会被呈现显示状态，所以都隐藏一遍 if (isOnCreate &amp;&amp; mFragmentManager.getFragments() != null) &#123; for (Fragment fragment : mFragmentManager.getFragments()) &#123; transaction.hide(fragment); &#125; &#125; else &#123; // 正常按钮点击进入，隐藏上一个即可 Fragment lastFragment = mFragmentManager.findFragmentByTag(currentTag); if (lastFragment != null) &#123; transaction.hide(lastFragment); &#125; &#125; // 获得将要显示页的tag String toTag = getFragmentTag(showItem); // find要显示的Fragment mCurrentFragment = mFragmentManager.findFragmentByTag(toTag); if (mCurrentFragment != null) &#123; // 已经存在则显示 transaction.show(mCurrentFragment); &#125; else &#123; // 不存在则添加新的fragment mCurrentFragment = operator.makeFragment(showItem); if (mCurrentFragment != null) &#123; transaction.add(operator.getFragmentContainerId(), mCurrentFragment, toTag); &#125; &#125; &#125; // 同步状态 operator.syncSelectState(showItem); // 保存当前显示fragment的item mHideItem = hideItem; mShowItem = showItem; transaction.commitAllowingStateLoss();&#125; 显示 Fragment在 Activity 中使用时只需要调用 showFragment() 方法即可 123456789101112131415161718/** * 显示某个fragment * * @param showItem 显示的item */public void showFragment(int showItem) &#123; if (showItem == mShowItem) &#123; if (operator.whenShowSameFragment(showItem)) &#123; performSelectItem(mExactlyItem, showItem, false); mExactlyItem = showItem; &#125; &#125; else &#123; if (operator.whenShowNotSameFragment(showItem)) &#123; performSelectItem(mExactlyItem, showItem, false); mExactlyItem = showItem; &#125; &#125;&#125; 优化当 Activity 被回收时，记录上次的状态 123456789101112131415161718192021222324252627282930313233343536// 保存数据// FragmentHelperpublic void onCreate(Bundle save) &#123; if (save != null) &#123; mHideItem = save.getInt(ITEM_HIDE, 0); mShowItem = save.getInt(ITEM_SHOW, 0); performSelectItem(mHideItem, mShowItem, true); &#125;&#125;// 在Activity销毁时调用@Overrideprotected void onSaveInstanceState(Bundle outState) &#123; super.onSaveInstanceState(outState); if (mFragmentHelper != null) &#123; mFragmentHelper.onSaveInstanceState(outState); &#125;&#125;// 重新加载// FragmentHelperpublic void onCreate(Bundle save) &#123; if (save != null) &#123; mHideItem = save.getInt(ITEM_HIDE, 0); mShowItem = save.getInt(ITEM_SHOW, 0); performSelectItem(mHideItem, mShowItem, true); &#125;&#125;// 在Activity创建时调用@Overridepublic void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mFragmentHelper = new FragmentHelper(getSupportFragmentManager(), mSimpleOperator); mFragmentHelper.onCreate(savedInstanceState);&#125; 使用123456789101112131415161718192021222324252627282930313233343536373839404142public class TestMultiFragmentActivity2 extends BaseActivity &#123; private FragmentHelper mFragmentHelper; private FragmentHelper.SimpleFragmentOperator mSimpleOperator; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mSimpleOperator = new FragmentHelper.SimpleFragmentOperator() &#123; @Override public int getFragmentContainerId() &#123; return 0; &#125; @Override public Fragment makeFragment(int showItem) &#123; return null; &#125; @Override public void syncSelectState(int showItem) &#123; &#125; &#125;; mFragmentHelper = new FragmentHelper(getSupportFragmentManager(), mSimpleOperator); // 只有销毁后回来才会调起切换操作否则没反应 mFragmentHelper.onCreate(savedInstanceState); &#125; @Override protected void onSaveInstanceState(Bundle outState) &#123; super.onSaveInstanceState(outState); if (mFragmentHelper != null) &#123; mFragmentHelper.onSaveInstanceState(outState); &#125; &#125; @Override protected int getLayoutId() &#123; return 0; &#125;&#125; 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206/** * CreateAt : 2016/11/5 * Describe : 实现Fragment切换 * * @author chendong */public class FragmentHelper &#123; private static final String FRAGMENT_ATG = "FragmentHelper"; private static final String ITEM_HIDE = "mHideItem"; private static final String ITEM_SHOW = "mShowItem"; private FragmentOperator operator; private Fragment mCurrentFragment; private FragmentManager mFragmentManager; private int mShowItem, mHideItem; private int mExactlyItem = 0; public void onCreate(Bundle save) &#123; if (save != null) &#123; mHideItem = save.getInt(ITEM_HIDE, 0); mShowItem = save.getInt(ITEM_SHOW, 0); performSelectItem(mHideItem, mShowItem, true); &#125; &#125; public void onSaveInstanceState(Bundle outState) &#123; outState.putInt(ITEM_HIDE, mHideItem); outState.putInt(ITEM_SHOW, mShowItem); &#125; public FragmentHelper(FragmentManager mFragmentManager, FragmentOperator operator) &#123; this.mFragmentManager = mFragmentManager; this.mFragmentManager = mFragmentManager; this.operator = operator; &#125; /** * 显示某个fragment * * @param showItem 显示的item */ public void showFragment(int showItem) &#123; if (showItem == mShowItem) &#123; if (operator.whenShowSameFragment(showItem)) &#123; performSelectItem(mExactlyItem, showItem, false); mExactlyItem = showItem; &#125; &#125; else &#123; if (operator.whenShowNotSameFragment(showItem)) &#123; performSelectItem(mExactlyItem, showItem, false); mExactlyItem = showItem; &#125; &#125; &#125; /** * 获取当前处于活动状态的fragment' * * @return fragment */ public Fragment getCurrentFragment() &#123; return mCurrentFragment; &#125; /** * 隐藏当前显示的fragment,显示将要显示的fragment * * @param hideItem 需要隐藏的fragment * @param showItem 需要显示的fragment * @param isOnCreate 是否是第一次从OnCreate中启动,点击都是false */ private void performSelectItem(int hideItem, int showItem, boolean isOnCreate) &#123; // 获得将要显示页的tag String currentTag = getFragmentTag(hideItem); // 隐藏当前的的fragment FragmentTransaction transaction = mFragmentManager.beginTransaction(); operator.beginTransaction(transaction); // 第一次创建，一个都没有，不需要隐藏，直接显示 if (mFragmentManager.getFragments() == null) &#123; mShowItem = showItem; mExactlyItem = showItem; mCurrentFragment = operator.makeFragment(showItem); transaction.add(operator.getFragmentContainerId(), mCurrentFragment, getFragmentTag(showItem)) .show(mCurrentFragment); &#125; else &#123; // 优化，如果被杀后再进来，全部的fragment都会被呈现显示状态，所以都隐藏一遍 if (isOnCreate &amp;&amp; mFragmentManager.getFragments() != null) &#123; for (Fragment fragment : mFragmentManager.getFragments()) &#123; transaction.hide(fragment); &#125; &#125; else &#123; // 正常按钮点击进入，隐藏上一个即可 Fragment lastFragment = mFragmentManager.findFragmentByTag(currentTag); if (lastFragment != null) &#123; transaction.hide(lastFragment); &#125; &#125; // 获得将要显示页的tag String toTag = getFragmentTag(showItem); // find要显示的Fragment mCurrentFragment = mFragmentManager.findFragmentByTag(toTag); if (mCurrentFragment != null) &#123; // 已经存在则显示 transaction.show(mCurrentFragment); &#125; else &#123; // 不存在则添加新的fragment mCurrentFragment = operator.makeFragment(showItem); if (mCurrentFragment != null) &#123; transaction.add(operator.getFragmentContainerId(), mCurrentFragment, toTag); &#125; &#125; &#125; // 同步状态 operator.syncSelectState(showItem); // 保存当前显示fragment的item mHideItem = hideItem; mShowItem = showItem; transaction.commitAllowingStateLoss(); &#125; private String getFragmentTag(int item) &#123; return FRAGMENT_ATG + item; &#125; interface FragmentOperator &#123; /** * 获取放置fragment的控件id * * @return id */ int getFragmentContainerId(); /** * 构建fragment * * @param showItem 将要展示的fragment pos * @return fragment */ Fragment makeFragment(int showItem); /** * 进行转换之前做操作,实现该方法可以自定义fragment切换的动画效果等 * * @param transaction transaction */ void beginTransaction(FragmentTransaction transaction); /** * 切换成功之后会回调这个方法，同步选中之后的显示状态 * 比如改变按钮的颜色等操作 * * @param showItem 被选中的item */ void syncSelectState(int showItem); /** * 当点击显示同一个，当两次切换到了同一个fragment，返回true时会进行此次切换 * * @param showItem 显示的item * @return 返回false表示忽略此次点击的切换 */ boolean whenShowSameFragment(int showItem); /** * 当点击显示的不是同一个，用于需要针对切换到某个fragment时的场景 * * @param showItem 显示的item * @return 返回false表示忽略此次点击的切换 */ boolean whenShowNotSameFragment(int showItem); &#125; // 上面的接口中不是所有的方法都是必须的，下面是一个简单的实现 public static abstract class SimpleFragmentOperator implements FragmentOperator &#123; @Override public boolean whenShowNotSameFragment(int showItem) &#123; return true; &#125; @Override public boolean whenShowSameFragment(int showItem) &#123; return false; &#125; @Override public void syncSelectState(int showItem) &#123; &#125; @Override public void beginTransaction(FragmentTransaction transaction) &#123; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AndroidTips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EditText]]></title>
    <url>%2Farticle%2F2515477621%2F</url>
    <content type="text"><![CDATA[EditText 是 TextView 的子类，用于进行文字输入等操作，是开发中特别常用的一个控件了，本文主要介绍： 更改EditText的背景 设置监听事件 给EditText设置具有带图片的Hint 监听事件监听焦点变化 123456etInput.setOnFocusChangeListener(new OnFocusChangeListener() &#123; @Override public void onFocusChange(View v, boolean hasFocus) &#123; // hasFocus 当前是否获得焦点 &#125;&#125;); 文本输入监听事件 1234567891011121314etInput.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; // 文本输入之前回调 &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; // 输入过程中会频繁回调 &#125; @Override public void afterTextChanged(Editable s) &#123; // 输入结束回调 &#125;&#125;); 自定义EditText背景如下图所示，当离开当前EditText时，检查输入是否有问题，输入错误会显示红色 定义背景drawable文件 其他形态的背景也相对简单，只有一条线的这种背景drawable写起来还是需要研究一下的，直接上代码啦,主要是用了一个selector -&gt; layer-list -&gt; shape,在select属性改变时，改变线条的颜色。原本是一个矩形，然后将另外三个边偏移一下，只留下底边，达到线条显示的效果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_selected="true"&gt; &lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item&gt; &lt;shape android:shape="rectangle"&gt; &lt;solid android:color="@android:color/transparent" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:left="-2dip" android:right="-2dip" android:top="-2dip"&gt; &lt;shape&gt; &lt;solid android:color="@android:color/transparent" /&gt; &lt;stroke android:width="1dip" android:color="@color/red" android:dashGap="0dp" android:dashWidth="0dip" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; &lt;/item&gt; &lt;item&gt; &lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item&gt; &lt;shape android:shape="rectangle"&gt; &lt;solid android:color="@android:color/transparent" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:left="-2dip" android:right="-2dip" android:top="-2dip"&gt; &lt;shape&gt; &lt;solid android:color="@android:color/transparent" /&gt; &lt;stroke android:width="1dip" android:color="@color/colorPrimary" android:dashGap="0dp" android:dashWidth="0dip" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; &lt;/item&gt;&lt;/selector&gt; 带图片的Hint如下图所示，实现带有图片的hint，使用 SpannableString实现 ，但是开始的效果不是很理想，图片不能很好的居中，使用重写ImageSpan的方法解决了这个问题 图片垂直居中的span1234567891011121314151617181920212223242526272829303132333435class VerticalCenterImageSpan extends ImageSpan &#123; VerticalCenterImageSpan(Drawable drawable) &#123; super(drawable); &#125; public int getSize(Paint paint, CharSequence text, int start, int end, Paint.FontMetricsInt fontMetricsInt) &#123; Drawable drawable = getDrawable(); Rect rect = drawable.getBounds(); if (fontMetricsInt != null) &#123; Paint.FontMetricsInt fmPaint = paint.getFontMetricsInt(); int fontHeight = fmPaint.bottom - fmPaint.top;// 计算文字的高度 int drHeight = rect.bottom - rect.top;// 计算图片的高度 int top = drHeight / 2 - fontHeight / 4; int bottom = drHeight / 2 + fontHeight / 4; fontMetricsInt.ascent = -bottom; fontMetricsInt.top = -bottom; fontMetricsInt.bottom = top; fontMetricsInt.descent = top; &#125; return rect.right; &#125; @Override public void draw(Canvas canvas, CharSequence text, int start, int end, float x, int top, int y, int bottom, Paint paint) &#123; Drawable drawable = getDrawable(); canvas.save(); int transY; transY = ((bottom - top) - drawable.getBounds().bottom) / 2 + top; canvas.translate(x, transY); drawable.draw(canvas); canvas.restore(); &#125; &#125; 设置hint123456789// 设置图文hint private void initEditText(EditText editText) &#123; SpannableString msp = new SpannableString("图片 写点什么吧..."); Drawable drawable = ContextCompat.getDrawable(getContext(), R.drawable.icon_hint_edit); drawable.setBounds(0, 0, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight()); // 这里从start = 0开始，end = 2结束，图片取代了两个字的位置，上面的字符串中国年的图片两个字会被替代 msp.setSpan(new VerticalCenterImageSpan(drawable), 0, 2, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); editText.setHint(msp); &#125; 修改键盘的回车键在xml配置 12android:imeOptions="actionSearch"android:inputType="text" 或在java代码中配置 12editText.setImeOptions(EditorInfo.IME_ACTION_SEARCH);editText.setInputType(EditorInfo.TYPE_CLASS_TEXT); 实现监听，进行相关操作 12345678910editText.setOnEditorActionListener(new TextView.OnEditorActionListener() &#123; public boolean onEditorAction(TextView v, int actionId, KeyEvent event) &#123; if (actionId == EditorInfo.IME_ACTION_SEND || (event != null &amp;&amp; event.getKeyCode() == KeyEvent.KEYCODE_ENTER)) &#123; //do something; return true; &#125; return false; &#125;&#125;);]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端与服务器token机制]]></title>
    <url>%2Farticle%2F1482489498%2F</url>
    <content type="text"><![CDATA[移动端与服务器token机制]]></content>
      <categories>
        <category>Android</category>
        <category>todo</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义控件-仿QQ相册滑动选中]]></title>
    <url>%2Farticle%2F3936083469%2F</url>
    <content type="text"><![CDATA[显示相册在app中是一个比较常见的操作，大致的操作就是通过ContentProvider获取多媒体资源进行展示，我综合了一下QQ 的和微信的显示效果，实现了一下,仿微信QQ显示手机相册，在QQ的相册选择时是支持滑动选中的，即手指碰到哪个就选中哪张照片，正好公司的项目中用到了这个功能，在网上找了找没有很好的解决方案，所以通过自定义控件处理事件，这篇文章主要介绍这个功能的实现。 自定义控件SlidingSelectLayout的源代码点击这里获取 大体思路自定义控件将会作为 RecyclerView 的父控件，这样使他可以优先于RecyclerView 捕捉事件 当手指竖向滑动时，父控件不作处理，RecyclerView处理事件，进行滑动。当手指横向滑动达到阈值时自定义父控件会截断事件自己进行进行处理。 根据手指的滑动MotionEvent获取x,y坐标，使用RecycelrView的findViewUnder(float x,float y) 的方法，可以直接获取制定位置的View，再使用tag从view中拿到之前使用mScl.markView()方法绑定的pos和data数据 使用该方法就不会因为动态计算距离而局限于RecyclerView的布局，九宫格模式下仍然可以很好的支持。 初始化参数在处理事件获取手指滑动的位置时，需要使用RecyclerView的LayoutManager等，为了尽量对外简化使用的流程，在控件内部使用遍历子控件的方式来获取RecyclerView和GridLayoutManager的列数等参数，初始化一些值。 获取 RecyclerView 1234567891011121314151617181920212223242526/** * 获取RecyclerView */private void ensureTarget() &#123; if (mTargetRv != null) return; View findView = searchInViewGroup(this); if (findView == null) &#123; Logger.e(TAG, "can not find RecyclerView"); &#125; else &#123; mTargetRv = (RecyclerView) findView; &#125;&#125;private View searchInViewGroup(ViewGroup viewGroup) &#123; View rstView = null; for (int i = 0; i &lt; viewGroup.getChildCount(); i++) &#123; View childAt = viewGroup.getChildAt(i); if (childAt instanceof RecyclerView) &#123; rstView = childAt; &#125; else if (childAt instanceof ViewGroup) &#123; rstView = searchInViewGroup((ViewGroup) childAt); &#125; &#125; return rstView;&#125; 处理LayoutManager，初始化xTouchSlop，这个值是滑动多大距离触发水平滑动，根据GridLayoutManager的列数来动态设置。 12345678910111213141516private void ensureLayoutManager() &#123; if (mTargetRv == null || itemSpanCount != INVALID_PARAM) return; RecyclerView.LayoutManager lm = mTargetRv.getLayoutManager(); if (lm == null) return; if (lm instanceof GridLayoutManager) &#123; GridLayoutManager glm = (GridLayoutManager) lm; itemSpanCount = glm.getSpanCount(); &#125; else &#123; Logger.e(TAG,"暂时不支持其他布局类型，请使用GridLayoutManager"); itemSpanCount = 4; &#125; int size = (int) (getResources().getDisplayMetrics().widthPixels / (itemSpanCount * 1.0f)); xTouchSlop = yTouchSlop = size * TOUCH_SLOP_RATE;&#125; 拦截事件12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 如果RecyclerView没有获取到，不进行事件的拦截private boolean isReadyToIntercept() &#123; return mTargetRv != null &amp;&amp; mTargetRv.getAdapter() != null &amp;&amp; itemSpanCount != INVALID_PARAM;&#125;@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; if (!isEnabled()) return super.onInterceptTouchEvent(ev); // 不支持多点触摸 int pointerCount = ev.getPointerCount(); if (pointerCount &gt; 1) &#123; return super.onInterceptTouchEvent(ev); &#125; // 获取RecyclerView ensureTarget(); // 初始化参数 ensureLayoutManager(); if (!isReadyToIntercept()) return super.onInterceptTouchEvent(ev); int action = MotionEventCompat.getActionMasked(ev); switch (action) &#123; case MotionEvent.ACTION_DOWN: // init mInitialDownX = ev.getX(); mInitialDownY = ev.getY(); break; case MotionEvent.ACTION_UP: // stop isBeingSlide = false; break; case MotionEvent.ACTION_MOVE: // handle float xDiff = Math.abs(ev.getX() - mInitialDownX); float yDiff = Math.abs(ev.getY() - mInitialDownY); if (yDiff &lt; yTouchSlop &amp;&amp; xDiff &gt; xTouchSlop) &#123; isBeingSlide = true; &#125; break; &#125; return isBeingSlide;&#125; 触摸事件处理Touch事件123456789101112131415161718@Overridepublic boolean onTouchEvent(MotionEvent ev) &#123; int action = MotionEventCompat.getActionMasked(ev); switch (action) &#123; case MotionEvent.ACTION_DOWN: break; case MotionEvent.ACTION_UP: // re init 手指抬起时重置 isBeingSlide = false; preViewPos = INVALID_PARAM; break; case MotionEvent.ACTION_MOVE: // 滑动过程中，触发监听事件 publishSlidingCheck(ev); break; &#125; return isBeingSlide;&#125; 获取数据123456789101112131415// 从View中使用getTag(int key)获取tag，也就是之前在onBindViewHolder中设置的数据// 从Tag中获取posprivate int getPos(View parentView) &#123; int pos = INVALID_PARAM; Object tag = parentView.getTag(tagPosKey); if (tag != null) pos = (int) tag; return pos; &#125; // 从tag中获取dataprivate Object getData(View parentView) &#123; return parentView.getTag(tagDataKey);&#125; 触发监听使用监听向外发布事件,将获取的pos和data通过监听发布 12345678910111213141516171819202122232425/** * 发布结果 * * @param event 事件 */private void publishSlidingCheck(MotionEvent event) &#123; float x = generateX(event.getX()); float y = generateY(event.getY()); View childViewUnder = mTargetRv.findChildViewUnder(x, y); // fast stop if (onSlidingSelectListener == null || childViewUnder == null) return; int pos = getPos(childViewUnder); Object data = getData(childViewUnder); // fast stop 当前触摸的点与上一次触摸的点相同 || 没有pos || 没有数据 if (preViewPos == pos || pos == INVALID_PARAM || data == null) return; try &#123; // 这里使用范型强制转换 onSlidingSelectListener.onSlidingSelect(pos, childViewUnder, data); preViewPos = pos; &#125; catch (ClassCastException e) &#123; Log.e("SlidingSelect", "ClassCastException:填写的范型有误，无法转换"); &#125;&#125; 效果演示普通模式演示视频 九宫格模式演示视频 使用xml 中使用1234567891011&lt;com.march.slidingselect.SlidingSelectLayout android:id="@+id/scl" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/recyclerview" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; &lt;/com.march.slidingselect.SlidingSelectLayout&gt; java 代码中配置在Adapter的onBindViewHolder方法中将pos和data与view进行绑定，之所以这样做是为了可以在手指划过Item时将对应的数据和位置通过监听发送回来。 123456789private SlidingSelectLayout mScl;mScl = getView(R.id.scl);class MyAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;&#123; @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) &#123; mScl.markView(holder.itemView,position,demos.get(position)); &#125;&#125; 监听回调使用范型获得手指触摸到的位置和当前位置对应的数据进行更新adapter 1234567mScl.setOnSlidingSelectListener(new SlidingSelectLayout.OnSlidingSelectListener&lt;Demo&gt;() &#123; @Override public void onSlidingSelect(int pos, View parentView, Demo data) &#123; demos.get(pos).isChanged = !demos.get(pos).isChanged; adapter.notifyItemChanged(pos); &#125; &#125;); 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251package com.march.dev.widget;import android.content.Context;import android.support.v4.view.MotionEventCompat;import android.support.v7.widget.GridLayoutManager;import android.support.v7.widget.RecyclerView;import android.util.AttributeSet;import android.util.Log;import android.view.MotionEvent;import android.view.View;import android.view.ViewGroup;import android.widget.FrameLayout;import com.march.dev.R;import com.march.dev.helper.Logger;/** * Project : CommonLib * Package : com.march.lib.view * CreateAt : 2016/9/12 * Describe : 滑动选中 * * @author chendong */public class SlidingSelectLayout extends FrameLayout &#123; public static final String TAG = SlidingSelectLayout.class.getSimpleName(); private static final float TOUCH_SLOP_RATE = 0.15f;// 初始化值 private static final int INVALID_PARAM = -1; public SlidingSelectLayout(Context context) &#123; this(context, null); &#125; public SlidingSelectLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); setTagKey(R.id.sliding_pos, R.id.sliding_data); itemSpanCount = INVALID_PARAM; preViewPos = INVALID_PARAM; &#125; private RecyclerView mTargetRv;// 内部的rv private int offsetTop; private float xTouchSlop;// 横轴滑动阈值，超过阈值表示触发横轴滑动 private float yTouchSlop;// 纵轴滑动阈值，超过阈值表示触发纵轴滑动 private int itemSpanCount;// 横向的item数量 private float mInitialDownX;// down 事件初始值 private float mInitialDownY;// down 事件初始值 private boolean isBeingSlide;// 是否正在滑动 private int tagPosKey; private int tagDataKey; private int preViewPos; private OnSlidingSelectListener onSlidingSelectListener;// 滑动选中监听 @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; if (!isEnabled()) return super.onInterceptTouchEvent(ev); // 不支持多点触摸 int pointerCount = ev.getPointerCount(); if (pointerCount &gt; 1) &#123; return super.onInterceptTouchEvent(ev); &#125; // 获取RecyclerView ensureTarget(); // 初始化参数 ensureLayoutManager(); if (!isReadyToIntercept()) return super.onInterceptTouchEvent(ev); int action = MotionEventCompat.getActionMasked(ev); switch (action) &#123; case MotionEvent.ACTION_DOWN: // init mInitialDownX = ev.getX(); mInitialDownY = ev.getY(); break; case MotionEvent.ACTION_UP: // stop isBeingSlide = false; break; case MotionEvent.ACTION_MOVE: // handle float xDiff = Math.abs(ev.getX() - mInitialDownX); float yDiff = Math.abs(ev.getY() - mInitialDownY); if (yDiff &lt; yTouchSlop &amp;&amp; xDiff &gt; xTouchSlop) &#123; isBeingSlide = true; &#125; break; &#125; return isBeingSlide; &#125; private float generateX(float x) &#123; return x; &#125; private float generateY(float y) &#123; return y - offsetTop; &#125; private void setTargetRv(RecyclerView mTargetRv) &#123; this.mTargetRv = mTargetRv; &#125; @Override public boolean onTouchEvent(MotionEvent ev) &#123; int action = MotionEventCompat.getActionMasked(ev); switch (action) &#123; case MotionEvent.ACTION_DOWN: break; case MotionEvent.ACTION_UP: // re init 手指抬起时重置 isBeingSlide = false; preViewPos = INVALID_PARAM; break; case MotionEvent.ACTION_MOVE: // 滑动过程中，触发监听事件 publishSlidingCheck(ev); break; &#125; return isBeingSlide; &#125; /** * 初始化参数 */ private void ensureLayoutManager() &#123; if (mTargetRv == null || itemSpanCount != INVALID_PARAM) return; RecyclerView.LayoutManager lm = mTargetRv.getLayoutManager(); if (lm == null) return; if (lm instanceof GridLayoutManager) &#123; GridLayoutManager glm = (GridLayoutManager) lm; itemSpanCount = glm.getSpanCount(); &#125; else &#123; Logger.e(TAG, "暂时不支持其他布局类型，请使用GridLayoutManager"); itemSpanCount = 4; &#125; int size = (int) (getResources().getDisplayMetrics().widthPixels / (itemSpanCount * 1.0f)); xTouchSlop = yTouchSlop = size * TOUCH_SLOP_RATE; &#125; /** * 发布结果 * * @param event 事件 */ private void publishSlidingCheck(MotionEvent event) &#123; float x = generateX(event.getX()); float y = generateY(event.getY()); View childViewUnder = mTargetRv.findChildViewUnder(x, y); // fast stop if (onSlidingSelectListener == null || childViewUnder == null) return; int pos = getPos(childViewUnder); Object data = getData(childViewUnder); // fast stop 当前触摸的点与上一次触摸的点相同 || 没有pos || 没有数据 if (preViewPos == pos || pos == INVALID_PARAM || data == null) return; try &#123; // 这里使用范型强制转换 onSlidingSelectListener.onSlidingSelect(pos, childViewUnder, data); preViewPos = pos; &#125; catch (ClassCastException e) &#123; Log.e("SlidingSelect", "ClassCastException:填写的范型有误，无法转换"); &#125; &#125; private void setTagKey(int tagPosKey, int tagDataKey) &#123; this.tagPosKey = tagPosKey; this.tagDataKey = tagDataKey; &#125; /** * 设置pos和data作为View的tag * @param parentView * @param pos * @param data */ public void markView(View parentView, int pos, Object data) &#123; parentView.setTag(tagPosKey, pos); parentView.setTag(tagDataKey, data); &#125; private int getPos(View parentView) &#123; int pos = INVALID_PARAM; Object tag = parentView.getTag(tagPosKey); if (tag != null) pos = (int) tag; return pos; &#125; private Object getData(View parentView) &#123; return parentView.getTag(tagDataKey); &#125; /** * 是否可以开始拦截处理事件，当recyclerView数据完全ok之后开始 * * @return 是否可以开始拦截处理事件 */ private boolean isReadyToIntercept() &#123; return mTargetRv != null &amp;&amp; mTargetRv.getAdapter() != null &amp;&amp; itemSpanCount != INVALID_PARAM; &#125; /** * 获取RecyclerView */ private void ensureTarget() &#123; if (mTargetRv != null) return; View findView = searchInViewGroup(this); if (findView == null) &#123; Logger.e(TAG, "can not find RecyclerView"); &#125; else &#123; mTargetRv = (RecyclerView) findView; &#125; &#125; private View searchInViewGroup(ViewGroup viewGroup) &#123; View rstView = null; for (int i = 0; i &lt; viewGroup.getChildCount(); i++) &#123; View childAt = viewGroup.getChildAt(i); if (childAt instanceof RecyclerView) &#123; rstView = childAt; &#125; else if (childAt instanceof ViewGroup) &#123; rstView = searchInViewGroup((ViewGroup) childAt); &#125; &#125; return rstView; &#125; public void setOffsetTop(int offsetTop) &#123; this.offsetTop = offsetTop; &#125; public &lt;D&gt; void setOnSlidingSelectListener(OnSlidingSelectListener&lt;D&gt; onSlidingCheckListener) &#123; this.onSlidingSelectListener = onSlidingCheckListener; &#125; public interface OnSlidingSelectListener&lt;D&gt; &#123; void onSlidingSelect(int pos, View parentView, D data); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NestedScrolling交互]]></title>
    <url>%2Farticle%2F2940188893%2F</url>
    <content type="text"><![CDATA[前言交互 触发时机 NestedScrollChild NestedScrollParent Down startNestScroll onStartNestScroll onNestScrollAccept Move dispatchNestPreScroll onNestPreScroll dispatchNestScroll onNestScroll Up stopNest]]></content>
      <categories>
        <category>Android</category>
        <category>todo</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分析SwipeRefreshLayout实现自定义刷新]]></title>
    <url>%2Farticle%2F308486771%2F</url>
    <content type="text"><![CDATA[前言 分析SwipeRefreshLayout的源代码来深入的理解一下关于刷新的事件处理和NestedScrolling机制的使用。Android5.0之后官方推出了SwipeRefreshLayout来实现下拉刷新，当然还有很多其他控件，因为像下拉刷新，抽屉效果，tabLayout效果几乎是每个App都需要的，在之前的版本中Android没有定义这些控件，因此GitHub上也涌现了大量的自定控件的库，大家可以很方便的引用这些库实现效果，比如很火的pull-to-refresh以及后来的ultra-pull-to-refresh。Android在推出SwipeRefreshLayout之后并没有在国内得到很好的使用，大家还是在用自己的刷新和开源库来实现。可能是因为： SwipeRefreshLayout的效果跟以前的刷新效果有些出入，大家接受了以前的效果对新的效果不太满意。 SwipeRefreshLayout自定义度不强，每个App都想有自己的特色，自然不愿意采用大众的做法。 这篇文章的目的就是，理解SwipeRefreshLayout 的实现，基于SwipeRefreshLayout实现类似传统的刷新效果并支持自定义。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SourceCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android事件交互]]></title>
    <url>%2Farticle%2F3766638624%2F</url>
    <content type="text"><![CDATA[Android事件交互,当用户手指触碰屏幕时会触发onTouchEvent(MotionEven event)方法。 推荐阅读简书－MotionEvent详解 事件分发事件分发的 U 型结构，事件先从上往下分发，到达最底层后，从下向上处理，当然中间还有截断事件等流程。 几个点： 只有 ViewGroup 具有 onInterceptTOuchEvent() 方法，用来截断事件的传递，当事件的传递被截断时，当前 ViewGroup 处理事件。 Activity 和 ViewGroup 具有 dispatchTouchEvent() 方法，用来分发事件，如果返回 false，意为不分发，上层将会处理事件。 onTouchEvent() 返回 true 表示当前控件处理事件，事件将不会继续向上传递，否则继续往上走。 如果当 ACTION_DOWN 时返回 false，就不能接收到其他事件。 常用事件1234567MotionEvent.ACTION_DOWN: 0MotionEvent.ACTION_UP: 1MotionEvent.ACTION_MOVE: 2MotionEvent.ACTION_CANCEL: 3MotionEvent.ACTION_OUTSIDE: 4MotionEvent.ACTION_POINTER_DOWN: 5MotionEvent.ACTION_POINTER_UP: 6 获取事件 event.getAction()和event.getActionMasked()和MotionEventCompat.getActionMasked(event)都可以获取事件类型。带有Mask标志的方法是针对多点触控的情况拿到的掩码。多点触控时，获取Action会返回每个触摸点的事件，其中使用pointerIndex区分每个触摸点。 为了能表示每个pointerIndex对应的事件，以及更方便转化，每个获取的action实际上是pointerIndex和event拼接成的16进制表示，比如第二个点的Move事件，返回的值是0x0100,01表示pointerIndex,00表示Down事件，所以返回的action的值为256. 单点触摸时只有一个pointerIndex = 0,所以获取的到的action实际上是0x0000(Down事件)，0x0001(UP事件)。。。所以结果和事件的值是一样的。 当多点触摸时，第一个点的Down事件0x0000,第二个点的Down事件0x0100,此时简单的getAction()方法并不能获取正确的事件值。 getActionMasked()方法是将getAction()的值与ACTION_MASK做‘与’运算，例如当有一个事件是0x0102,获取掩码时可以过滤掉pointerIndex的值获取event的值，event.getActionMasked()原理大致相同。 描述 值 getAction()十六进制表示 0x0101 ACTION_MASK十六进制表示 0x00ff getAction()二进制表示 000001 000001 ACTION_MASK二进制表示 000000 011111 getActionMasked()二进制表示 000000 000001 getActionMasked()十六进制表示 0x0001(Move事件) 1234public static final int ACTION_MASK = 0xff;public static int getActionMasked(MotionEvent event) &#123; return event.getAction() &amp; ACTION_MASK;&#125; MotionEventCompat.getActionMasked()是对版本兼容的方法。推荐使用这个类进行相关操作达到兼容版本的目的。 Pointer pointer , pointerIndex , event , action , poiterId pointer代表一个触摸点 pointerIndex是pointer在MotionEvent中的索引 event代表事件，比如0(Down),1(UP)… action是pointerIndex和event拼接的十六进制形式 pointerId是一个pointer的唯一标示，他在整个事件流中是不会改变的，但是pointerIndex的值会改变，比如，先后放置三个指头在屏幕上会接收到0x0000(第一个指头Down事件),0x0105(第二个指头Pointer_Down事件),0x0205(第三个指头Pointer_Down事件),抬起第二个指头时会触发0x0106(Pointer_Up),再抬起第三个指头也会触发0x0106(Pointer_Up),也就是说抬起第二个指头之后第三个指头的index由02变成了01,所以index只是MotionEvnet中每个事件的下标，与事件不能形成标志性的关系。 MotionEventCompat MotionEventCompat是一个针对事件处理提供的辅助类，内部做了版本兼容。 getActionIndex(MotionEvent event)获取该事件的索引，有点类似于MotionEventCompat.getActionMasked(),都使用‘与’运算，只不过一个取的是高位的pointerIndex,后者取得是低位的event事件。 1234public static int getActionIndex(MotionEvent event) &#123; return (event.getAction() &amp; ACTION_POINTER_INDEX_MASK) &gt;&gt; ACTION_POINTER_INDEX_SHIFT; &#125; getPointerId(MotionEvent event, int pointerIndex)在一个MotionEvent中根据触摸点pointerIndex的值获取pointerId 123public static int getPointerId(MotionEvent event, int pointerIndex) &#123; return IMPL.getPointerId(event, pointerIndex);&#125; findPointerIndex(MotionEvent event, int pointerId)在一个MotionEvent中根据pointerId获取pointerIndex 123public static int findPointerIndex(MotionEvent event, int pointerId) &#123; return IMPL.findPointerIndex(event, pointerId);&#125; 从一个MotionEvent中根据pointerIndex获取对应触摸点的XY坐标 123456public static float getX(MotionEvent event, int pointerIndex) &#123; return IMPL.getX(event, pointerIndex);&#125;public static float getY(MotionEvent event, int pointerIndex) &#123; return IMPL.getY(event, pointerIndex);&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NestedScrollingParent分析]]></title>
    <url>%2Farticle%2F1655050953%2F</url>
    <content type="text"><![CDATA[前言 对NestedScrollingParent接口进行分析，主要是文档的翻译和一些理解，以及每个方法触发的时机。 NestedScrollingParent接口 This interface should be implemented by {@link android.view.ViewGroup ViewGroup} subclassesthat wish to support scrolling operations delegated by a nested child view. 翻译：这个接口被ViewGroup的子类实现来支持处理nest子视图的滑动操作。 Classes implementing this interface should create a final instance of a {@link NestedScrollingParentHelper} as a field and delegate any View or ViewGroup methodsto the NestedScrollingParentHelper methods of the same signature. 翻译：实现这个接口的类应该创建一个final类型的NestedScrollingParentHelper实例作为一个属性，来代理NestedScrollingParent中与NestedScrollingParentHelper具有相同方法名字的操作。 Views invoking nested scrolling functionality should always do so from the relevant {@link ViewCompat}, {@link ViewGroupCompat} or {@link ViewParentCompat} compatibility shim static methods. This ensures interoperability with nested scrolling views on Android 5.0 Lollipop and newer. 翻译：View调用嵌套滑动的相关功能时应该从相关的ViewCompat，ViewGroupCompat，ViewParentCompat调用兼容的静态方法，这保证了在5.0或者更新版本中与嵌套滑动的互用性。 onStartNestedScroll方法1public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes); 参数和返回值 12345678//ViewParent包涵的直接的子View@param child Direct child of this ViewParent containing target //启动嵌套滑动操作的View@param target View that initiated the nested scroll //flag垂直滑动还是水平滑动@param nestedScrollAxes Flags consisting of &#123;@link ViewCompat#SCROLL_AXIS_HORIZONTAL&#125;, &#123;@link ViewCompat#SCROLL_AXIS_VERTICAL&#125; or both //如果返回true代表父View接受消耗这个滑动操作。@return true if this ViewParent accepts the nested scroll operation React to a descendant view initiating a nestable scroll operation, claiming the nested scroll operation if appropriate. 翻译：对一个派生View的嵌套滑动操作作出反应，如果需要的话将会拦截（消耗）这个滑动操作。 This method will be called in response to a descendant view invoking ink ViewCompat#startNestedScroll(View, int)}. Each parent up the view hierarchy will be given an opportunity to respond and claim the nested scrolling operation by returning true. 翻译：这个方法将会被作为派生View调用ViewCompat.startNestedScroll(View, int)时的回复响应，每个上层的父视图如果这个方法返回true,都将有机会响应和拦截（消耗）这个嵌套滑动操作. onNestedScrollAccepted方法1public void onNestedScrollAccepted(View child, View target, int nestedScrollAxes); React to the successful claiming of a nested scroll operation. 翻译：对嵌套滑动操作的成功声明作出响应， This method will be called after {@link #onStartNestedScroll(View, View, int) onStartNestedScroll} returns true. It offers an opportunity for the view and its superclasses to perform initial configuration for the nested scroll. Implementations of this method should always call their superclass’s implementation of this method if one is present. 翻译：这个方法将会在 onStartNestedScroll方法返回true时被调用。这个方法提供给View和他的父类一个对嵌套滑动操作进行初始化配置的机会。如果父类对该方法有操作，实现此方法应该调用父类的实现。 onStopNestedScroll方法1public void onStopNestedScroll(View target); 参数和返回值 12//触发嵌套滑动的View@param target View that initiated the nested scroll React to a nested scroll operation ending. 翻译：对嵌套滑动结束做出响应 Perform cleanup after a nested scrolling operation.This method will be called when a nested scroll stops, for example when a nested touch scroll ends with a {@link MotionEvent#ACTION_UP} or {@link MotionEvent#ACTION_CANCEL} event. Implementations of this method should always call their superclass’s implementation of this method if one is present. 翻译：确认在嵌套滑动操作结束之后的清理操作，比如一些参数的重新初始化，这个方法将会在嵌套滑动操作结束后调用，比如嵌套滑动操作因为ACTION_UP，ACTION_CANCEL事件被终止。如果父类对该方法有操作，实现此方法应该调用父类的实现。 onNestedScroll方法1public void onNestedScroll(View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed); 参数和返回值 12345678910// 控制嵌套滑动的子View@param target The descendent view controlling the nested scroll// 子View水平滑动消耗的距离@param dxConsumed Horizontal scroll distance in pixels already consumed by target// 子View垂直滑动消耗的距离@param dyConsumed Vertical scroll distance in pixels already consumed by target// 子View水平滑动没有消耗的距离@param dxUnconsumed Horizontal scroll distance in pixels not consumed by target// 子View水平滑动没有消耗的距离@param dyUnconsumed Vertical scroll distance in pixels not consumed by target React to a nested scroll in progress. 翻译：对滑动过程作出响应 This method will be called when the ViewParent’s current nested scrolling child view dispatches a nested scroll event. To receive calls to this method the ViewParent must have previously returned true for a call to {@link #onStartNestedScroll(View, View, int)}. 翻译：这个方法将会在ViewParent中当前正在嵌套滑动的子View分发嵌套滑动事件时被调用。为了能够接受到调用这个方法，ViewParent必须事先在onStartNestedScroll返回true。 Both the consumed and unconsumed portions of the scroll distance are reported to the ViewParent. An implementation may choose to use the consumed portion to match or chase scroll position of multiple child elements, for example. The unconsumed portion may be used to allow continuous dragging of multiple scrolling or draggable elements, such as scrolling a list within a vertical drawer where the drawer begins dragging once the edge of inner scrolling content is reached. 翻译：消耗部分和没有消耗部分的嵌套滑动的距离都被上报给ViewParent。一个实现可以选择使用消耗的部分来匹配或追逐多个子元素的滚动位置，例如。未使用的部分可以用来允许连续滚动或拖动拖动多元素，如在一个垂直的抽屉内滚动一个列表，抽屉开始拖动滚动达到内容的边缘。 onNestedPreScroll方法1public void onNestedPreScroll(View target, int dx, int dy, int[] consumed); 参数和返回值 12345678// 发起嵌套滑动的子View@param target View that initiated the nested scroll// 水平滑动的距离@param dx Horizontal scroll distance in pixels// 垂直滑动的距离@param dy Vertical scroll distance in pixels// 输出,水平滑动和垂直滑动被父View消耗的距离@param consumed Output. The horizontal and vertical scroll distance consumed by this parent React to a nested scroll in progress before the target view consumes a portion of the scroll. 滑动过程中在发起嵌套滑动的子View消耗滑动距离之前作出反应 When working with nested scrolling often the parent view may want an opportunity to consume the scroll before the nested scrolling child does. An example of this is a drawer that contains a scrollable list. The user will want to be able to scroll the list fully into view before the list itself begins scrolling. 在进行嵌套滑动时，通常父View希望获得机会在子View之前消耗滑动距离。例如，抽屉里面包含一个可以滑动的list,用户将希望能够在列表本身开始滚动之前将列表完全滚动到视图中。 onNestedPreScroll is called when a nested scrolling child invokes {@link View#dispatchNestedPreScroll(int, int, int[], int[])}. The implementation should report how any pixels of the scroll reported by dx, dy were consumed in the consumed array. Index 0 corresponds to dx and index 1 corresponds to dy. This parameter will never be null. Initial values for consumed[0] and consumed[1] will always be 0. onNestedPreScroll 方法在子View调用dispatchNestedPreScroll方法时被调用。这个方法的实现应该报告对dx和dy进行了多少消耗。consumed[0]代表消耗的dx,consumed[1]代表消耗的dy,这个参数不会为空，consumed[0]和consumed[1]初始值为0。 onNestedFling方法1public boolean onNestedFling(View target, float velocityX, float velocityY, boolean consumed); 参数和返回值 12345678910// 发起嵌套滑动的子View@param target View that initiated the nested scroll// 横向滑动的速度@param velocityX Horizontal velocity in pixels per second// 竖向滑动的速度@param velocityY Vertical velocity in pixels per second// 如果是true表示这个子View消耗了这个滑动@param consumed true if the child consumed the fling, false otherwise// 返回true表示，父View消耗滑动或其他情况@return true if this parent consumed or otherwise reacted to the fling Request a fling from a nested scroll. 需要嵌套滑动发生fling事件 This method signifies that a nested scrolling child has detected suitable conditions for a fling. Generally this means that a touch scroll has ended with a {@link VelocityTracker velocity} in the direction of scrolling that meets or exceeds the {@link ViewConfiguration#getScaledMinimumFlingVelocity() minimum fling velocity} along a scrollable axis. 这个方法意味着嵌套滑动的子View监测到一个适合fling的情况。通常意味着触摸事件在一个可滑动的轴上在一个方向上以一定速度结束，这个速度超过了ViewConfiguration#getScaledMinimumFlingVelocity()的值。 If a nested scrolling child view would normally fling but it is at the edge of its own content, it can use this method to delegate the fling to its nested scrolling parent instead. The parent may optionally consume the fling or observe a child fling. 如果一个子View在嵌套滑动但是到达了他的内容边缘，它可以使用这个方法将处理fling事件代理给父View,父View可以选择性的消耗fling事件或者观察子View的fling事件。 onNestedPreFling方法1public boolean onNestedPreFling(View target, float velocityX, float velocityY); 参数和返回值 12345678// 触发嵌套滑动的子View@param target View that initiated the nested scroll// 水平方向滑动速度@param velocityX Horizontal velocity in pixels per second// 垂直方向滑动速度@param velocityY Vertical velocity in pixels per second// 如果父View要处理这个fling事件返回true@return true if this parent consumed the fling ahead of the target view React to a nested fling before the target view consumes it. 在子View对嵌套fling事件消耗之前作出响应 This method siginfies that a nested scrolling child has detected a fling with the given velocity along each axis. Generally this means that a touch scroll has ended with a {@link VelocityTracker velocity} in the direction of scrolling that meets or exceeds the {@link ViewConfiguration#getScaledMinimumFlingVelocity() minimum fling velocity} along a scrollable axis. 这个方法意味着嵌套滑动的子View在每个轴上给定的速度上发生了fling事件，通常意味着触摸事件在一个可滑动的轴上在一个方向上以一定速度结束，这个速度超过了ViewConfiguration#getScaledMinimumFlingVelocity()的值。 If a nested scrolling parent is consuming motion as part of a {@link #onNestedPreScroll(View, int, int, int[]) pre-scroll}, it may be appropriate for it to also consume the pre-fling to complete that same motion. By returning true from this method, the parent indicates that the child should not fling its own internal content as well. 如果父View在onNestedPreScroll方法中消耗了嵌套滑动，那么他可能同样也想在fling事件中进行消耗操作，来完成处理嵌套滑动的请求。这个方法返回true表明子View应该只在它自己的区域内滑动。 getNestedScrollAxes()方法1public int getNestedScrollAxes(); 参数和返回值 12345// 表明滑动轴方向的flag@return Flags indicating the current axes of nested scrolling@see ViewCompat#SCROLL_AXIS_HORIZONTAL@see ViewCompat#SCROLL_AXIS_VERTICAL@see ViewCompat#SCROLL_AXIS_NONE A NestedScrollingParent returning something other than {@link ViewCompat#SCROLL_AXIS_NONE}］is currently acting as a nested scrolling parent for one or more descendant views in the hierarchy. 如果没有返回ViewCompat#SCROLL_AXIS_NONE，表明有子View在进行嵌套滑动。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SourceCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 6.0 权限动态申请]]></title>
    <url>%2Farticle%2F2939773101%2F</url>
    <content type="text"><![CDATA[minSdkVersion minSdkVersion指的是你的应用可以兼容到的最低版本，比如你只使用了2.X的API，那minSdkVersion就可以尽量小，以适配更多机型，小于minSdkVersion的机型将无法安装。 maxSdkVersion maxSdkVersion指的是你的应用可以支持到的最高版本，高于这个版本的机型将不能安装应用，但是这个不需要我们自己去写，Android系统默认向下兼容的。 targetSdkVersion targetSdkVersion如果设置了此属性，那么在程序执行时，如果目标设备的API版本正好等于此数值，他会告诉Android平台：此程序在此版本已经经过充分测，没有问题。不必为此程序开启兼容性检查判断的工作了。 介绍 由于Android M对隐私权限必须动态申请，当你的targetSdkVersion&gt;=23时就需要进行权限申请了，否则将获得不了权限。不过当targetSdkVersion&lt;23时，由于Android版本向下兼容性，你的应用将运行在&lt;23的环境中，不会出现问题。 Git上已经有很多开源库供大家使用了，确实方便简单，PermissionGen这个库好评率还是蛮高的，使用注解简化了很多操作，网上很多博客都推荐它，不过，我觉得不能遇到啥问题就引个别人的库进来， 一方面如果库的定制性不高，自定义起来也是麻烦，另一方面，像这种比较简单的问题，还是自己写比较好，可以了解一下是如何实现的，对自己的学习也有好处。别人封装的再好也不是自己的，以后只能说我会使用XX,XXX…类库.那就尴尬了。扯远了～ Android权限 Android M之后将权限分为了两类，Normal和Dangerous Permission,Dangerous Permission大都是跟用户隐私相关的权限，如下表，更详细见Android文档－Permissions Permission Group Permissions CALENDAR READ _ CALENDAR WRITE _ CALENDAR CAMERA CAMERA CONTACTS READ _ CONTACTS WRITE _ CONTACTS GET _ ACCOUNTS LOCATION ACCESS FINE LOCATION ACCESS COARSE LOCATION MICROPHONE RECORD _ AUDIO PHONE READ PHONE STATE CALL _ PHONE READ CALL LOG WRITE CALL LOG ADD _ VOICEMAIL USE _ SIP PROCESS OUTGOING CALLS SENSORS BODY _ SENSORS SMS SEND _ SMS RECEIVE _ SMS READ _ SMS RECEIVE WAP PUSH RECEIVE _ MMS STORAGE READ EXTERNAL STORAGE WRITE EXTERNAL STORAGE 思路和API 涉及到的核心方法context.requestPermissions(String[] permissions,int reqCode);该方法必须在Android M以上可以使用。大体的思路就是： 当前手机版本是不是大于Android M ？ 是否有私有权限需要申请？ 该权限是不是已经同意了 弹个dialog告诉用户我们将要申请哪些权限，现在市面上app大都是这么做的 开始申请 处理申请结果 PermissionHelper 为了方便操作，我将部分核心方法抽象出来了，调用checkPermission()申请权限，返回值会告诉你是不是需要申请，调用onRequestPermissionsResult()会格式化处理返回的数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * com.march.baselib.helper * CommonLib * Created by chendong on 16/8/17. * Copyright © 2016年 chendong. All rights reserved. * Desc : */public class PermissionHelper &#123; public static final int REQ_PERMISSION_CODE = 0x12; /** * 动态申请权限 * @param context 上下文 * @param permissions 需要申请的权限 * @return 是不是需要申请 */ public static boolean checkPermission(Activity context, String[] permissions) &#123; //6.0以上 if (AppHelper.isOverMarshmallow()) &#123; //没有权限需要申请时 if (permissions == null || permissions.length &lt;= 0) return true; //检查权限是不是已经授予 List&lt;String&gt; noOkPermissions = new ArrayList&lt;&gt;(); for (String permission : permissions) &#123; if (context.checkSelfPermission(permission) == PackageManager.PERMISSION_DENIED) &#123; noOkPermissions.add(permission); &#125; &#125; //该权限已经授予，不再申请 if (noOkPermissions.size() &lt;= 0) return true; //6.0以上需要申请权限 context.requestPermissions(noOkPermissions.toArray(new String[noOkPermissions.size()]), REQ_PERMISSION_CODE); return false; &#125; //6.0以下下不需要申请 return true; &#125; /** * 处理权限申请的结果，返回结构化的数据 * @param requestCode 请求码 * @param permissions 被请求的权限 * @param grantResults 请求结果 * @param listener 监听 */ public static void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults, OnPermissionHandleOverListener listener) &#123; if (requestCode != REQ_PERMISSION_CODE) return; Map&lt;String, Integer&gt; result = new HashMap&lt;&gt;(); boolean isHavePermissionNotOk = false; for (int i = 0; i &lt; Math.min(permissions.length, grantResults.length); i++) &#123; result.put(permissions[i], grantResults[i]); //有权限没有同意 if (grantResults[i] == PackageManager.PERMISSION_DENIED) &#123; isHavePermissionNotOk = true; &#125; &#125; //如果权限全部同意，继续执行 if (listener != null) listener.onHandleOver(!isHavePermissionNotOk, result); &#125; public interface OnPermissionHandleOverListener &#123; void onHandleOver(boolean isOkExactly, Map&lt;String, Integer&gt; result); &#125;&#125; BaseActivity 一般权限监测是在Activity进行，在基类中监测要简单方便 1234567891011121314151617181920212223242526272829303132333435@Overridepublic void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mSaveBundle = savedInstanceState; mActivity = this; mContext = getApplicationContext(); createViewShow(); //如果不需要监测，会立刻执行invokeCommonMethod()开始Activity操作，如果需要就会发起申请 if (PermissionHelper.checkPermission(mActivity, getPermission2Check())) invokeCommonMethod(mSaveBundle); &#125; //抽象方法，由子类来决定哪些权限需要申请protected abstract String[] getPermission2Check();//子类实现决定处理结果protected boolean handlePermissionResult(Map&lt;String, Integer&gt; resultNotOk) &#123; return true;&#125;//处理返回结果@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); PermissionHelper.onRequestPermissionsResult(requestCode, permissions, grantResults, new PermissionHelper.OnPermissionHandleOverListener() &#123; @Override public void onHandleOver(boolean isOkExactly, Map&lt;String, Integer&gt; result) &#123; //权限ok或者子类要求直接执行 if (isOkExactly || handlePermissionResult(result)) invokeCommonMethod(mSaveBundle); &#125; &#125;); &#125; 子类12345678910111213141516//哪些权限需要申请@TargetApi(Build.VERSION_CODES.JELLY_BEAN)@Overrideprotected String[] getPermission2Check() &#123; return new String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;;&#125;//如果权限没有获得如何处理@Overrideprotected boolean handlePermissionResult(Map&lt;String, Integer&gt; resultNoOk) &#123; if (resultNoOk.get(Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_DENIED) &#123; Toaster.get().show("您没有允许读取存储卡，不能继续操作"); return false; &#125; return true;&#125; 以上]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AndroidTips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python普通方法、静态方法、类方法]]></title>
    <url>%2Farticle%2F1727896955%2F</url>
    <content type="text"><![CDATA[开始123456789101112131415161718192021222324# -*-coding:utf-8-*-# 普通方法,类方法,静态方法的区别__metaclass__ = typeclass Tst: name = 'tst' data = 'this is data' # 普通方法 def normalMethod(self, name): print self.data, name # 类方法,可以访问类属性 @classmethod def classMethod(cls, name): print cls.data, name # 静态方法,不可以访问类属性 @staticmethod def staticMethod(name): print name 测试 三种方法都可以通过实例来调用，但是静态方法和类方法无法访问实例属性，所以更改了tst.data仅对普通方法起了作用 12345678910tst = Tst()tst.data = 'this is new'tst.normalMethod('name')tst.staticMethod('name')tst.classMethod('name')#结果this is new namenamethis is data name 区别 普通方法不能通过类名调用，但是静态方法和类方法是可以的 12345678# error普通方法必须通过实例调用# Tst.normalMethod(&apos;name&apos;)Tst.classMethod(&apos;name&apos;)Tst.staticMethod(&apos;name&apos;)#结果this is data namename 总结 普通方法,可以通过self访问实例属性 1def normalMethod(self,data) 类方法,可以通过cls访问类属性 12@classmethoddef classMethod(cls,data) 静态方法,不可以访问,通过传值的方式 12@staticmethoddef staticMethod(data)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Json]]></title>
    <url>%2Farticle%2F2150468451%2F</url>
    <content type="text"><![CDATA[开始12345678910111213141516171819202122232425# -*-coding:utf-8-*-import jsonfrom httptst.Singleton import singleton@singletonclass JsonHelper(object): name = 'json helper' def convert_to_builtin_type(obj): print 'default(', repr(obj), ')' dict = &#123;&#125; dict.update(obj.__dict__) return dict # obj 转 json def getJson(self, obj): data = json.dumps(obj, sort_keys=True, default=self.convert_to_builtin_type) return data # json str 转dict def parse(self, jsonStr): jsonDict = json.loads(jsonStr) return jsonDict]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python实现单例]]></title>
    <url>%2Farticle%2F3789624758%2F</url>
    <content type="text"><![CDATA[单例装饰器 在网上查到很多方式，选择一种比较pythonic的方式 123456789def singleton(cls, *args, **kwargs): instances = &#123;&#125; def _singleton(): if cls not in instances: instances[cls] = cls(*args, **kwargs) return instances[cls] return _singleton 使用12345678@singletonclass HttpHelper: def __init__(self): pass name = 'http helper' ...... ....]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android添加快捷方式]]></title>
    <url>%2Farticle%2F3591670187%2F</url>
    <content type="text"><![CDATA[权限12&lt;uses-permission android:name="com.android.launcher.permission.INSTALL_SHORTCUT"/&gt;&lt;uses-permission android:name="com.android.launcher.permission.UNINSTALL_SHORTCUT"/&gt; 配置 快捷方式要打开一个界面，需要一个Intent配置这些信息 1234567891011121314/*** 获取Intent** @param thisActivity 当前activity* @param goActivity 点击打开的activity* @return 创建的Intent*/private static Intent getShortCutIntent(Activity thisActivity, Class goActivity) &#123; // 使用MAIN，可以避免部分手机(比如华为、HTC部分机型)删除应用时无法删除快捷方式的问题 Intent intent = new Intent(Intent.ACTION_MAIN); intent.addCategory(Intent.CATEGORY_DEFAULT); intent.setClass(thisActivity, goActivity); return intent;&#125; Action1234// Action 添加Shortcutpublic static final String ACTION_ADD_SHORTCUT = "com.android.launcher.action.INSTALL_SHORTCUT";// Action 移除Shortcutpublic static final String ACTION_REMOVE_SHORTCUT = "com.android.launcher.action.UNINSTALL_SHORTCUT"; 添加快捷方式123456789101112131415161718192021222324252627282930/*** 添加快捷方式** @param activity context* @param name name* @param goActivity 要启动的界面* @param allowRepeat 是否允许重复,建议false* @param iconBitmap 快捷方式图标*/public static void addShortcut(Activity activity, Class goActivity, String name,boolean allowRepeat, Bitmap iconBitmap) &#123; Intent addShortcutIntent = new Intent(ACTION_ADD_SHORTCUT); // 是否允许重复创建 addShortcutIntent.putExtra("duplicate", allowRepeat); // 快捷方式的标题 addShortcutIntent.putExtra(Intent.EXTRA_SHORTCUT_NAME, name); // 快捷方式的图标 addShortcutIntent.putExtra(Intent.EXTRA_SHORTCUT_ICON, iconBitmap); // 快捷方式的动作 Intent shortCutIntent = getShortCutIntent(activity, goActivity); addShortcutIntent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortCutIntent); activity.sendBroadcast(addShortcutIntent);&#125;public static void addShortcut(Activity activity, Class goActivity, String name, boolean allowRepeat, int res) &#123; BitmapFactory.Options options = new BitmapFactory.Options(); Bitmap bitmap = BitmapFactory.decodeResource(activity.getResources(), res); addShortcut(activity, goActivity, name, allowRepeat, bitmap);&#125; 移除快捷方式12345678910111213141516/** * 移除快捷方式 * * @param activity context * @param goActivity 要启动的Activity * @param name name */public static void removeShortcut(Activity activity, Class goActivity, String name) &#123; Intent intent = new Intent(ACTION_REMOVE_SHORTCUT); intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, name); //intent.addCategory(Intent.CATEGORY_LAUNCHER); intent.putExtra("duplicate", false); Intent shortCutIntent = getShortCutIntent(activity, goActivity); intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortCutIntent); activity.sendBroadcast(intent);&#125; 附全部代码，亲测可用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * com.march.libs.helper * CdLibsTest * Created by chendong on 16/7/29. * Copyright © 2016年 chendong. All rights reserved. * Desc : */public class ShortCutHelper &#123; // Action 添加Shortcut public static final String ACTION_ADD_SHORTCUT = "com.android.launcher.action.INSTALL_SHORTCUT"; // Action 移除Shortcut public static final String ACTION_REMOVE_SHORTCUT = "com.android.launcher.action.UNINSTALL_SHORTCUT"; /** * 获取Intent * * @param thisActivity 当前activity * @param goActivity 点击打开的activity * @return 创建的Intent */ private static Intent getShortCutIntent(Activity thisActivity, Class goActivity) &#123; // 使用MAIN，可以避免部分手机(比如华为、HTC部分机型)删除应用时无法删除快捷方式的问题 Intent intent = new Intent(Intent.ACTION_MAIN); intent.addCategory(Intent.CATEGORY_DEFAULT); intent.setClass(thisActivity, goActivity); return intent; &#125; /** * 添加快捷方式 * * @param activity context * @param name name * @param goActivity 要启动的界面 * @param allowRepeat 是否允许重复 * @param iconBitmap 快捷方式图标 */ public static void addShortcut(Activity activity, Class goActivity, String name, boolean allowRepeat, Bitmap iconBitmap) &#123; Intent addShortcutIntent = new Intent(ACTION_ADD_SHORTCUT); // 是否允许重复创建 addShortcutIntent.putExtra("duplicate", allowRepeat); // 快捷方式的标题 addShortcutIntent.putExtra(Intent.EXTRA_SHORTCUT_NAME, name); // 快捷方式的图标 addShortcutIntent.putExtra(Intent.EXTRA_SHORTCUT_ICON, iconBitmap); // 快捷方式的动作 Intent shortCutIntent = getShortCutIntent(activity, goActivity); addShortcutIntent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortCutIntent); activity.sendBroadcast(addShortcutIntent); &#125; public static void addShortcut(Activity activity, Class goActivity, String name, boolean allowRepeat, int res) &#123; BitmapFactory.Options options = new BitmapFactory.Options(); Bitmap bitmap = BitmapFactory.decodeResource(activity.getResources(), res); addShortcut(activity, goActivity, name, allowRepeat, bitmap); &#125; /** * 移除快捷方式 * * @param activity context * @param goActivity 要启动的Activity * @param name name */ public static void removeShortcut(Activity activity, Class goActivity, String name) &#123; Intent intent = new Intent(ACTION_REMOVE_SHORTCUT); intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, name); //intent.addCategory(Intent.CATEGORY_LAUNCHER); intent.putExtra("duplicate", false); Intent shortCutIntent = getShortCutIntent(activity, goActivity); intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortCutIntent); activity.sendBroadcast(intent); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AndroidTips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 范型]]></title>
    <url>%2Farticle%2F2053934834%2F</url>
    <content type="text"><![CDATA[关于如何继承带有范型的基类 继承父类的范型12345678910111213141516171819202122232425262728293031public class GenericityTst &#123; public class Temp &#123; &#125; //具有泛型的ClassA public class ClassA&lt;T&gt;&#123; T t; &#125; //继承泛型 public class ClassB&lt;T&gt; extends ClassA&lt;T&gt;&#123; T t; &#125; //缩小泛型的范围，是准许的，但是不允许扩大泛型的范围 public class ClassC&lt;T extends Temp&gt; extends ClassA&lt;T&gt;&#123; T t; &#125; //具有泛型的类ClassD,泛型具有父类约束 public class ClassD&lt;T extends Temp&gt; &#123; T t; &#125; //继承ClassD,声明泛型时至少具有父类同样的约束 public class ClassE&lt;T extends Temp&gt; extends ClassD&lt;T&gt;&#123; T t; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 AS 中使用 Lambda 表达式]]></title>
    <url>%2Farticle%2F4229621729%2F</url>
    <content type="text"><![CDATA[配置 AndroidStudio 支持 Lambda 表达式 2017.9.30 升级到 3.7.0 并与 freeline 编译使用 根目录下gradle文件配置在 project / build.gradle 中配置 123456789buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:2.3.3&apos; classpath &apos;me.tatarka:gradle-retrolambda:3.7.0&apos; &#125;&#125; app下gradle文件配置在 project / app / build.gradle 顶部配置插件 1apply plugin: &apos;me.tatarka.retrolambda&apos; 在android{…}中配置123456789101112131415android &#123; retrolambda &#123; javaVersion JavaVersion.VERSION_1_7 jvmArgs &apos;-noverify&apos; defaultMethods false incremental true &#125; // 使用Java1.8 compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>DevEnvironment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ORM框架－GreenDao2.0]]></title>
    <url>%2Farticle%2F3564593419%2F</url>
    <content type="text"><![CDATA[GreenDao官网官网 -&gt; http://greendao-orm.com GitHubGitHub -&gt; https://github.com/greenrobot/greenDAO 性能对比 介绍 GreenDao采用的是用java代码直接生成Bean（实体）和Dao（Data Access Object数据访问对象）的方式，都不用自己写实体了，也是一大好处，不过这也造成了理解上的难度，我刚开始用的时候就有点蒙。 首先创建一个Java的Library,一定是Java的，命名为daogenerator（可以起别的名字，为了后面叙述方便）。在app下面和’java’目录同级创建’java-gen’目录，将会用来放置生成的Bean和Dao。Dao也就是数据访问对象，实体类只能描述一个对象的属性和行为，想与数据库交流就需要Dao对象，它包含对应的数据库字段和增删改查方法。 生成文件 在daogenerator库里创建’ExampleDaoGenerator.java’文件,包含main方法，构建schema，生成目录和文件 123456789101112131415161718192021public static void main(String[] args) throws Exception&#123; operate();&#125;private static void operate() throws Exception &#123; // Schema对象，可以用来生成实体和dao // 两个参数分别代表：数据库版本号与自动生成bean代码的包路径。 Schema schema = new Schema(2, "com.march.bean"); // 默认的dao目录 schema.setDefaultJavaPackageDao("com.march.dao"); // 模式（Schema）同时也拥有两个默认的 flags，分别用来标示 entity 是否是 activie 以及是否使用 keep sections。 // 可以激活预热实体，使读写更迅速 schema.enableActiveEntitiesByDefault(); // 这个是为了你可以在自动生成的实体类中添加自己的custom代码 schema.enableKeepSectionsByDefault(); // 一旦你拥有了一个 Schema 对象后，你便可以使用它添加实体（Entities）了。这里只是一个假的方法表示一下，生成实体在下一节 generateBean(schema); // 最后我们将使用 DAOGenerator 类的 generateAll() 方法自动生成代码，此处你需要根据自己的情况更改输出目录（既之前创建的 java-gen)。 // 其实，输出目录的路径可以在 build.gradle 中设置，有兴趣的朋友可以自行搜索，这里就不再详解。 new DaoGenerator().generateAll(schema, "/Users/march/AndroidPro/Reaper/app/src/main/java-gen");&#125; 如何生成实体12345678910111213private static void addNote(Schema schema) &#123; // 一个实体（类）就关联到数据库中的一张表，此处表名为「Note」（既类名） Entity note = schema.addEntity("Note"); // greenDAO 会自动根据实体类的属性值来创建表字段，并赋予默认值 // 接下来你便可以设置表中的字段,又很多链式编程的方法，结合数据库的create table操作可以设置相关的字段及约束 note.addIdProperty().autoincrement(); note.addBooleanProperty("isYes").primaryKey().unique(); note.addStringProperty("text").notNull(); // 与在 Java 中使用驼峰命名法不同，默认数据库中的命名是使用大写和下划线来分割单词的。 // For example, a property called “creationDate” will become a database column “CREATION_DATE”. note.addStringProperty("comment"); note.addDateProperty("date");&#125; 自定义生成的代码 当重新执行java代码时会覆盖生成新的文件，如果你修改了生成的类，就会被重新覆盖，解决这个问题，设置note.setHasKeepSections(true);会在文件中生成一些注释，在注释中间的代码将不会被覆盖，也可以设置继承，实现等。。。这样就不需要每次都修改代码了 1234567891011121314151617181920// KEEP INCLUDES - put your custom includes hereimport com.march.quickrvlibs.inter.RvQuickInterface;// KEEP INCLUDES END// KEEP FIELDS - put your custom fields herepublic static final int TYPE_SHU = 0;public static final int TYPE_HENG = 1;// KEEP FIELDS END// KEEP METHODS - put your custom methods here@Overridepublic int getRvType() &#123; if (height &gt; width) return 0; else return 1;&#125;// KEEP METHODS END 12345678//设置支持自定义代码（或schema.enableKeepSectionsByDefault();）note.setHasKeepSections(true);//设置实现的接口note.implementsInterface("RvQuickInterface", "java.io.Serializable");//设置继承的父类note.setSuperclass("Album");//你也可以重新给表命名note.setTableName("NODE"); 初始化数据库123456789101112131415private DaoSession mDaoSession;public void setupDatabase(Context context) &#123; // 通过 DaoMaster 的内部类 DevOpenHelper，你可以得到一个便利的 SQLiteOpenHelper 对象。 // 可能你已经注意到了，你并不需要去编写「CREATE TABLE」这样的 SQL 语句，因为 greenDAO 已经帮你做了。 // 注意：默认的 DaoMaster.DevOpenHelper 会在数据库升级时，删除所有的表，意味着这将导致数据的丢失。 // 所以，在正式的项目中，你还应该做一层封装，来实现数据库的安全升级。 DaoMaster.DevOpenHelper helper = new DaoMaster.DevOpenHelper(context, "notes-db", null); SQLiteDatabase db = helper.getWritableDatabase(); // 注意：该数据库连接属于 DaoMaster，所以多个 Session 指的是相同的数据库连接。 DaoMaster daoMaster = new DaoMaster(db); mDaoSession = daoMaster.newSession(); // 在 QueryBuilder 类中内置两个 Flag 用于方便输出执行的 SQL 语句与传递参数的值 QueryBuilder.LOG_SQL = true; QueryBuilder.LOG_VALUES = true;&#125; 获取Dao123public WholeAlbumItemDao getWholeAlbumItemDao() &#123; return mDaoSession.getWholeAlbumItemDao();&#125; 增12345678910//这两个方法提供简单的插入和不存在则插入存在则更新的操作DaoHelper.get().getAlbumDetailDao().insert();DaoHelper.get().getAlbumDetailDao().insertOrReplace();//这两个方法是上面两个方法的加强版，支持iterable类型多个对象的插入和更新，同时是基于事务的。DaoHelper.get().getAlbumDetailDao().insertInTx();DaoHelper.get().getAlbumDetailDao().insertOrReplaceInTx();//官方解释:Insert an entity into the table associated with a concrete DAO &lt;b&gt;without&lt;/b&gt; setting key property.//Warning: This may be faster, but the entity should not be used anymore. The entity also won't be attached to identity scope.//大概意思就是小心点用，虽然速度快，但是插进去可能就拿不出来了DaoHelper.get().getAlbumDetailDao().insertWithoutSettingPk() 删1234567891011//与insert方法大同小异DaoHelper.get().getAlbumDetailDao().delete();DaoHelper.get().getAlbumDetailDao().deleteInTx();//根据主键删除元素DaoHelper.get().getAlbumDetailDao().deleteByKey();DaoHelper.get().getAlbumDetailDao().deleteByKeyInTx();//删除全部DaoHelper.get().getAlbumDetailDao().deleteAll();//也是删除，具体的区别还没弄明白DaoHelper.get().getAlbumDetailDao().detach()DaoHelper.get().getAlbumDetailDao().detachAll(); 改12DaoHelper.get().getAlbumDetailDao().update();DaoHelper.get().getAlbumDetailDao().updateInTx(); 查 关于Query的操作相对复杂， 下面只是比较基本的，更多的使用方法可以参照Query文档 12345678910111213141516171819// 获取querybuilderQueryBuilder&lt;RecommendAlbumItem&gt; queryBuilder = DaoHelper.get().getRecommendAlbumItemDao().queryBuilder();// 查询条件，大于小于，and,orqueryBuilder.where( RecommendAlbumItemDao.Properties.Album_type.eq(""), queryBuilder.or(RecommendAlbumItemDao.Properties.Album_cover.gt(""), queryBuilder.and(RecommendAlbumItemDao.Properties.Album_cover.ge("") ,RecommendAlbumItemDao.Properties.Album_cover.eq(""))));// offset limmit queryBuilder.offset(10).limit(10);//排序queryBuilder.orderAsc();queryBuilder.orderCustom(null,null);queryBuilder.orderDesc();queryBuilder.build();//查询数量queryBuilder.count();//返回listqueryBuilder.list();]]></content>
      <categories>
        <category>Android</category>
        <category>Library</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Library</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 安装 Mongdb]]></title>
    <url>%2Farticle%2F3372882306%2F</url>
    <content type="text"><![CDATA[MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。 在高负载的情况下，添加更多的节点，可以保证服务器性能。MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。 MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。 特点:高性能、易部署、易使用，存储数据非常方便。 安装 MongoDb安装homebrew 1$ /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 更新homebrew 1$ brew update 安装mongodb 1$ brew install mongodb 配置环境变量1234$ open ~/.bash_profile # 写入以下路径# mongodbexport PATH=$&#123;PATH&#125;:/usr/local/Cellar/mongodb/3.2.6/bin 根据配置启动mongodb使用该命令将会使用mongod.conf文件的相关配置来启动mongodb 文件的路径在 /usr/local/etc/mongod.conf（Mac） 从配置文件可以看到数据库的路径以及log的路径等。 1234567891011$ mongod --config /usr/local/etc/mongod.conf# mongod.conf 文件内容systemLog: destination: file path: /usr/local/var/log/mongodb/mongo.log logAppend: truestorage: dbPath: /usr/local/var/mongodbnet: bindIp: 127.0.0.1 直接启动直接启动快捷简单，数据将会存储在/data/db下,其中/data路径与/usr路径是同级的。 123456789数据会存放在/data/db 目录下，需要首先创建目录，并更改目录权限$ mkdir -p /data/db $ sudo chown -R march /data启动mongodb服务$ mongod输入 mongo ，连接到mongo服务，即可进入命令行操作$ mongo]]></content>
      <categories>
        <category>Db</category>
      </categories>
      <tags>
        <tag>Database</tag>
        <tag>MongoDb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node开发-1-基础]]></title>
    <url>%2Farticle%2F3697016025%2F</url>
    <content type="text"><![CDATA[基本工具的配置检测xcode是否安装12$ xcode-select -p/Applications/Xcode.app/Contents/Developer 检测python和ruby版本12$ python -v$ ruby -v 安装homebrew1$ /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 安装node.js1$ brew install node 第一个web应用创建连接12345678910111213141516//新建一个文件，为server.js,内容如下const http = require('http');const hostname = '127.0.0.1';const port = 3000;const server = http.createServer((req, res) =&gt; &#123; res.statusCode = 200; res.setHeader('Content-Type', 'text/plain'); res.end('Hello World\n');&#125;);server.listen(port, hostname, () =&gt; &#123; console.log(`Server running at http://$&#123;hostname&#125;:$&#123;port&#125;/`);&#125;); 启动服务 到相应目录下运行命令,打开浏览器输入http://127.0.0.1:3000/可以看到服务已经起来了，使用ctrl+c停止服务 1$ node server.js]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Django服务器搭建]]></title>
    <url>%2Farticle%2F1002618664%2F</url>
    <content type="text"><![CDATA[前言 安装的部分工具，我是在Mac下使用，其他的平台自己搜索一下如何安装。现在默认你已经安装了Python环境，我的是Python2.7 安装pip包管理器 pip包管理器是python下安装模块的工具 1234567$ curl -O https://raw.github.com/pypa/pip/master/contrib/get-pip.py$ [sudo] python get-pip.py# 安装包$ pip install django# 卸载包$ pip uninstall django 安装ipython ipython是一个增强式的python交互式操作命令工具，有自动提示和补全的功能 1$ pip install ipython 安装django1$ pip install django 简单尝试12345678910111213141516171819# 创建一个项目$ django -admin startproject mysite# 开启服务$ python manage.py runserver# 出现如下字样May 14, 2016 - 00:00:21Django version 1.9.6, using settings 'mysite.settings'Starting development server at http://127.0.0.1:8000/Quit the server with CONTROL-C.Not Found: /[14/May/2016 00:00:32] "GET / HTTP/1.1" 200 1767Not Found: /favicon.ico[14/May/2016 00:00:32] "GET /favicon.ico HTTP/1.1" 404 1936# 打开浏览器输入`http://127.0.0.1:8000/`就可以看到It worked字样，一个简单的web服务就好了# 你可以使用`python manage.py`查看更多的命令 各个文件的简单介绍12345678910$ cd mysite/$ lsmanage.py mysite# manage.py是一个管理工具，使用它可以管理服务器，比如开启服务等# mysite是你的工程目录$ cd mysite/__init__.py settings.py urls.py wsgi.py__init__.pyc settings.pyc urls.pyc wsgi.pyc# settings.py 是一些配置信息# urls.py 是url的映射，他表示不同的url会映射到不同的网页 建立app django是使用app的形式来配置模块，你可以建立新的模块 12345678910111213$ python manage.py startapp blog# 可以发现在mysite目录下有了blog和mysite两个文件夹# 在mysite/mysite/settings.py中配置这个app模块# Application definitionINSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'blog'] 构建一个简单的网页123456789101112131415161718192021222324252627$ cd blog/$ ls_init__.py admin.pyc models.py views.py__init__.pyc apps.py models.pyc views.pycadmin.py migrations tests.py# blog目录下的文件，我们现在只使用views.py，他是用来构建输出html 页面的一个类#（1）打开views.py 定义一个简单的html页面from django.shortcuts import renderfrom django.http import HttpResponse# Create your views here.def hello(request): return HttpResponse('&lt;html&gt;hello world&lt;/html&gt;') # (2) 打开mysite/mysite/urls.py 配置url映射from django.conf.urls import urlfrom django.contrib import adminurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'hello','blog.views.hello')]# (3) 启动服务,在浏览器输入http://127.0.0.1:8000/hello,可以获得返回的网页$ python manage.py runserver]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift基础2]]></title>
    <url>%2Farticle%2F1243741076%2F</url>
    <content type="text"><![CDATA[可选型的概念 数据类型＋？将会构成一种新的类型，可选型，String?为字符串可选型，，在swift中，空的概念略有不同，java中，如果一个对象变量，没有指向，为null；一个int类型的变量如果没有初始化，值为0，null和0 意为没有，在swift中，空是一种完全独立的数据类型，nil的位置和Int，String的地位是一样的，他不是对象或者数据的一种特殊状态，而是一种新的对象。这也就意味着代码中(1)的部分是编译错误的，会提示，nil类型是不能和String类型进行的比较的，该设计的目的是为了使swift更具安全性，因为任何对象都不能设置为nil,就如同String类型的数据不能设置为int类型的数据，他们是完全不同的对象，可以避免潜在空指针的发生。 123456789101112131415161718192021222324//(1)var str = "abc"if(str == nil)&#123;&#125;//String? 为String可选型，他意味着这种类型，可以为nil,还是那句话，可选型和nil不是一个类型的特殊状态，他是一种新的类型。//2var optionalStr:String? = "hello"optionalStr = "world"print(optionalStr == nil) var greet = "hey"if let name = optionalStr&#123; greet = "hello \(name)";&#125;print(greet) if(optionalStr != nil)&#123; print("optional str is not nil")&#125; where与模式匹配1234567891011121314151617181920212223242526272829303132333435//switch中使用where语句let point = (3,3)switch point &#123; case let(x,y) where x == y: print("x == y") case let(x,y) where x == -y: print("x == -y") default: print("rst is \(point.0) , \(point.1)")&#125;//switch中使用运算符 let age = 19switch age&#123; case 10 ... 19: print("teenager") default: print("not teenager")&#125; //if中使用模式 if case 10...19 = age where age &gt; 18&#123; print("teenager and in colldge")&#125; //if中使用模式和where语句let vector = (4,0)if case (let x,0) = vector where x &gt; 2 &amp;&amp; x &lt; 5&#123; print("it is vector")&#125; //if中使用模式＋where+运算符 for case let i in 1 ... 100 where i % 3==0&#123; print("i is \(i)")&#125; guard关键字12345678910111213//guard else 防止数据错误，也可以认为是需要满足的一种先决条件//例如下面money&gt;price,capacity &gt; volume是必须满足的条件，简化语法，防止错误func buy(money:Int,price:Int,capacity:Int,volume:Int) -&gt; Bool&#123; guard money &gt; price else &#123; print("not money") return false &#125; guard capacity &gt; volume else&#123; print("not volume") return false &#125; return true&#125; String类型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//字符串var originStr = "this is str"originStr = "this is new str"//定义一个空字符串let emptyStr = ""//判空操作print(emptyStr.isEmpty)//合并字符串var rstStr = originStr + emptyStr//使用+=,此时rstStr必须是变量rstStr += originStr//字符串插值rstStr = "this is new str and insert \(100)"//转义字符 \//遍历字符串for c in originStr.characters&#123; print(c)&#125; //Characterlet cc:Character = "!"originStr.append(cc) //字符串长度，基于unicode码，也就是说不管是3个汉字或者3个字母，它的count都是3let englishLetter = "abc"let chinseLetter = "慕课网"let emojiLetter = "😢😢😢"let unicodeLetter = "\u&#123;1f60e&#125;\u&#123;0301&#125;"print(englishLetter.characters.count)print(chinseLetter.characters.count)print(emojiLetter.characters.count)print("enlish is \(englishLetter) chinse is \(chinseLetter) emoji is \(emojiLetter) unicode is \(unicodeLetter)") //索引访问字符串，需要使用String.Index类来访问//[startIndex,endIndex)let startIndex = originStr.startIndexlet endIndex = originStr.endIndexprint("index is \(startIndex) and content is \(originStr[startIndex])")//向后n个startIndex.advancedBy(6)//前面一个位置endIndex.predecessor()//后面一个位置startIndex.successor() //String的一些API//Range&lt;Index&gt;类型let range = startIndex.advancedBy(3) ..&lt; endIndexoriginStr.replaceRange(range, with: "!!!")originStr.appendContentsOf("xxx")originStr.insert("z", atIndex: originStr.endIndex) originStr.removeAtIndex(originStr.endIndex.predecessor()) originStr.removeRange(originStr.endIndex.advancedBy(-2)..&lt;originStr.endIndex) print("upper \(originStr.uppercaseString) low \(originStr.lowercaseString) First up \(originStr.capitalizedString)")originStr.containsString("")originStr.hasSuffix("")originStr.hasPrefix("") //NSString let s2 = NSString(format: "one third is %.2f",1.0/3.0)print("转换 \(s2 as String)") let nsStr:NSString = "one third is 0.33"nsStr.substringFromIndex(4)nsStr.substringFromIndex(3)nsStr.substringWithRange(NSMakeRange(4, 5)) let s6 = " --- Hello --- " as NSString//去掉空格和－print(s6.stringByTrimmingCharactersInSet(NSCharacterSet(charactersInString:" -"))]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[防止app闪白屏或闪黑屏]]></title>
    <url>%2Farticle%2F3133739946%2F</url>
    <content type="text"><![CDATA[App启动时需要加载应用进程，就算你的软件在 Appliation 中什么也没做仍旧会有延时，会显示白屏或者黑屏，很难看。本文主要介绍去掉闪屏，白屏或黑屏的几种方案。 透明 Theme 使用透明Theme解决，原理就是虽然程序启动了，但是没有显示出来，你看到的还是桌面，目前主流的产品都是用的这种方式，比如QQ，微信。缺点就是等待的时间长，造成程序启动慢的感觉。 1234&lt;style name="Theme.AppStartUseTransparent" parent="Theme.AppCompat.NoActionBar"&gt; &lt;item name="android:windowIsTranslucent"&gt;true&lt;/item&gt; &lt;item name="android:windowNoTitle"&gt;true&lt;/item&gt;&lt;/style&gt; 图片 Theme 使用图片Theme解决，原理就是设置一张背景图，在你的程序没有加载完成的时候会显示这张背景图，你也可以用shape自定义或者使用图片，优点就是启动很快，显示的效果取决于你的图片。 1234&lt;style name="Theme.AppStartUseDrawable" parent="Theme.AppCompat.NoActionBar"&gt; &lt;item name="android:windowBackground"&gt;@drawable/shape_maincolor&lt;/item&gt; &lt;item name="android:windowNoTitle"&gt;true&lt;/item&gt;&lt;/style&gt; 在 manifest.xml 使用 我是AppCompat的风格，你可以对parent＝“”做适当修改。 123456789 &lt;activity android:name=".activity.LoadingActivity" android:theme="@style/Theme.AppStartUseTransparent"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AndroidTips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView添加Header和Footer的基本原理]]></title>
    <url>%2Farticle%2F4007050602%2F</url>
    <content type="text"><![CDATA[介绍 采用的基本原理就是Header和Footer作为RecyclerView的一个Item，只是显示的方式特别一点，ListView实际也是这么做的所以添加了Header之后，数据的位置会错乱。 由于使用不同的LayoutManager时显示效果也不一样， 所以针对不同的LayoutManager需要做不同的操作。 分析一下，LinearLayoutManager比较简单，只需要将Header和Footer作为一项就可以了，GridLayoutManager和StaggeredGridLayoutManager在这个基础上还需要将Header和Footer所在的Item充满他所在的这一行。 变量和方法123456789101112131415161718//Header和Footer,以及对应的Typeprivate View mHeaderView;private View mFooterView;private int TYPE_HEADER = -1;private int TYPE_FOOTER = -2;//一些辅助的方法public int getHeaderCount() &#123; return isHasHeader() ? 1 : 0;&#125;private boolean isHasHeader() &#123; return mHeaderView != null;&#125;private boolean isHasFooter() &#123; return mFooterView != null;&#125; 根据是否有Header和Footer获取数据Size123456789101112//根据是否有Header和Footer返回不同的Size@Overridepublic int getItemCount() &#123; int pos = datas.size(); if (isHasHeader()) pos++; if (isHasFooter()) pos++; return pos;&#125; 根据是否有Header和Footer获取Type12345678910111213141516171819202122//获取item的type，基本逻辑是如果有header又是位于第一个的则返回HeaderType,如果pos超出了data的size，又是最后一个，则返回FooterType@Overridepublic int getItemViewType(int position) &#123; //如果没有header没有footer直接返回 if (!isHasHeader() &amp;&amp; !isHasFooter()) return datas.get(position).getRvType(); //有header且位置0 if (isHasHeader() &amp;&amp; position == 0) return TYPE_HEADER; //pos超出 if (isHasFooter() &amp;&amp; position == getItemCount() - 1) return TYPE_FOOTER; //如果有header,下标减一个 if (isHasHeader()) return datas.get(position - 1).getRvType(); else //没有header 按照原来的 return datas.get(position).getRvType();&#125; 根据是否有Header和Footer创建Holder123456789101112//根据返回的不同的type使用HeaderView和FooterView初始化Holder,至此已经可以对LinearLayoutManager添加Header和Footer@Overridepublic RvViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; RvViewHolder holder; if (isHasFooter() &amp;&amp; viewType == TYPE_FOOTER) &#123; holder = new RvFooterHolder(mFooterView); &#125; else if (isHasHeader() &amp;&amp; viewType == TYPE_HEADER) &#123; holder = new RvHeaderHolder(mHeaderView); &#125; else &#123; holder = new RvViewHolder(getInflateView(Res4Type.get(viewType).getResId(), return holder;&#125; LinearLayoutManager 由于LinearLayoutManager是连续排列的，所以只需要创建不同的holder就可以实现header+footer GridLayoutManager 首先如何知道是否是GridLayoutManager,重写onAttachedToRecyclerView方法获取Manager,调用gridLayoutManager.setSpanSizeLookup（）方法，设置他跨越的宽度。 12345678910111213141516171819202122@Overridepublic void onAttachedToRecyclerView(RecyclerView recyclerView) &#123; super.onAttachedToRecyclerView(recyclerView); Log.e("chendong","onAttachedToRecyclerView"); RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager(); if (layoutManager instanceof GridLayoutManager) &#123; final GridLayoutManager gridLayoutManager = (GridLayoutManager) layoutManager; gridLayoutManager.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() &#123; @Override public int getSpanSize(int position) &#123; return getItemViewType(position) == TYPE_HEADER || getItemViewType(position) == TYPE_FOOTER ? gridLayoutManager.getSpanCount() : 1; &#125; &#125;); return; &#125; //判断是不是StaggeredGridLayoutManager if(layoutManager instanceof StaggeredGridLayoutManager)&#123; isStaggeredGridLayoutManager = true; &#125;&#125; StaggeredGridLayoutManager 主要使用StaggeredGridLayoutManager.LayoutParams的 layoutParams.setFullSpan(true);方法设置 123456789101112131415161718192021222324252627282930@Overridepublic RvViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; RvViewHolder holder; if (isHasFooter() &amp;&amp; viewType == TYPE_FOOTER) &#123; holder = new RvFooterHolder(mFooterView); &#125; else if (isHasHeader() &amp;&amp; viewType == TYPE_HEADER) &#123; holder = new RvHeaderHolder(mHeaderView); &#125; else &#123; holder = new RvViewHolder(getInflateView(Res4Type.get(viewType).getResId(), parent)); if (clickListener != null) &#123; holder.setOnItemClickListener(clickListener); &#125; if (longClickListenter != null) &#123; holder.setOnItemLongClickListener(longClickListenter); &#125; &#125; //关键代码 if (isStaggeredGridLayoutManager &amp;&amp; (holder instanceof RvHeaderHolder || holder instanceof RvFooterHolder)) &#123; Log.e("chendong","瀑布流设置满行"); StaggeredGridLayoutManager.LayoutParams layoutParams = new StaggeredGridLayoutManager.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT); layoutParams.setFullSpan(true); holder.getParentView().setLayoutParams(layoutParams); &#125; bindListener4View(holder, viewType); return holder;&#125; QuickAdapter 最后贴一下整个QuickAdapter的源代码，涉及相关具体的类可以去这里查看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317package com.march.quickrvlibs;import android.content.Context;import android.support.v7.widget.GridLayoutManager;import android.support.v7.widget.RecyclerView;import android.support.v7.widget.StaggeredGridLayoutManager;import android.util.Log;import android.util.SparseArray;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import com.march.quickrvlibs.inter.OnRecyclerItemClickListener;import com.march.quickrvlibs.inter.OnRecyclerItemLongClickListener;import com.march.quickrvlibs.inter.RvQuickInterface;import java.util.Collections;import java.util.List;/** * Created by 陈栋 on 15/12/28. * 功能: */public abstract class RvQuickAdapter&lt;D extends RvQuickInterface&gt; extends RecyclerView.Adapter&lt;RvViewHolder&gt; &#123; protected List&lt;D&gt; datas; protected LayoutInflater mLayoutInflater; protected Context context; protected SparseArray&lt;RvAdapterConfig&gt; Res4Type; private OnRecyclerItemClickListener&lt;RvViewHolder&gt; clickListener; private OnRecyclerItemLongClickListener&lt;RvViewHolder&gt; longClickListenter; private View mHeaderView; private View mFooterView; private int TYPE_HEADER = -1; private int TYPE_FOOTER = -2; private int adapterId;//使用此标志来判断当前adapter的类型 private boolean isStaggeredGridLayoutManager = false; public int getAdapterId() &#123; return adapterId; &#125; /** * 设置adapterId标示 * @param adapterId adapter标示 */ public void setAdapterId(int adapterId) &#123; this.adapterId = adapterId; &#125; /** * 使用标记判断,是否是该adaper * @param adapter adapter * @return boolean */ public boolean isThisAdapter(RvQuickAdapter adapter) &#123; if (adapter == null) &#123; return false; &#125; else if (adapter.getAdapterId() == adapterId) &#123; return true; &#125; return false; &#125; /** * 多类型适配,需要调用addType()方法配置参数 * * @param context context * @param datas 数据源 */ public RvQuickAdapter(Context context, List&lt;D&gt; datas) &#123; this.datas = datas; this.mLayoutInflater = LayoutInflater.from(context); this.context = context; &#125; public RvQuickAdapter(Context context, D[] ds) &#123; Collections.addAll(datas, ds); this.mLayoutInflater = LayoutInflater.from(context); this.context = context; &#125; /** * 单类型适配 * * @param context context * @param datas 数据源 * @param res layout资源 */ public RvQuickAdapter(Context context, List&lt;D&gt; datas, int res) &#123; this.datas = datas; this.mLayoutInflater = LayoutInflater.from(context); this.context = context; this.Res4Type = new SparseArray&lt;&gt;(); Res4Type.put(0, new RvAdapterConfig(0, res)); &#125; public RvQuickAdapter(Context context, D[] ds, int res) &#123; Collections.addAll(datas, ds); this.mLayoutInflater = LayoutInflater.from(context); this.context = context; this.Res4Type = new SparseArray&lt;&gt;(); Res4Type.put(0, new RvAdapterConfig(0, res)); &#125; public void setClickListener(OnRecyclerItemClickListener&lt;RvViewHolder&gt; listener) &#123; if (listener != null) &#123; this.clickListener = listener; &#125; &#125; public void setLongClickListener(OnRecyclerItemLongClickListener&lt;RvViewHolder&gt; longClickListenter) &#123; if (longClickListenter != null) &#123; this.longClickListenter = longClickListenter; &#125; &#125; public void addHeader(View mHeaderView) &#123; this.mHeaderView = mHeaderView; &#125; public void addFooter(View mFooterView) &#123; this.mFooterView = mFooterView; &#125; public void addHeader(int mHeaderViewRes) &#123; this.mHeaderView = getInflateView(mHeaderViewRes, null); &#125; public void addFooter(int mFooterViewRes) &#123; this.mFooterView = getInflateView(mFooterViewRes, null); &#125; public View getInflateView(int resId, ViewGroup parent) &#123; return mLayoutInflater.inflate(resId, parent, false); &#125; @Override public RvViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; RvViewHolder holder; if (isHasFooter() &amp;&amp; viewType == TYPE_FOOTER) &#123; holder = new RvFooterHolder(mFooterView); &#125; else if (isHasHeader() &amp;&amp; viewType == TYPE_HEADER) &#123; holder = new RvHeaderHolder(mHeaderView); &#125; else &#123; holder = new RvViewHolder(getInflateView(Res4Type.get(viewType).getResId(), parent)); if (clickListener != null) &#123; holder.setOnItemClickListener(clickListener); &#125; if (longClickListenter != null) &#123; holder.setOnItemLongClickListener(longClickListenter); &#125; &#125; if (isStaggeredGridLayoutManager &amp;&amp; (holder instanceof RvHeaderHolder || holder instanceof RvFooterHolder)) &#123; Log.e("chendong","瀑布流设置满行"); StaggeredGridLayoutManager.LayoutParams layoutParams = new StaggeredGridLayoutManager.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT); layoutParams.setFullSpan(true); holder.getParentView().setLayoutParams(layoutParams); &#125; bindListener4View(holder, viewType); return holder; &#125; @Override public void onBindViewHolder(RvViewHolder holder, int position) &#123; if (isHasFooter() &amp;&amp; position == getItemCount() - 1) &#123; bindLisAndData4Footer((RvFooterHolder) holder); &#125; else if (isHasHeader() &amp;&amp; position == 0) &#123; bindLisAndData4Header((RvHeaderHolder) holder); &#125; else &#123; int pos = judgePos(position); bindData4View(holder, datas.get(pos), pos, datas.get(pos).getRvType()); &#125; &#125; @Override public int getItemViewType(int position) &#123; //如果没有header没有footer直接返回 if (!isHasHeader() &amp;&amp; !isHasFooter()) return datas.get(position).getRvType(); //有header且位置0 if (isHasHeader() &amp;&amp; position == 0) return TYPE_HEADER; //pos超出 if (isHasFooter() &amp;&amp; position == getItemCount() - 1) return TYPE_FOOTER; //如果有header,下标减一个 if (isHasHeader()) return datas.get(position - 1).getRvType(); else //没有header 按照原来的 return datas.get(position).getRvType(); &#125; private int judgePos(int pos) &#123; if (isHasHeader()) &#123; return pos - 1; &#125; else &#123; return pos; &#125; &#125; @Override public void onAttachedToRecyclerView(RecyclerView recyclerView) &#123; super.onAttachedToRecyclerView(recyclerView); Log.e("chendong","onAttachedToRecyclerView"); RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager(); if (layoutManager instanceof GridLayoutManager) &#123; final GridLayoutManager gridLayoutManager = (GridLayoutManager) layoutManager; gridLayoutManager.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() &#123; @Override public int getSpanSize(int position) &#123; return getItemViewType(position) == TYPE_HEADER || getItemViewType(position) == TYPE_FOOTER ? gridLayoutManager.getSpanCount() : 1; &#125; &#125;); return; &#125; if(layoutManager instanceof StaggeredGridLayoutManager)&#123; isStaggeredGridLayoutManager = true; &#125; &#125; /** * 绑定数据 * * @param holder ViewHolder数据持有者 * @param data 数据集 * @param pos 数据集中的位置 * @param type type */ public abstract void bindData4View(RvViewHolder holder, D data, int pos, int type); /** * 绑定监听器 * * @param holder ViewHolder数据持有者 * @param type type */ public void bindListener4View(RvViewHolder holder, int type) &#123; &#125; /** * 绑定header的数据 和 监听 * * @param holder header holder */ public void bindLisAndData4Header(RvHeaderHolder holder) &#123; &#125; /** * 绑定footer的数据和监听 * * @param holder footer holder */ public void bindLisAndData4Footer(RvFooterHolder holder) &#123; &#125; @Override public int getItemCount() &#123; int pos = datas.size(); if (isHasHeader()) pos++; if (isHasFooter()) pos++; return pos; &#125; public int getHeaderCount() &#123; return isHasHeader() ? 1 : 0; &#125; public int getDataPos(int pos) &#123; return pos - getHeaderCount(); &#125; private boolean isHasHeader() &#123; return mHeaderView != null; &#125; private boolean isHasFooter() &#123; return mFooterView != null; &#125; /** * @param type 数据的类型(如果有n种类型,那么type的值需要是0 ~ n-1) * @param resId 该类型对应的资源文件的id * @return QuickTypeAdapter */ public RvQuickAdapter&lt;D&gt; addType(int type, int resId) &#123; if (this.Res4Type == null) this.Res4Type = new SparseArray&lt;&gt;(); this.Res4Type.put(type, new RvAdapterConfig(type, resId)); return this; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Adapter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Adapter</tag>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汉字转换拼音]]></title>
    <url>%2Farticle%2F1637707051%2F</url>
    <content type="text"><![CDATA[进行汉字的字符串拼配,比较,排序的时候使用汉字很不方便,转换成拼音就可以进行首字母匹配搜索等工作了。 Api调用12345PinyinHelper.get().getPinYin("你好"));PinyinHelper.get().getPinYin("你bSfb");PinyinHelper.get().getPinYin("JHHihubbb"); 核心方法123456789101112131415161718192021//核心方法 /** * 唯一公开的方法 * * @param input 输入的文字 * @return 返回的汉字将会转化为大写英文, 如果是英文将会原样返回 */ public String getPinYin(String input) &#123; ArrayList&lt;Token&gt; tokens = get(input); StringBuilder sb = new StringBuilder(); if (tokens != null &amp;&amp; tokens.size() &gt; 0) &#123; for (Token token : tokens) &#123; if (Token.PINYIN == token.type) &#123; sb.append(token.target); &#125; else &#123; sb.append(token.source); &#125; &#125; &#125; return sb.toString(); &#125; 附源码一份123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532package com.march.libs.helper;/** * CdLibsTest com.march.libs.helper * Created by 陈栋 on 16/3/28. * 功能: */import android.text.TextUtils;import android.util.Log;import java.text.Collator;import java.util.ArrayList;import java.util.Locale;public class PinyinHelper &#123; private static final String TAG = "HanziToPinyin"; private static final boolean DEBUG = false; private static final char[] UNIHANS = &#123; '\u963f', '\u54ce', '\u5b89', '\u80ae', '\u51f9', '\u516b', '\u6300', '\u6273', '\u90a6', '\u52f9', '\u9642', '\u5954', '\u4f3b', '\u5c44', '\u8fb9', '\u706c', '\u618b', '\u6c43', '\u51ab', '\u7676', '\u5cec', '\u5693', '\u5072', '\u53c2', '\u4ed3', '\u64a1', '\u518a', '\u5d7e', '\u66fd', '\u66fe', '\u5c64', '\u53c9', '\u8286', '\u8fbf', '\u4f25', '\u6284', '\u8f66', '\u62bb', '\u6c88', '\u6c89', '\u9637', '\u5403', '\u5145', '\u62bd', '\u51fa', '\u6b3b', '\u63e3', '\u5ddb', '\u5205', '\u5439', '\u65fe', '\u9034', '\u5472', '\u5306', '\u51d1', '\u7c97', '\u6c46', '\u5d14', '\u90a8', '\u6413', '\u5491', '\u5446', '\u4e39', '\u5f53', '\u5200', '\u561a', '\u6265', '\u706f', '\u6c10', '\u55f2', '\u7538', '\u5201', '\u7239', '\u4e01', '\u4e1f', '\u4e1c', '\u543a', '\u53be', '\u8011', '\u8968', '\u5428', '\u591a', '\u59b8', '\u8bf6', '\u5940', '\u97a5', '\u513f', '\u53d1', '\u5e06', '\u531a', '\u98de', '\u5206', '\u4e30', '\u8985', '\u4ecf', '\u7d11', '\u4f15', '\u65ee', '\u4f85', '\u7518', '\u5188', '\u768b', '\u6208', '\u7ed9', '\u6839', '\u522f', '\u5de5', '\u52fe', '\u4f30', '\u74dc', '\u4e56', '\u5173', '\u5149', '\u5f52', '\u4e28', '\u5459', '\u54c8', '\u548d', '\u4f44', '\u592f', '\u8320', '\u8bc3', '\u9ed2', '\u62eb', '\u4ea8', '\u5677', '\u53ff', '\u9f41', '\u4e6f', '\u82b1', '\u6000', '\u72bf', '\u5ddf', '\u7070', '\u660f', '\u5419', '\u4e0c', '\u52a0', '\u620b', '\u6c5f', '\u827d', '\u9636', '\u5dfe', '\u5755', '\u5182', '\u4e29', '\u51e5', '\u59e2', '\u5658', '\u519b', '\u5494', '\u5f00', '\u520a', '\u5ffc', '\u5c3b', '\u533c', '\u808e', '\u52a5', '\u7a7a', '\u62a0', '\u625d', '\u5938', '\u84af', '\u5bbd', '\u5321', '\u4e8f', '\u5764', '\u6269', '\u5783', '\u6765', '\u5170', '\u5577', '\u635e', '\u808b', '\u52d2', '\u5d1a', '\u5215', '\u4fe9', '\u5941', '\u826f', '\u64a9', '\u5217', '\u62ce', '\u5222', '\u6e9c', '\u56d6', '\u9f99', '\u779c', '\u565c', '\u5a08', '\u7567', '\u62a1', '\u7f57', '\u5463', '\u5988', '\u57cb', '\u5ada', '\u7264', '\u732b', '\u4e48', '\u5445', '\u95e8', '\u753f', '\u54aa', '\u5b80', '\u55b5', '\u4e5c', '\u6c11', '\u540d', '\u8c2c', '\u6478', '\u54de', '\u6bea', '\u55ef', '\u62cf', '\u8149', '\u56e1', '\u56d4', '\u5b6c', '\u7592', '\u5a1e', '\u6041', '\u80fd', '\u59ae', '\u62c8', '\u5b22', '\u9e1f', '\u634f', '\u56dc', '\u5b81', '\u599e', '\u519c', '\u7fba', '\u5974', '\u597b', '\u759f', '\u9ec1', '\u90cd', '\u5594', '\u8bb4', '\u5991', '\u62cd', '\u7705', '\u4e53', '\u629b', '\u5478', '\u55b7', '\u5309', '\u4e15', '\u56e8', '\u527d', '\u6c15', '\u59d8', '\u4e52', '\u948b', '\u5256', '\u4ec6', '\u4e03', '\u6390', '\u5343', '\u545b', '\u6084', '\u767f', '\u4eb2', '\u72c5', '\u828e', '\u4e18', '\u533a', '\u5cd1', '\u7f3a', '\u590b', '\u5465', '\u7a63', '\u5a06', '\u60f9', '\u4eba', '\u6254', '\u65e5', '\u8338', '\u53b9', '\u909a', '\u633c', '\u5827', '\u5a51', '\u77a4', '\u637c', '\u4ee8', '\u6be2', '\u4e09', '\u6852', '\u63bb', '\u95aa', '\u68ee', '\u50e7', '\u6740', '\u7b5b', '\u5c71', '\u4f24', '\u5f30', '\u5962', '\u7533', '\u8398', '\u6552', '\u5347', '\u5c38', '\u53ce', '\u4e66', '\u5237', '\u8870', '\u95e9', '\u53cc', '\u8c01', '\u542e', '\u8bf4', '\u53b6', '\u5fea', '\u635c', '\u82cf', '\u72fb', '\u590a', '\u5b59', '\u5506', '\u4ed6', '\u56fc', '\u574d', '\u6c64', '\u5932', '\u5fd1', '\u71a5', '\u5254', '\u5929', '\u65eb', '\u5e16', '\u5385', '\u56f2', '\u5077', '\u51f8', '\u6e4d', '\u63a8', '\u541e', '\u4e47', '\u7a75', '\u6b6a', '\u5f2f', '\u5c23', '\u5371', '\u6637', '\u7fc1', '\u631d', '\u4e4c', '\u5915', '\u8672', '\u4eda', '\u4e61', '\u7071', '\u4e9b', '\u5fc3', '\u661f', '\u51f6', '\u4f11', '\u5401', '\u5405', '\u524a', '\u5743', '\u4e2b', '\u6079', '\u592e', '\u5e7a', '\u503b', '\u4e00', '\u56d9', '\u5e94', '\u54df', '\u4f63', '\u4f18', '\u625c', '\u56e6', '\u66f0', '\u6655', '\u7b60', '\u7b7c', '\u5e00', '\u707d', '\u5142', '\u5328', '\u50ae', '\u5219', '\u8d3c', '\u600e', '\u5897', '\u624e', '\u635a', '\u6cbe', '\u5f20', '\u957f', '\u9577', '\u4f4b', '\u8707', '\u8d1e', '\u4e89', '\u4e4b', '\u5cd9', '\u5ea2', '\u4e2d', '\u5dde', '\u6731', '\u6293', '\u62fd', '\u4e13', '\u5986', '\u96b9', '\u5b92', '\u5353', '\u4e72', '\u5b97', '\u90b9', '\u79df', '\u94bb', '\u539c', '\u5c0a', '\u6628', '\u5159', '\u9fc3', '\u9fc4',&#125;; private static final byte[][] PINYINS = &#123; &#123;65, 0, 0, 0, 0, 0&#125;, &#123;65, 73, 0, 0, 0, 0&#125;, &#123;65, 78, 0, 0, 0, 0&#125;, &#123;65, 78, 71, 0, 0, 0&#125;, &#123;65, 79, 0, 0, 0, 0&#125;, &#123;66, 65, 0, 0, 0, 0&#125;, &#123;66, 65, 73, 0, 0, 0&#125;, &#123;66, 65, 78, 0, 0, 0&#125;, &#123;66, 65, 78, 71, 0, 0&#125;, &#123;66, 65, 79, 0, 0, 0&#125;, &#123;66, 69, 73, 0, 0, 0&#125;, &#123;66, 69, 78, 0, 0, 0&#125;, &#123;66, 69, 78, 71, 0, 0&#125;, &#123;66, 73, 0, 0, 0, 0&#125;, &#123;66, 73, 65, 78, 0, 0&#125;, &#123;66, 73, 65, 79, 0, 0&#125;, &#123;66, 73, 69, 0, 0, 0&#125;, &#123;66, 73, 78, 0, 0, 0&#125;, &#123;66, 73, 78, 71, 0, 0&#125;, &#123;66, 79, 0, 0, 0, 0&#125;, &#123;66, 85, 0, 0, 0, 0&#125;, &#123;67, 65, 0, 0, 0, 0&#125;, &#123;67, 65, 73, 0, 0, 0&#125;, &#123;67, 65, 78, 0, 0, 0&#125;, &#123;67, 65, 78, 71, 0, 0&#125;, &#123;67, 65, 79, 0, 0, 0&#125;, &#123;67, 69, 0, 0, 0, 0&#125;, &#123;67, 69, 78, 0, 0, 0&#125;, &#123;67, 69, 78, 71, 0, 0&#125;, &#123;90, 69, 78, 71, 0, 0&#125;, &#123;67, 69, 78, 71, 0, 0&#125;, &#123;67, 72, 65, 0, 0, 0&#125;, &#123;67, 72, 65, 73, 0, 0&#125;, &#123;67, 72, 65, 78, 0, 0&#125;, &#123;67, 72, 65, 78, 71, 0&#125;, &#123;67, 72, 65, 79, 0, 0&#125;, &#123;67, 72, 69, 0, 0, 0&#125;, &#123;67, 72, 69, 78, 0, 0&#125;, &#123;83, 72, 69, 78, 0, 0&#125;, &#123;67, 72, 69, 78, 0, 0&#125;, &#123;67, 72, 69, 78, 71, 0&#125;, &#123;67, 72, 73, 0, 0, 0&#125;, &#123;67, 72, 79, 78, 71, 0&#125;, &#123;67, 72, 79, 85, 0, 0&#125;, &#123;67, 72, 85, 0, 0, 0&#125;, &#123;67, 72, 85, 65, 0, 0&#125;, &#123;67, 72, 85, 65, 73, 0&#125;, &#123;67, 72, 85, 65, 78, 0&#125;, &#123;67, 72, 85, 65, 78, 71&#125;, &#123;67, 72, 85, 73, 0, 0&#125;, &#123;67, 72, 85, 78, 0, 0&#125;, &#123;67, 72, 85, 79, 0, 0&#125;, &#123;67, 73, 0, 0, 0, 0&#125;, &#123;67, 79, 78, 71, 0, 0&#125;, &#123;67, 79, 85, 0, 0, 0&#125;, &#123;67, 85, 0, 0, 0, 0&#125;, &#123;67, 85, 65, 78, 0, 0&#125;, &#123;67, 85, 73, 0, 0, 0&#125;, &#123;67, 85, 78, 0, 0, 0&#125;, &#123;67, 85, 79, 0, 0, 0&#125;, &#123;68, 65, 0, 0, 0, 0&#125;, &#123;68, 65, 73, 0, 0, 0&#125;, &#123;68, 65, 78, 0, 0, 0&#125;, &#123;68, 65, 78, 71, 0, 0&#125;, &#123;68, 65, 79, 0, 0, 0&#125;, &#123;68, 69, 0, 0, 0, 0&#125;, &#123;68, 69, 78, 0, 0, 0&#125;, &#123;68, 69, 78, 71, 0, 0&#125;, &#123;68, 73, 0, 0, 0, 0&#125;, &#123;68, 73, 65, 0, 0, 0&#125;, &#123;68, 73, 65, 78, 0, 0&#125;, &#123;68, 73, 65, 79, 0, 0&#125;, &#123;68, 73, 69, 0, 0, 0&#125;, &#123;68, 73, 78, 71, 0, 0&#125;, &#123;68, 73, 85, 0, 0, 0&#125;, &#123;68, 79, 78, 71, 0, 0&#125;, &#123;68, 79, 85, 0, 0, 0&#125;, &#123;68, 85, 0, 0, 0, 0&#125;, &#123;68, 85, 65, 78, 0, 0&#125;, &#123;68, 85, 73, 0, 0, 0&#125;, &#123;68, 85, 78, 0, 0, 0&#125;, &#123;68, 85, 79, 0, 0, 0&#125;, &#123;69, 0, 0, 0, 0, 0&#125;, &#123;69, 73, 0, 0, 0, 0&#125;, &#123;69, 78, 0, 0, 0, 0&#125;, &#123;69, 78, 71, 0, 0, 0&#125;, &#123;69, 82, 0, 0, 0, 0&#125;, &#123;70, 65, 0, 0, 0, 0&#125;, &#123;70, 65, 78, 0, 0, 0&#125;, &#123;70, 65, 78, 71, 0, 0&#125;, &#123;70, 69, 73, 0, 0, 0&#125;, &#123;70, 69, 78, 0, 0, 0&#125;, &#123;70, 69, 78, 71, 0, 0&#125;, &#123;70, 73, 65, 79, 0, 0&#125;, &#123;70, 79, 0, 0, 0, 0&#125;, &#123;70, 79, 85, 0, 0, 0&#125;, &#123;70, 85, 0, 0, 0, 0&#125;, &#123;71, 65, 0, 0, 0, 0&#125;, &#123;71, 65, 73, 0, 0, 0&#125;, &#123;71, 65, 78, 0, 0, 0&#125;, &#123;71, 65, 78, 71, 0, 0&#125;, &#123;71, 65, 79, 0, 0, 0&#125;, &#123;71, 69, 0, 0, 0, 0&#125;, &#123;71, 69, 73, 0, 0, 0&#125;, &#123;71, 69, 78, 0, 0, 0&#125;, &#123;71, 69, 78, 71, 0, 0&#125;, &#123;71, 79, 78, 71, 0, 0&#125;, &#123;71, 79, 85, 0, 0, 0&#125;, &#123;71, 85, 0, 0, 0, 0&#125;, &#123;71, 85, 65, 0, 0, 0&#125;, &#123;71, 85, 65, 73, 0, 0&#125;, &#123;71, 85, 65, 78, 0, 0&#125;, &#123;71, 85, 65, 78, 71, 0&#125;, &#123;71, 85, 73, 0, 0, 0&#125;, &#123;71, 85, 78, 0, 0, 0&#125;, &#123;71, 85, 79, 0, 0, 0&#125;, &#123;72, 65, 0, 0, 0, 0&#125;, &#123;72, 65, 73, 0, 0, 0&#125;, &#123;72, 65, 78, 0, 0, 0&#125;, &#123;72, 65, 78, 71, 0, 0&#125;, &#123;72, 65, 79, 0, 0, 0&#125;, &#123;72, 69, 0, 0, 0, 0&#125;, &#123;72, 69, 73, 0, 0, 0&#125;, &#123;72, 69, 78, 0, 0, 0&#125;, &#123;72, 69, 78, 71, 0, 0&#125;, &#123;72, 77, 0, 0, 0, 0&#125;, &#123;72, 79, 78, 71, 0, 0&#125;, &#123;72, 79, 85, 0, 0, 0&#125;, &#123;72, 85, 0, 0, 0, 0&#125;, &#123;72, 85, 65, 0, 0, 0&#125;, &#123;72, 85, 65, 73, 0, 0&#125;, &#123;72, 85, 65, 78, 0, 0&#125;, &#123;72, 85, 65, 78, 71, 0&#125;, &#123;72, 85, 73, 0, 0, 0&#125;, &#123;72, 85, 78, 0, 0, 0&#125;, &#123;72, 85, 79, 0, 0, 0&#125;, &#123;74, 73, 0, 0, 0, 0&#125;, &#123;74, 73, 65, 0, 0, 0&#125;, &#123;74, 73, 65, 78, 0, 0&#125;, &#123;74, 73, 65, 78, 71, 0&#125;, &#123;74, 73, 65, 79, 0, 0&#125;, &#123;74, 73, 69, 0, 0, 0&#125;, &#123;74, 73, 78, 0, 0, 0&#125;, &#123;74, 73, 78, 71, 0, 0&#125;, &#123;74, 73, 79, 78, 71, 0&#125;, &#123;74, 73, 85, 0, 0, 0&#125;, &#123;74, 85, 0, 0, 0, 0&#125;, &#123;74, 85, 65, 78, 0, 0&#125;, &#123;74, 85, 69, 0, 0, 0&#125;, &#123;74, 85, 78, 0, 0, 0&#125;, &#123;75, 65, 0, 0, 0, 0&#125;, &#123;75, 65, 73, 0, 0, 0&#125;, &#123;75, 65, 78, 0, 0, 0&#125;, &#123;75, 65, 78, 71, 0, 0&#125;, &#123;75, 65, 79, 0, 0, 0&#125;, &#123;75, 69, 0, 0, 0, 0&#125;, &#123;75, 69, 78, 0, 0, 0&#125;, &#123;75, 69, 78, 71, 0, 0&#125;, &#123;75, 79, 78, 71, 0, 0&#125;, &#123;75, 79, 85, 0, 0, 0&#125;, &#123;75, 85, 0, 0, 0, 0&#125;, &#123;75, 85, 65, 0, 0, 0&#125;, &#123;75, 85, 65, 73, 0, 0&#125;, &#123;75, 85, 65, 78, 0, 0&#125;, &#123;75, 85, 65, 78, 71, 0&#125;, &#123;75, 85, 73, 0, 0, 0&#125;, &#123;75, 85, 78, 0, 0, 0&#125;, &#123;75, 85, 79, 0, 0, 0&#125;, &#123;76, 65, 0, 0, 0, 0&#125;, &#123;76, 65, 73, 0, 0, 0&#125;, &#123;76, 65, 78, 0, 0, 0&#125;, &#123;76, 65, 78, 71, 0, 0&#125;, &#123;76, 65, 79, 0, 0, 0&#125;, &#123;76, 69, 0, 0, 0, 0&#125;, &#123;76, 69, 73, 0, 0, 0&#125;, &#123;76, 69, 78, 71, 0, 0&#125;, &#123;76, 73, 0, 0, 0, 0&#125;, &#123;76, 73, 65, 0, 0, 0&#125;, &#123;76, 73, 65, 78, 0, 0&#125;, &#123;76, 73, 65, 78, 71, 0&#125;, &#123;76, 73, 65, 79, 0, 0&#125;, &#123;76, 73, 69, 0, 0, 0&#125;, &#123;76, 73, 78, 0, 0, 0&#125;, &#123;76, 73, 78, 71, 0, 0&#125;, &#123;76, 73, 85, 0, 0, 0&#125;, &#123;76, 79, 0, 0, 0, 0&#125;, &#123;76, 79, 78, 71, 0, 0&#125;, &#123;76, 79, 85, 0, 0, 0&#125;, &#123;76, 85, 0, 0, 0, 0&#125;, &#123;76, 85, 65, 78, 0, 0&#125;, &#123;76, 85, 69, 0, 0, 0&#125;, &#123;76, 85, 78, 0, 0, 0&#125;, &#123;76, 85, 79, 0, 0, 0&#125;, &#123;77, 0, 0, 0, 0, 0&#125;, &#123;77, 65, 0, 0, 0, 0&#125;, &#123;77, 65, 73, 0, 0, 0&#125;, &#123;77, 65, 78, 0, 0, 0&#125;, &#123;77, 65, 78, 71, 0, 0&#125;, &#123;77, 65, 79, 0, 0, 0&#125;, &#123;77, 69, 0, 0, 0, 0&#125;, &#123;77, 69, 73, 0, 0, 0&#125;, &#123;77, 69, 78, 0, 0, 0&#125;, &#123;77, 69, 78, 71, 0, 0&#125;, &#123;77, 73, 0, 0, 0, 0&#125;, &#123;77, 73, 65, 78, 0, 0&#125;, &#123;77, 73, 65, 79, 0, 0&#125;, &#123;77, 73, 69, 0, 0, 0&#125;, &#123;77, 73, 78, 0, 0, 0&#125;, &#123;77, 73, 78, 71, 0, 0&#125;, &#123;77, 73, 85, 0, 0, 0&#125;, &#123;77, 79, 0, 0, 0, 0&#125;, &#123;77, 79, 85, 0, 0, 0&#125;, &#123;77, 85, 0, 0, 0, 0&#125;, &#123;78, 0, 0, 0, 0, 0&#125;, &#123;78, 65, 0, 0, 0, 0&#125;, &#123;78, 65, 73, 0, 0, 0&#125;, &#123;78, 65, 78, 0, 0, 0&#125;, &#123;78, 65, 78, 71, 0, 0&#125;, &#123;78, 65, 79, 0, 0, 0&#125;, &#123;78, 69, 0, 0, 0, 0&#125;, &#123;78, 69, 73, 0, 0, 0&#125;, &#123;78, 69, 78, 0, 0, 0&#125;, &#123;78, 69, 78, 71, 0, 0&#125;, &#123;78, 73, 0, 0, 0, 0&#125;, &#123;78, 73, 65, 78, 0, 0&#125;, &#123;78, 73, 65, 78, 71, 0&#125;, &#123;78, 73, 65, 79, 0, 0&#125;, &#123;78, 73, 69, 0, 0, 0&#125;, &#123;78, 73, 78, 0, 0, 0&#125;, &#123;78, 73, 78, 71, 0, 0&#125;, &#123;78, 73, 85, 0, 0, 0&#125;, &#123;78, 79, 78, 71, 0, 0&#125;, &#123;78, 79, 85, 0, 0, 0&#125;, &#123;78, 85, 0, 0, 0, 0&#125;, &#123;78, 85, 65, 78, 0, 0&#125;, &#123;78, 85, 69, 0, 0, 0&#125;, &#123;78, 85, 78, 0, 0, 0&#125;, &#123;78, 85, 79, 0, 0, 0&#125;, &#123;79, 0, 0, 0, 0, 0&#125;, &#123;79, 85, 0, 0, 0, 0&#125;, &#123;80, 65, 0, 0, 0, 0&#125;, &#123;80, 65, 73, 0, 0, 0&#125;, &#123;80, 65, 78, 0, 0, 0&#125;, &#123;80, 65, 78, 71, 0, 0&#125;, &#123;80, 65, 79, 0, 0, 0&#125;, &#123;80, 69, 73, 0, 0, 0&#125;, &#123;80, 69, 78, 0, 0, 0&#125;, &#123;80, 69, 78, 71, 0, 0&#125;, &#123;80, 73, 0, 0, 0, 0&#125;, &#123;80, 73, 65, 78, 0, 0&#125;, &#123;80, 73, 65, 79, 0, 0&#125;, &#123;80, 73, 69, 0, 0, 0&#125;, &#123;80, 73, 78, 0, 0, 0&#125;, &#123;80, 73, 78, 71, 0, 0&#125;, &#123;80, 79, 0, 0, 0, 0&#125;, &#123;80, 79, 85, 0, 0, 0&#125;, &#123;80, 85, 0, 0, 0, 0&#125;, &#123;81, 73, 0, 0, 0, 0&#125;, &#123;81, 73, 65, 0, 0, 0&#125;, &#123;81, 73, 65, 78, 0, 0&#125;, &#123;81, 73, 65, 78, 71, 0&#125;, &#123;81, 73, 65, 79, 0, 0&#125;, &#123;81, 73, 69, 0, 0, 0&#125;, &#123;81, 73, 78, 0, 0, 0&#125;, &#123;81, 73, 78, 71, 0, 0&#125;, &#123;81, 73, 79, 78, 71, 0&#125;, &#123;81, 73, 85, 0, 0, 0&#125;, &#123;81, 85, 0, 0, 0, 0&#125;, &#123;81, 85, 65, 78, 0, 0&#125;, &#123;81, 85, 69, 0, 0, 0&#125;, &#123;81, 85, 78, 0, 0, 0&#125;, &#123;82, 65, 78, 0, 0, 0&#125;, &#123;82, 65, 78, 71, 0, 0&#125;, &#123;82, 65, 79, 0, 0, 0&#125;, &#123;82, 69, 0, 0, 0, 0&#125;, &#123;82, 69, 78, 0, 0, 0&#125;, &#123;82, 69, 78, 71, 0, 0&#125;, &#123;82, 73, 0, 0, 0, 0&#125;, &#123;82, 79, 78, 71, 0, 0&#125;, &#123;82, 79, 85, 0, 0, 0&#125;, &#123;82, 85, 0, 0, 0, 0&#125;, &#123;82, 85, 65, 0, 0, 0&#125;, &#123;82, 85, 65, 78, 0, 0&#125;, &#123;82, 85, 73, 0, 0, 0&#125;, &#123;82, 85, 78, 0, 0, 0&#125;, &#123;82, 85, 79, 0, 0, 0&#125;, &#123;83, 65, 0, 0, 0, 0&#125;, &#123;83, 65, 73, 0, 0, 0&#125;, &#123;83, 65, 78, 0, 0, 0&#125;, &#123;83, 65, 78, 71, 0, 0&#125;, &#123;83, 65, 79, 0, 0, 0&#125;, &#123;83, 69, 0, 0, 0, 0&#125;, &#123;83, 69, 78, 0, 0, 0&#125;, &#123;83, 69, 78, 71, 0, 0&#125;, &#123;83, 72, 65, 0, 0, 0&#125;, &#123;83, 72, 65, 73, 0, 0&#125;, &#123;83, 72, 65, 78, 0, 0&#125;, &#123;83, 72, 65, 78, 71, 0&#125;, &#123;83, 72, 65, 79, 0, 0&#125;, &#123;83, 72, 69, 0, 0, 0&#125;, &#123;83, 72, 69, 78, 0, 0&#125;, &#123;88, 73, 78, 0, 0, 0&#125;, &#123;83, 72, 69, 78, 0, 0&#125;, &#123;83, 72, 69, 78, 71, 0&#125;, &#123;83, 72, 73, 0, 0, 0&#125;, &#123;83, 72, 79, 85, 0, 0&#125;, &#123;83, 72, 85, 0, 0, 0&#125;, &#123;83, 72, 85, 65, 0, 0&#125;, &#123;83, 72, 85, 65, 73, 0&#125;, &#123;83, 72, 85, 65, 78, 0&#125;, &#123;83, 72, 85, 65, 78, 71&#125;, &#123;83, 72, 85, 73, 0, 0&#125;, &#123;83, 72, 85, 78, 0, 0&#125;, &#123;83, 72, 85, 79, 0, 0&#125;, &#123;83, 73, 0, 0, 0, 0&#125;, &#123;83, 79, 78, 71, 0, 0&#125;, &#123;83, 79, 85, 0, 0, 0&#125;, &#123;83, 85, 0, 0, 0, 0&#125;, &#123;83, 85, 65, 78, 0, 0&#125;, &#123;83, 85, 73, 0, 0, 0&#125;, &#123;83, 85, 78, 0, 0, 0&#125;, &#123;83, 85, 79, 0, 0, 0&#125;, &#123;84, 65, 0, 0, 0, 0&#125;, &#123;84, 65, 73, 0, 0, 0&#125;, &#123;84, 65, 78, 0, 0, 0&#125;, &#123;84, 65, 78, 71, 0, 0&#125;, &#123;84, 65, 79, 0, 0, 0&#125;, &#123;84, 69, 0, 0, 0, 0&#125;, &#123;84, 69, 78, 71, 0, 0&#125;, &#123;84, 73, 0, 0, 0, 0&#125;, &#123;84, 73, 65, 78, 0, 0&#125;, &#123;84, 73, 65, 79, 0, 0&#125;, &#123;84, 73, 69, 0, 0, 0&#125;, &#123;84, 73, 78, 71, 0, 0&#125;, &#123;84, 79, 78, 71, 0, 0&#125;, &#123;84, 79, 85, 0, 0, 0&#125;, &#123;84, 85, 0, 0, 0, 0&#125;, &#123;84, 85, 65, 78, 0, 0&#125;, &#123;84, 85, 73, 0, 0, 0&#125;, &#123;84, 85, 78, 0, 0, 0&#125;, &#123;84, 85, 79, 0, 0, 0&#125;, &#123;87, 65, 0, 0, 0, 0&#125;, &#123;87, 65, 73, 0, 0, 0&#125;, &#123;87, 65, 78, 0, 0, 0&#125;, &#123;87, 65, 78, 71, 0, 0&#125;, &#123;87, 69, 73, 0, 0, 0&#125;, &#123;87, 69, 78, 0, 0, 0&#125;, &#123;87, 69, 78, 71, 0, 0&#125;, &#123;87, 79, 0, 0, 0, 0&#125;, &#123;87, 85, 0, 0, 0, 0&#125;, &#123;88, 73, 0, 0, 0, 0&#125;, &#123;88, 73, 65, 0, 0, 0&#125;, &#123;88, 73, 65, 78, 0, 0&#125;, &#123;88, 73, 65, 78, 71, 0&#125;, &#123;88, 73, 65, 79, 0, 0&#125;, &#123;88, 73, 69, 0, 0, 0&#125;, &#123;88, 73, 78, 0, 0, 0&#125;, &#123;88, 73, 78, 71, 0, 0&#125;, &#123;88, 73, 79, 78, 71, 0&#125;, &#123;88, 73, 85, 0, 0, 0&#125;, &#123;88, 85, 0, 0, 0, 0&#125;, &#123;88, 85, 65, 78, 0, 0&#125;, &#123;88, 85, 69, 0, 0, 0&#125;, &#123;88, 85, 78, 0, 0, 0&#125;, &#123;89, 65, 0, 0, 0, 0&#125;, &#123;89, 65, 78, 0, 0, 0&#125;, &#123;89, 65, 78, 71, 0, 0&#125;, &#123;89, 65, 79, 0, 0, 0&#125;, &#123;89, 69, 0, 0, 0, 0&#125;, &#123;89, 73, 0, 0, 0, 0&#125;, &#123;89, 73, 78, 0, 0, 0&#125;, &#123;89, 73, 78, 71, 0, 0&#125;, &#123;89, 79, 0, 0, 0, 0&#125;, &#123;89, 79, 78, 71, 0, 0&#125;, &#123;89, 79, 85, 0, 0, 0&#125;, &#123;89, 85, 0, 0, 0, 0&#125;, &#123;89, 85, 65, 78, 0, 0&#125;, &#123;89, 85, 69, 0, 0, 0&#125;, &#123;89, 85, 78, 0, 0, 0&#125;, &#123;74, 85, 78, 0, 0, 0&#125;, &#123;89, 85, 78, 0, 0, 0&#125;, &#123;90, 65, 0, 0, 0, 0&#125;, &#123;90, 65, 73, 0, 0, 0&#125;, &#123;90, 65, 78, 0, 0, 0&#125;, &#123;90, 65, 78, 71, 0, 0&#125;, &#123;90, 65, 79, 0, 0, 0&#125;, &#123;90, 69, 0, 0, 0, 0&#125;, &#123;90, 69, 73, 0, 0, 0&#125;, &#123;90, 69, 78, 0, 0, 0&#125;, &#123;90, 69, 78, 71, 0, 0&#125;, &#123;90, 72, 65, 0, 0, 0&#125;, &#123;90, 72, 65, 73, 0, 0&#125;, &#123;90, 72, 65, 78, 0, 0&#125;, &#123;90, 72, 65, 78, 71, 0&#125;, &#123;67, 72, 65, 78, 71, 0&#125;, &#123;90, 72, 65, 78, 71, 0&#125;, &#123;90, 72, 65, 79, 0, 0&#125;, &#123;90, 72, 69, 0, 0, 0&#125;, &#123;90, 72, 69, 78, 0, 0&#125;, &#123;90, 72, 69, 78, 71, 0&#125;, &#123;90, 72, 73, 0, 0, 0&#125;, &#123;83, 72, 73, 0, 0, 0&#125;, &#123;90, 72, 73, 0, 0, 0&#125;, &#123;90, 72, 79, 78, 71, 0&#125;, &#123;90, 72, 79, 85, 0, 0&#125;, &#123;90, 72, 85, 0, 0, 0&#125;, &#123;90, 72, 85, 65, 0, 0&#125;, &#123;90, 72, 85, 65, 73, 0&#125;, &#123;90, 72, 85, 65, 78, 0&#125;, &#123;90, 72, 85, 65, 78, 71&#125;, &#123;90, 72, 85, 73, 0, 0&#125;, &#123;90, 72, 85, 78, 0, 0&#125;, &#123;90, 72, 85, 79, 0, 0&#125;, &#123;90, 73, 0, 0, 0, 0&#125;, &#123;90, 79, 78, 71, 0, 0&#125;, &#123;90, 79, 85, 0, 0, 0&#125;, &#123;90, 85, 0, 0, 0, 0&#125;, &#123;90, 85, 65, 78, 0, 0&#125;, &#123;90, 85, 73, 0, 0, 0&#125;, &#123;90, 85, 78, 0, 0, 0&#125;, &#123;90, 85, 79, 0, 0, 0&#125;, &#123;0, 0, 0, 0, 0, 0&#125;, &#123;83, 72, 65, 78, 0, 0&#125;, &#123;0, 0, 0, 0, 0, 0&#125;,&#125;; /** * First and last Chinese character with known Pinyin according to zh collation */ private static final String FIRST_PINYIN_UNIHAN = "\u963F"; private static final String LAST_PINYIN_UNIHAN = "\u9FFF"; private static final Collator COLLATOR = Collator.getInstance(Locale.CHINA); private static PinyinHelper sInstance; private final boolean mHasChinaCollator; public static class Token &#123; /** * Separator between target string for each source char */ public static final String SEPARATOR = " "; public static final int LATIN = 1; public static final int PINYIN = 2; public static final int UNKNOWN = 3; public Token() &#123; &#125; public Token(int type, String source, String target) &#123; this.type = type; this.source = source; this.target = target; &#125; /** * Type of this token, ASCII, PINYIN or UNKNOWN. */ public int type; /** * Original string before translation. */ public String source; /** * Translated string of source. For Han, target is corresponding Pinyin. Otherwise target is * original string in source. */ public String target; &#125; protected PinyinHelper(boolean hasChinaCollator) &#123; mHasChinaCollator = hasChinaCollator; &#125; public static PinyinHelper get() &#123; synchronized (PinyinHelper.class) &#123; if (sInstance != null) &#123; return sInstance; &#125; final Locale locale[] = Collator.getAvailableLocales(); for (int i = 0; i &lt; locale.length; i++) &#123; if (locale[i].equals(Locale.CHINA)) &#123; // Do self validation just once. if (DEBUG) &#123; Log.d(TAG, "Self validation. Result: " + doSelfValidation()); &#125; sInstance = new PinyinHelper(true); return sInstance; &#125; &#125; sInstance = new PinyinHelper(true); return sInstance; &#125; &#125; private static boolean doSelfValidation() &#123; char lastChar = UNIHANS[0]; String lastString = Character.toString(lastChar); for (char c : UNIHANS) &#123; if (lastChar == c) &#123; continue; &#125; final String curString = Character.toString(c); int cmp = COLLATOR.compare(lastString, curString); if (cmp &gt;= 0) &#123; return false; &#125; lastString = curString; &#125; return true; &#125; private Token getToken(char character) &#123; Token token = new Token(); final String letter = Character.toString(character); token.source = letter; int offset = -1; int cmp; if (character &lt; 256) &#123; token.type = Token.LATIN; token.target = letter; return token; &#125; else &#123; cmp = COLLATOR.compare(letter, FIRST_PINYIN_UNIHAN); if (cmp &lt; 0) &#123; token.type = Token.UNKNOWN; token.target = letter; return token; &#125; else if (cmp == 0) &#123; token.type = Token.PINYIN; offset = 0; &#125; else &#123; cmp = COLLATOR.compare(letter, LAST_PINYIN_UNIHAN); if (cmp &gt; 0) &#123; token.type = Token.UNKNOWN; token.target = letter; return token; &#125; else if (cmp == 0) &#123; token.type = Token.PINYIN; offset = UNIHANS.length - 1; &#125; &#125; &#125; token.type = Token.PINYIN; if (offset &lt; 0) &#123; int begin = 0; int end = UNIHANS.length - 1; while (begin &lt;= end) &#123; offset = (begin + end) / 2; final String unihan = Character.toString(UNIHANS[offset]); cmp = COLLATOR.compare(letter, unihan); if (cmp == 0) &#123; break; &#125; else if (cmp &gt; 0) &#123; begin = offset + 1; &#125; else &#123; end = offset - 1; &#125; &#125; &#125; if (cmp &lt; 0) &#123; offset--; &#125; StringBuilder pinyin = new StringBuilder(); for (int j = 0; j &lt; PINYINS[offset].length &amp;&amp; PINYINS[offset][j] != 0; j++) &#123; pinyin.append((char) PINYINS[offset][j]); &#125; token.target = pinyin.toString(); if (TextUtils.isEmpty(token.target)) &#123; token.type = Token.UNKNOWN; token.target = token.source; &#125; return token; &#125; private ArrayList&lt;Token&gt; get(final String input) &#123; ArrayList&lt;Token&gt; tokens = new ArrayList&lt;Token&gt;(); if (!mHasChinaCollator || TextUtils.isEmpty(input)) &#123; // return empty tokens. return tokens; &#125; final int inputLength = input.length(); final StringBuilder sb = new StringBuilder(); int tokenType = Token.LATIN; for (int i = 0; i &lt; inputLength; i++) &#123; final char character = input.charAt(i); if (character == ' ') &#123; if (sb.length() &gt; 0) &#123; addToken(sb, tokens, tokenType); &#125; &#125; else if (character &lt; 256) &#123; if (tokenType != Token.LATIN &amp;&amp; sb.length() &gt; 0) &#123; addToken(sb, tokens, tokenType); &#125; tokenType = Token.LATIN; sb.append(character); &#125; else &#123; Token t = getToken(character); if (t.type == Token.PINYIN) &#123; if (sb.length() &gt; 0) &#123; addToken(sb, tokens, tokenType); &#125; tokens.add(t); tokenType = Token.PINYIN; &#125; else &#123; if (tokenType != t.type &amp;&amp; sb.length() &gt; 0) &#123; addToken(sb, tokens, tokenType); &#125; tokenType = t.type; sb.append(character); &#125; &#125; &#125; if (sb.length() &gt; 0) &#123; addToken(sb, tokens, tokenType); &#125; return tokens; &#125; private void addToken( final StringBuilder sb, final ArrayList&lt;Token&gt; tokens, final int tokenType) &#123; String str = sb.toString(); tokens.add(new Token(tokenType, str, str)); sb.setLength(0); &#125; /** * 唯一公开的方法 * * @param input 输入的文字 * @return 返回的汉字将会转化为大写英文, 如果是英文将会原样返回 */ public String getPinYin(String input) &#123; ArrayList&lt;Token&gt; tokens = get(input); StringBuilder sb = new StringBuilder(); if (tokens != null &amp;&amp; tokens.size() &gt; 0) &#123; for (Token token : tokens) &#123; if (Token.PINYIN == token.type) &#123; sb.append(token.target); &#125; else &#123; sb.append(token.source); &#125; &#125; &#125; return sb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android系统分享的注册和调起]]></title>
    <url>%2Farticle%2F3733894393%2F</url>
    <content type="text"><![CDATA[系统相册照片长按时会弹出分享发送选项，可以选择分享到QQ，微信等，本文主要介绍： 如何将自己的应用注册到系统分享中，使用户可以将照片视频文件等发送到自己的应用中。 如何接受解析系统分享发送过来的数据。 如何唤醒系统分享，分享照片视频文件到别的应用。 注册系统的分享需要在 AndroidManifest.xml 文件声明 &lt;intent-filter&gt;，使得你可以在用户点击分享/发送按钮时调起你的应用，将图片和文字等分享到你的App。 关于 mimeType 的相关类型，请查看 MimeUtils.java 文件。 12345678910111213141516171819&lt;activity android:name=".activity.HandleShareActivity"&gt; &lt;intent-filter&gt; &lt;!--接受单个文件分享--&gt; &lt;action android:name="android.intent.action.SEND"/&gt; &lt;!--接受多个文件分享--&gt; &lt;action android:name="android.intent.action.SEND_MULTIPLE"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;!--接受图片类文件分享 image/jpeg" "image/bmp" "image/gif" "image/jpg" "image/png"--&gt; &lt;data android:mimeType="image/*"/&gt; &lt;!--接受文本分享 text/plain--&gt; &lt;data android:mimeType="text/*"/&gt; &lt;!--接受视频分享 video/wav video/mp4--&gt; &lt;data android:mimeType="video/*"/&gt; &lt;!--接受声音文件分享--&gt; &lt;data android:mimeType="audio/*"/&gt; &lt;!--接受压缩文件和其他各种文件分享--&gt; &lt;data android:mimeType="application/*"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 接受分享的数据当直接长按选中某些文本分享时拿到的数据有些不一样，是存储在 Intent.EXTRA_TEXT 中的，因此单独处理一下。 12345678910111213141516171819/** * 处理分享页面发来的intent */public static void handleIntent(Activity context) &#123; Intent intent = context.getIntent(); String type = intent.getType(); if (type == null) return; // 当文件格式无法识别或选择了多种类型的文件时，type会变成 */* LogUtils.e("type " + type); //type可能为的类型是 image/* | video/* | audio/* | text/* | application/* | */* if (type.startsWith("text") &amp;&amp; intent.getStringExtra(Intent.EXTRA_TEXT) != null) &#123; // 当直接选中文本分享时，会存放在EXTRA_TEXT里面，选择文本文件时，仍然存放在EXTRA_STREAM里面 LogUtils.e("获取到分享的文本 " + intent.getStringExtra(Intent.EXTRA_TEXT)); &#125; else &#123; List&lt;String&gt; sharePaths = getSharePaths(context, intent); LogUtils.e("获取到分享的文件的路径 " + sharePaths.toString()); &#125;&#125; 区分多个文件和单个文件分享，获取分享过来的路径列表 123456789101112131415161718192021222324252627282930/** * 获取分享过来的路径 * * @param context 上下文 * @param intent intent * @return 路径列表 */private static List&lt;String&gt; getSharePaths(Context context, Intent intent) &#123; String action = intent.getAction(); List&lt;String&gt; paths = new ArrayList&lt;&gt;(); // 单个文件 if (Intent.ACTION_SEND.equals(action)) &#123; Uri imageUri = intent.getParcelableExtra(Intent.EXTRA_STREAM); if (imageUri != null) &#123; String realPathFromURI = getRealPathFromURI(context, imageUri); if (realPathFromURI != null) paths.add(realPathFromURI); &#125; &#125; // 多个文件 else if (Intent.ACTION_SEND_MULTIPLE.equals(action)) &#123; ArrayList&lt;Uri&gt; imageUris = intent.getParcelableArrayListExtra(Intent.EXTRA_STREAM); if (imageUris != null) &#123; for (Uri uri : imageUris) &#123; paths.add(getRealPathFromURI(context, uri)); &#125; &#125; &#125; return paths;&#125; 如何从 uri 中获取存储路径，将 uri 进行转换。 123456789101112131415161718192021222324252627/** * 从uri获取path * * @param uri uri * @return path */private static String getRealPathFromURI(Context context, Uri uri) &#123; final String scheme = uri.getScheme(); String data = null; if (ContentResolver.SCHEME_FILE.equals(scheme)) &#123; data = uri.getPath(); &#125; else if (ContentResolver.SCHEME_CONTENT.equals(scheme)) &#123; Cursor cursor = context.getContentResolver() .query(uri, new String[]&#123;MediaStore.Images.ImageColumns.DATA&#125; , null, null, null); if (null != cursor) &#123; if (cursor.moveToFirst()) &#123; int index = cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA) if (index &gt; -1) &#123; data = cursor.getString(index); &#125; &#125; cursor.close(); &#125; &#125; return data;&#125; 唤醒系统分享12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 分享文字 * * @param context 上下文 * @param title 文字标题 * @param content 文字内容 */public static void shareText(Context context, String title, String content) &#123; Intent shareIntent = new Intent(); shareIntent.setAction(Intent.ACTION_SEND); shareIntent.putExtra(Intent.EXTRA_TEXT, content); shareIntent.putExtra(Intent.EXTRA_TITLE, title); shareIntent.setType("text/plain"); //设置分享列表的标题，并且每次都显示分享列表 context.startActivity(Intent.createChooser(shareIntent, "分享到"));&#125;/** * 分享单张图片 * * @param context 上下文 * @param path 图片的路径 */public static void shareImage(Context context, String path) &#123; //由文件得到uri Uri imageUri = Uri.fromFile(new File(path)); Intent shareIntent = new Intent(); shareIntent.setAction(Intent.ACTION_SEND); shareIntent.putExtra(Intent.EXTRA_STREAM, imageUri); shareIntent.setType("image/*"); context.startActivity(Intent.createChooser(shareIntent, "分享到"));&#125;/** * 分享多张图片 * * @param context 上下文 * @param paths 路径的集合 */public static void shareImages(Context context, List&lt;String&gt; paths) &#123; ArrayList&lt;Uri&gt; uriList = new ArrayList&lt;&gt;(); for (String path : paths) &#123; uriList.add(Uri.fromFile(new File(path))); &#125; Intent shareIntent = new Intent(); shareIntent.setAction(Intent.ACTION_SEND_MULTIPLE); shareIntent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, uriList); shareIntent.setType("image/*"); context.startActivity(Intent.createChooser(shareIntent, "分享到"));&#125; 附源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141/** * CreateAt : 16/8/13 * Describe : 唤醒系统分享 * * @author chendong */public class ShareUtils &#123; /** * 分享文字 * * @param context 上下文 * @param title 文字标题 * @param content 文字内容 */ public static void shareText(Context context, String title, String content) &#123; Intent shareIntent = new Intent(); shareIntent.setAction(Intent.ACTION_SEND); shareIntent.putExtra(Intent.EXTRA_TEXT, content); shareIntent.putExtra(Intent.EXTRA_TITLE, title); shareIntent.setType("text/plain"); //设置分享列表的标题，并且每次都显示分享列表 context.startActivity(Intent.createChooser(shareIntent, "分享到")); &#125; /** * 分享单张图片 * * @param context 上下文 * @param path 图片的路径 */ public static void shareImage(Context context, String path) &#123; //由文件得到uri Uri imageUri = Uri.fromFile(new File(path)); Intent shareIntent = new Intent(); shareIntent.setAction(Intent.ACTION_SEND); shareIntent.putExtra(Intent.EXTRA_STREAM, imageUri); shareIntent.setType("image/*"); context.startActivity(Intent.createChooser(shareIntent, "分享到")); &#125; /** * 分享多张图片 * * @param context 上下文 * @param paths 路径的集合 */ public static void shareImages(Context context, List&lt;String&gt; paths) &#123; ArrayList&lt;Uri&gt; uriList = new ArrayList&lt;&gt;(); for (String path : paths) &#123; uriList.add(Uri.fromFile(new File(path))); &#125; Intent shareIntent = new Intent(); shareIntent.setAction(Intent.ACTION_SEND_MULTIPLE); shareIntent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, uriList); shareIntent.setType("image/*"); context.startActivity(Intent.createChooser(shareIntent, "分享到")); &#125; /** * 处理分享页面发来的intent */ public static void handleIntent(Activity context) &#123; Intent intent = context.getIntent(); String type = intent.getType(); if (type == null) return; // 当文件格式无法识别或选择了多种类型的文件时，type会变成 */* LogUtils.e("type " + type); //type可能为的类型是 image/* | video/* | audio/* | text/* | application/* if (type.startsWith("text") &amp;&amp; intent.getStringExtra(Intent.EXTRA_TEXT) != null) &#123; // 当直接选中文本分享时，会存放在EXTRA_TEXT里面，选择文本文件时，仍然存放在EXTRA_STREAM里面 LogUtils.e("获取到分享的文本 " + intent.getStringExtra(Intent.EXTRA_TEXT)); &#125; else &#123; List&lt;String&gt; sharePaths = getSharePaths(context, intent); LogUtils.e("获取到分享的文件的路径 " + sharePaths.toString()); &#125; &#125; /** * 获取分享过来的路径 * * @param context 上下文 * @param intent intent * @return 路径列表 */ private static List&lt;String&gt; getSharePaths(Context context, Intent intent) &#123; String action = intent.getAction(); List&lt;String&gt; paths = new ArrayList&lt;&gt;(); // 单个文件 if (Intent.ACTION_SEND.equals(action)) &#123; Uri imageUri = intent.getParcelableExtra(Intent.EXTRA_STREAM); if (imageUri != null) &#123; String realPathFromURI = getRealPathFromURI(context, imageUri); if (realPathFromURI != null) paths.add(realPathFromURI); &#125; &#125; // 多个文件 else if (Intent.ACTION_SEND_MULTIPLE.equals(action)) &#123; ArrayList&lt;Uri&gt; imageUris = intent.getParcelableArrayListExtra(Intent.EXTRA_STREAM); if (imageUris != null) &#123; for (Uri uri : imageUris) &#123; paths.add(getRealPathFromURI(context, uri)); &#125; &#125; &#125; return paths; &#125; /** * 从uri获取path * * @param uri uri * @return path */ private static String getRealPathFromURI(Context context, Uri uri) &#123; final String scheme = uri.getScheme(); String data = null; if (ContentResolver.SCHEME_FILE.equals(scheme)) &#123; data = uri.getPath(); &#125; else if (ContentResolver.SCHEME_CONTENT.equals(scheme)) &#123; Cursor cursor = context.getContentResolver() .query(uri, new String[]&#123;MediaStore.Images.ImageColumns.DATA&#125; , null, null, null); if (null != cursor) &#123; if (cursor.moveToFirst()) &#123; int index = cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA); if (index &gt; -1) &#123; data = cursor.getString(index); &#125; &#125; cursor.close(); &#125; &#125; return data; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AndroidTips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义控件-ViewPager广告板轮播]]></title>
    <url>%2Farticle%2F149273814%2F</url>
    <content type="text"><![CDATA[GitHub GitHub地址 Gradle compile &#39;com.march.billboardview:billboardview:2.0.6-beta4&#39; xml 里面使用12345678910111213xml 里面使用&lt;com.march.billboardview.BillBoardView android:id="@+id/billboard" android:layout_width="match_parent" android:layout_height="250dp" board:isAutoRun="true" board:isLoopIt="true" board:intervalTime="2000" /&gt;属性：isAutoRun:是不是自动播放，不需要滑动，默认trueisLoopIt:是不是无限循环播放，默认是trueintervalTime:播放间隔时间，每隔多长时间走一页 构建实体12//实体类实现获取url和title的接口public class Demo implements BoardConfig&#123;&#125; 定义加载工具1234567//初始化图片加载的工具,你可以自定义使用Picasso还是Glide等图片加载库加载BillBoard.init(new BillBoard.BillLoadImg() &#123; @Override public void loadImg(Context context, String title, String url, ImageView imageView) &#123; imageView.setImageResource(Integer.parseInt(url)); &#125; &#125;); 使用SimpleBoardAdapter1234private BillBoardView billBoardView;private SimpleBoardAdapter&lt;Demo&gt; mBoardAdapter;mBoardAdapter = new SimpleBoardAdapter&lt;&gt;(getActivity(), demos);billBoardView.setAdapter(mBoardAdapter); 配置BillBoardView123456789billBoardView .setAdapter(mBoardAdapter) .setSwipeRefreshLayout(sw) .click(new OnBoardClickListener() &#123; @Override public void clickBillBoard(int pos, BoardConfig b) &#123; Log.e(&quot;chendong&quot;, &quot;click pos &quot; + pos + &quot; title is &quot; + b.getTitle()); &#125; &#125;).show(); 数据更新1mBoardAdapter.notifyDataSetChanged(demos); 开放停止和开始播放的方法12public void startPlay()public void stopPlay() SwipeRefreshLayout冲突 当与SwipeRefreshLayout嵌套使用时，解决SwipeRefreshLayout冲突 1public void setSwipeRefreshLayout(SwipeRefreshLayout sw) 轮播动画和时间 下面是可选的插值器,可自定义插值器 12//设置动画的方法public BillBoardView setAnimation(int duration, Interpolator interpolator) 插值器 描述 new AccelerateInterpolator() 开始慢后面加速,由于距离较近效果不明显,有点像是匀速 new AccelerateDecelerateInterpolator() 两头速度慢,中间加速,由于距离较近效果不明显,有点像是匀速 new DecelerateInterpolator() 开始快后面慢,由于距离较近效果不明显,有点像是匀速 new BounceInterpolator() 到达末尾跳跃弹起 new AnticipateInterpolator() 先甩一下在移动 new AnticipateOvershootInterpolator() 先甩一下到达终点后过界在后退 new OvershootInterpolator() 过界后返回 new LinearInterpolator() 常量变速 new LinearOutSlowInInterpolator() 开始快后面慢 其他API12345//BillBoardView//重新定义ViewPager的将停public void setOnBoardPageChangeListener(OnPageChangeListener onPageChangeListener)//获取内部的ViewPagerpublic ViewPager getViewPager() BoardAdapter12345678//一些变量，你可以在子类中访问protected Context mContext;protected int mLyRes;protected int preIndex = -1;//上一个被选中的protected List&lt;B&gt; datas;protected boolean isLoop;protected View mRootView;protected BillBoardView mBoardView; 基于SimpleBoardAdapter1234567891011121314//为了方便使用定义了SimpleBoardAdapter//获取TitleView用于改变字体，颜色，背景，文字大小等public TextView getTitleView()//获取底部Bar,用于改变背景，高度等public ViewGroup getBotLy()//获取导航条public LinearLayout getGuideLy()//设置选中和未选中的资源public void setSelectRes(int selectRes, int unSelectRes)//设置标题的位置POS_LEFT = 0, POS_CENTER = 1, POS_RIGHT = 2public void setTitleGravity(int gravity)//设置导航栏的位置POS_LEFT = 0, POS_CENTER = 1, POS_RIGHT = 2public void setGuideLyGravity(int gravity) 如何自定义Adapter12345678910111213141516171819202122232425262728293031//Adapter做的工作是，覆盖在BillBoardView上面，随着BillBoardView的变化，修改UIpublic class MyAdapter extends BoardAdapter&lt;Demo&gt; &#123; public MyAdapter(Context mContext, List&lt;Demo&gt; datas) &#123; super(mContext, datas); &#125; //资源ID.高度建议Match_parent @Override protected int getLayoutId() &#123; return 0; &#125; //获取控件，findById()或者一些初始化的操作 @Override protected void initAdapterViews() &#123; &#125; //当划到pos位置。更改界面显示 @Override public void changeItemDisplay(int pos, Demo demo) &#123; &#125; //当adapter连接到billboardView时，触发 @Override public void onBillBoardViewAttached(BillBoardView billBoardView) &#123; super.onBillBoardViewAttached(billBoardView); &#125;&#125; 优化 当你的页面退出时,暂定轮播将是优化的一个很好选择 123456789101112131415161718@Overrideprotected void onResume() &#123; super.onResume(); if(billBoardView!=null) billBoardView.startPlay();&#125;@Overrideprotected void onDestroy() &#123; super.onDestroy(); billBoardView.stopPlay();&#125;@Overrideprotected void onPause() &#123; super.onPause(); billBoardView.stopPlay();&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift基础语法1]]></title>
    <url>%2Farticle%2F1996349588%2F</url>
    <content type="text"><![CDATA[从今天开始学习Swift－2016-3-16； 先学习简单语法，不涉及详细API Swift 3.0已经移除i++方法，请使用i+=1 快捷键123456//格式化代码 ctrl+i//删除一行 command+delete//注释一行command+/ 一些琐碎1234567891011121314151617181920212223242526272829303132//swift是一门安全的语言//不支持隐式类型转换//不支持空值，nil是一种单独的类型//数据类型后面带有数字，表示使用几位来表示，Int8最大为127var int8:Int8print(Int8.max)//二进制，八进制，16进制的表示var two = 0b111var eight = 0o111var sixTeen = 0x111print("\(two) \(eight) \(sixTeen)")//下划线表示忽略,更清晰的数据定义方式var bigNum = 1_000_000var _ = 100//轻量级的数据聚合，元组，元组可以存储任意类型的数据//指定类型var yuanzu0:(Int,String,Int,String) = (100,"0909",30,"222")print("\(yuanzu0.1)")//不指定类型，使用下标访问var yuanzu1 = (100,"0909",30,"222")print("\(yuanzu1.1)")//标志位，访问var yuanzu2 = (x:100,y:"aaa")print("\(yuanzu2.x)")//解包访问，不关心的数据可以使用_代替var (m,_) = yuanzu2print("\(m) ") 常量和变量1234567891011print("hello world");//常量(let)和变量(var)，未赋值的变量常量显示声明类型,赋值的变量常量会自动推断数据类型let contast = 1;print(contast)var a:Int//10进制a = 1000var str = "this is a str" //使用\(变量常量)可以直接打印变量常量出来var rst = "this is a rst = \(a)"print(rst) ##数组和字典123456789101112131415161718192021222324//定义数组，使用［］访问元素var list = [1,2,3,4,5];print(list);print(list[0]);//定义字典，使用key访问var map = ["a":1,"b":2,"c":3];print(map);print(map["a"])print(map["a"]! + 100) //如果列表和字典的类型可以被推断出来，可以不使用类型，也不用带（），在下面，shoplist首先被声明为String类型的数组，后又重新赋值，此时可以推断shoplist 是［String］var shoplist = [String]()shoplist = []//跟常量和变量的定义一样，如果类型可以被推断时，可以不使用类型声明，上面的list和map类型已经可以推断，当将它重新指向空的数组和字典list = []map = [:] //定义空的数组和字典var emptyList = [String]()var emptyMap = [String:Int]()print(emptyList.count)print(emptyMap.count) 控制流for1234567891011121314151617181920212223242526let testList = [1,2,3,4,5,6,7,8];//简单for循环for var i=0;i&lt;8;i+=1 &#123; print("for this is \(testList[i])")&#125;//for in 循环//注意这里的x是常量，不能修改它的值，所以下面（1）是错误的for x in testList&#123; print("for in this is \(x)") //(1) x = 1&#125;//遍历字典中的数组let map2scan = [ "a":[1,2,3,4,5], "b":["a","b","c"]] for (key,value) in map2scan&#123; print("key is \(key)") for num in value&#123; print("num is \(num)") &#125;&#125; if关键字123456789101112131415161718//涉及可选型的概念，后面单独介绍var optionalStr:String? = "hello"optionalStr = "world"print(optionalStr == nil) var greet = "hey"if let name = optionalStr&#123; greet = "hello \(name)";&#125;print(greet) if(optionalStr != nil)&#123; print("optional str is not nil")&#125;if score &gt;= 10&#123;&#125; switch关键字1234567891011121314151617181920212223242526272829303132333435363738394041//swift支持任意数据类型的switch比较，不仅限于Int和enum//break语句,不需要显式添加，默认语句后面都会break;//default语句,是不可以省略的,除非所有的值都被穷举出来了；//fallthrough语句，当满足某个case之后仍旧想使它匹配下一个case，使用 fallthrough，则不会被截断let vegetable = "red peper"switch vegetable&#123;//因为每个case之后都会有break，所以每个case之后必须至少有一行可执行语句，当需要多个匹配时，可以像下面这样case "b","B" print("this is b/B")case "a": print("this is a") fallthroughcase let x where x.hasSuffix("peper"): print("has suffix " + x)default: print("default")&#125;//高级用法//区间let num = 100switch num&#123; case 0 ..&lt; 100: print("小于100")&#125;//元组let point = (1,1)switch point&#123; case (_,0): print("x aliaxs"); fallthrough case (0,_): print("y aliaxs") fallthrough case (0,0): print("origin point") fallthrough case (-2 ... 2,-2 ... 2): print("near by origin point")&#125; while/repeat…while1234567891011//while/repeat...while循环, 当while语句成立时，语句体会执行。var num = 0;while num &lt; 100&#123; num+=1&#125;print("while num is \(num)") repeat&#123; num-=1;&#125;while num &gt; 0print("repeat num is \(num)") 操作符可选值操作符(??)12345//有点类似三目运算符,??表示默认值,当前面的值为空时将会使用后面的let nickName?String = "a"let fullName = "b"let name = "hello \(nickName ?? fullName)"print(name) 范围操作符(..&gt;／…)1234567891011//提供一种更简单实现循环的方式,...包含上界//0 1 2 3for x in 0..&lt;4&#123; print("x is \(x)")&#125;//0 1 2 3 4for x in 0...4&#123; print("x is is \(x)")&#125; 强制解包操作符(!)123//强制解包 unwrap 解包的概念会在可变型中介绍var num = 100var name = "this is " + num! 函数和闭包简述1函数是一个可以被抽取调用的封闭代码块，是可以被传递的数据类型 一个简单函数123456789//函数使用func关键字命名//使用 [参数名:参数类型] ...的方式定义参数//调用函数时，要用 [参数名:值] 的方式传递//func 函数名（参数列表（参数名:参数类型））-&gt; 返回类型 &#123;// 函数体｝func firstFun (name:String,pwd:String,newParams:String)-&gt;Bool &#123; print("name is \(name) and pwd is \(pwd)") return true&#125;firstFun("chendong",pwd:"1234567",newParams:"new params"); 返回多个值1234567891011121314151617181920//可以使用元组返回多个值，实际上是以元组作为值传递的方式//使用元组实现多个返回值//元组可以使用键访问，rst.max,也可以使用下标访问，rst.2func getMultiBackFun(scores:[Int])-&gt;(max:Int,min:Int,sum:Int)&#123; var sum = 0 var min = scores[0] var max = scores[0] for score in scores&#123; sum += score; if(score &gt; max)&#123; max = score; &#125; if(score &lt; min)&#123; min = score &#125; &#125; return (max,min,sum)&#125;let rst = getMultiBackFun([4,8,1,7,4,0,6,3,7])print("max is \(rst.max) min is \(rst.min) sum is \(rst.sum) rst.2 is \(rst.2)") 可变长度参数函数123456789101112//跟所有的语言一样，支持可变长度参数，本质是数组的传递//一个求均值的函数func changeParamFun(params :Int...)-&gt;Void&#123; var sum = 0; for x in params&#123; sum+=x &#125; print("averge is \(sum/(params.count))")&#125; changeParamFun(1,2,3,4)changeParamFun(0,9,8,7) ###函数嵌套定义1234567891011//函数可以嵌套定义,被嵌套的函数作用域有限，只能在嵌套它的｛｝中被访问，比如下面（1）中的代码是编译错误的，被嵌套的函数可以访问外面函数的变量或者全局变量，func aOutFun() -&gt; Void&#123; var num = 100 func aInFun()-&gt;String&#123; return "chendong \(num)" &#125; print(aInFun())&#125;aOutFun()//1 编译错误aInFun() 函数作为返回值123456789//函数作为返回值,下面的函数表示一个无参函数，返回值是一个（参数为Int,返回值是String的）函数类型，在函数returnFuncFun中定义内嵌函数并返回，在外部可以使用该函数func returnFuncFun()-&gt;(Int-&gt;String)&#123; func INTSTRING(num:Int)-&gt;String&#123; return "this num is \(num)" &#125; return INTSTRING&#125;let funINTSTR = returnFuncFun();print("func return is \(funINTSTR(1000))") 函数作为参数传递123456789101112//函数作为参数，下面的函数表示一个参数为Int类型，一个参数为（Int-&gt;String）的函数类型，返回值Stringfunc funParamFun(num:Int,param : Int -&gt; String)-&gt;String&#123; return "funparamfun + \(param(num))"&#125;func paramFunc(num:Int)-&gt;String&#123; return "paramfunc + \(num)"&#125;print("rst is \(funParamFun(100, param: paramFunc))")//结果是 rst is funparamfun + paramfunc + 100 匿名函数闭包12345678910111213141516171819//匿名闭包（in 前面是参数类型，in后面的是函数体）let numbers = [1,2,3,4,5];let get = numbers.map(&#123; （in 前面是函数参数和返回值，in后面的是函数体） (number:Int)-&gt;Int in let rst = number*2; return 3 + rst;&#125;)print("rst is \(get)")//如果一个闭包的类型已知，比如作为一个回调函数，你可以忽略参数的类型和返回值。单个语句闭包会把它语句的值当做结果返回.numbers.map(&#123; number in number * 3&#125;)//使用参数位置代指参数 numbers.sort(&#123;$0&gt;$1&#125;)let get2 = numbers.map(&#123;$0*2&#125;)print("numbers is \(get2)")]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将自己写的库发布到 Jcenter]]></title>
    <url>%2Farticle%2F3189961703%2F</url>
    <content type="text"><![CDATA[本文主要介绍如何最简单的将自己的 Library 发布到 jcenter。 2017.6.16 更新为使用远程上传脚本打包上传，简化操作流程 使用 gradle 开发过程中，我们可以使用 compile 命令，依赖 Library，这种做法的好处时，我们不需要再去关注一堆 jar 文件，当我们需要升级 Library 时，只需要改变依赖的版本号，就可以完成升级。 我们之所以可以使用一句 gradle 脚本完成依赖的下载，升级，是因为这些 Library 都被存储在了一个公共的服务器上，通过 compile 命令可以唯一的映射到服务器存储的 Library。 jcenter 就是一个这样的服务，AndroidStudio 现在新建项目都会默认依赖 repositories {jcenter()}，当执行 compile 脚本时，就会去 jcenter 检查对应的 Library 进行下载和依赖。 踩过的坑 删除 gradle.properties 里面会有 systemProp.http.proxyHost=127.0.0.1 systemProp.http.proxyPort=1080字段，使用代理可能会导致无法上传发布。 打包 javadoc 时会出问题，因为他会将你所有的注释打包进去，如果注释写的不规范就会报错，不过这个是有提示的，按照提示改掉就好了，注释要符合要求。 如果出现了 gradle commond not found ,说明你的 gradle 路径没有配置，mac可以参考这篇文章进行配置。 你的 library 中的 manifest 文件有 allowback 属性最好删掉， 当别人或者你的别的工程引用这个库时，需要进行 manifest 的 merge 操作，如果某些属性冲突了会导致合并失败，因此库文件的 manifest 文件只保留必要的属性，即可。 注册账号我们要发布自己的库到 JCenter,首先要将代码发布到 maven 库，官方网站www.bintray.com ，进去网站注册登录就好了，注册之后可以拿到你的用户名和 apikey。 apiKey 的获取方法 －&gt; 右上角点击头像 －&gt; your profile-&gt; 头像下面edit -&gt; 最下面的 APIkey 就可以获取了，后面有用。 构建项目使用 AS 开发你的项目应该是有多个 module 的，通常你的项目至少应该有 app 这个 module ，创建一个 library 类型的 module（点击工具栏 File - &gt; new moudle -&gt; library,就可以建立一个library moudle)，因为我们要发布到 maven 的是你的 library，所以这个 moudle 需要有。然后你应该把这个项目发布到 github上去，后续需要填写项目的地址，当然这不是必选的。 配置 project/build.gradle配置这个文件主要是依赖一些必要的插件来完成后续的打包上传操作，可能当你看到时下面的插件版本已经不是最新的了，你可以自己依赖最新的插件。 123456789101112131415161718//最后写完应该是这样的buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.2.3' //主要是下面的两行 classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.0' classpath 'com.github.dcendents:android-maven-gradle-plugin:1.4.1' &#125;&#125;allprojects &#123; repositories &#123; jcenter() &#125;&#125; 配置 module/build.gradle需要在 ext{} 内配置项目的相关信息，在每个信息上我都加了比较详细的注释。 完整的配置文件如下，引用了我 git 上面远程的一个上传脚本，当然你也将全部内容复制到本地进行修改，然后引用自己本地的上传脚本，使用远程脚本是为了简化书写脚本的流程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546apply plugin: 'com.android.library'android &#123; ...&#125;dependencies &#123; ...&#125;ext &#123; // 项目的主页 yourSiteUrl = 'https://github.com/chendongMarch/LightAdapterExample' // Git仓库的url yourGitUrl = 'https://github.com/chendongMarch/LightAdapterExample' // issue 地址 YourIssueTrackerUrl = 'https://github.com/chendongMarch/LightAdapterExample/issues' // 项目的名称，将会显示在bintray yourProName = 'LightAdapter' // 项目的描述 yourProDesc = 'Java Recyclerview Library' // bintrayID yourId = 'chendongmarch' // nickName yourName = 'chendong' // email yourEmail = 'helloworld4x@gmial.com' // 最后生成依赖 compile 'yourGroup:yourArtifactId:yourVersion' // 最后生成依赖 compile 'com.march.lightadapter:lightadapter:1.0.1-beta1' yourGroup = 'com.march.lightadapter' yourArtifactId = 'lightadapter' yourVersion = '1.0.1-beta4' // 此文件中存储的是 bintray 的敏感信息，用户名和key // 你需要在该文件中如下声明 // bintray.user=xxxx // bintray.apikey=xxxx // 你可以使用项目中的 local.properties yourBintrayUserPath = '/Users/march/AndroidRes/file/common_local.properties'&#125;apply from: 'https://raw.githubusercontent.com/chendongMarch/Resource/master/jcenter/bintrayUpload.gradle' 需要注意的点下面配置的三个值，决定了你最后生成的依赖是什么样的，我用我现在的库举了个例子，这个是可以后期修改的。 12345// 最后生成依赖 compile 'yourGroup:yourArtifactId:yourVersion'// 最后生成依赖 compile 'com.march.lightadapter:lightadapter:1.0.1-beta1'yourGroup = 'com.march.lightadapter'yourArtifactId = 'lightadapter'yourVersion = '1.0.1-beta4' 用户名和 key，这些敏感信息是不应该被传到 git 上面的， 你应该在 .gitignore 中避免上传这个文件，习惯的做法你可以将这些信息写在 local.properties 中，路径配置为 yourBintrayUserPath = &#39;local.properties&#39;，我的做法是写在本地文件中然后使用绝对路径引用。 然后你在文件中需要按照如下格式声明 bintray.user 和 bintray.apikey； 1234567// 此文件中存储的是 bintray 的敏感信息，用户名和key// 你需要在该文件中如下声明// bintray.user=xxxx// bintray.apikey=xxxx// 你可以使用项目中的 local.propertiesyourBintrayUserPath = '/Users/march/AndroidRes/file/common_local.properties' 发布类库我在 mac 下开发，相关命令可能有所差异。 打开 terminal，运行 install 命令 1./gradlew install 成功后运行上传命令 1./gradlew bintrayUpload 当提示 Build Success 后，去网站打开所在的项目，注意右上角有个链接，类似 https://dl.bintray.com/chendongmarch/maven，这是你 maven库的链接，也就是你私有的空间。注意左下角有三个很小的选项 maven、gradle、lvy，点击 gradle 可以看到一个依赖地址，这是 compile 的地址，就算大功告成啦。 在私有空间使用类库此时你已经可以使用这个类库了，但是因为你的类库没有发布到共有空间，因此使用时需要在 project/build.gradle 声明你的私有空间。 12345678910111213//在 project/build.gradle 文件中添加你私有 maven 空间allprojects &#123; repositories &#123; jcenter() // 现在之所以添加这一句是因为你的类库只是发布到了maven // 但是没有发布到JCenter // 因此需要单独依赖你的私有空间的地址。 maven &#123;url &apos;https://dl.bintray.com/chendongmarch/maven&apos;&#125; &#125;&#125;//在app/build.gradle文件中依赖compile &apos;com.march.lightadapter:lightadapter:1.0.1-beta1&apos; 发布到 jcenter然后我们将类库发布到公共空间让别人可以快速使用，还是在网站查看项目右下角可以看到 Add to jcenter 点击之后可以很简单的添加你的库到 JCenter,但是审核需要时间，第一次会慢一点，以后会很快。等到审核通过，就可以将 maven{url=&quot;&quot;} 这一块去掉，直接 compile，因为已经可以在 jcenter 找到你的类库了， 不需要使用私有空间了。 在本地空间使用类库单单运行 ./gradlew install 任务， gradle 会在 maven 的本地仓库中生成工件，只需将 mavenLocal 添加到 repositories，我们可以像发布到 JCenter 一样引用自己的库，方便打包那些多个项目共享又不想发布的私有库, 在project/build.gradle 文件添加下面的依赖，可以使用本地库，类比上面的私有空间，这个应该算本地空间。 123456allprojects &#123; repositories &#123; mavenLocal() jcenter() &#125;&#125; 一些理解总体来说，最最重要的是打包上传的脚本，他负责打包源文件，生成 aar，生成 doc 然后上传到 bintray，我之前采用过别的方式打包类库，本文介绍的方法有个很大的优点就是把这个任务独立出来，写在 bintrayUpload.gradle 文件中，使用远程脚本，需要打包上传的 library 只需要配置一下类库相关信息，引用这个脚本就可以上传，不需要进行复杂的配置。]]></content>
      <categories>
        <category>Android</category>
        <category>Publish</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Publish</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将自己写的库发布到 JitPack]]></title>
    <url>%2Farticle%2F2091453987%2F</url>
    <content type="text"><![CDATA[JitPack优缺 在使用Jcenter发布库代码时，需要先上传到Bintray网站，比较麻烦，不过我之前已经给出了简化的方案,根据这篇文章发布自己的库到JCenter可以很快的配置好项目。本文介绍另外一种发布自己的库代码的方式，使用JitPack发布代码更简单一些。 AndroidStudio创建项目时没有默认生成JitPack的依赖，当使用库时需要添加如下依赖1234repositories &#123; jcenter() maven &#123; url &quot;https://jitpack.io&quot; &#125; &#125; 创建工程新建Library Module,这些就不仔细说了，大家都会，需要注意的一点是，使用JCenter时，库的名字是跟你的Module name有关的，但是JitPack是与你的Project name有关的,所以给你的项目起一个好名字，他将作为库的名称。 配置插件与发布到JCenter一样，需要插件,这里说一下这个插件，该插件的GitHub地址，在发布到JCenter时也用到了这个插件，现在的最新版本1.4.1，我试了一下，编译不成功，看了Issues,大概是因为gradle需要提升到2.14.1才可以，关于这个问题可以自己去查一下，像我下面这样的配置是ok的，版本的对应可以去Git上看看。12345678910buildscript &#123; repositories &#123; jcenter() mavenCentral() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:2.1.2&apos; classpath &apos;com.github.dcendents:android-maven-gradle-plugin:1.3&apos; &#125;&#125; 配置Module的build.gradle123456//默认就有的apply plugin: &apos;com.android.library&apos;//这个跟Jcenter一样的插件apply plugin: &apos;com.github.dcendents.android-maven&apos;//你的Github用户名替换一下group=&apos;com.github.chendongMarch&apos; 发布到GitHub 接下来就去GitHub上打开你的项目－&gt;点击release－&gt;点击创建新的release版本－&gt;书写版本号和release信息－&gt;就会看见到此就完成了发布。如下 JitPack发布 最后去JitPack,会看见如下界面,输入你的项目地址，会看到版本号，点击get it，下面会出现compile地址 完成 AS依赖 1compile &apos;com.github.chendongMarch:JitPackLibs:1.0.2&apos;]]></content>
      <categories>
        <category>Android</category>
        <category>Publish</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Publish</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Mac 下配置 Gradle 命令]]></title>
    <url>%2Farticle%2F2863351425%2F</url>
    <content type="text"><![CDATA[推荐阅读Mac 下配置 Sdk,Gradle 相关下载下载gradle http://gradle.org/downloads/ 配置环境变量 打开.bash-profile 12touch .bash-profileopen -e .bash_profile 打开 bash_profile，配置环境变量。 12345//不使用ndk可以不配置export NDK_PATH=&quot;/Users/Bob_ge/Documents/android_dev/ndk/android-ndk-r10d&quot;export SDK_PATH=&quot;/Users/Bob_ge/Library/Android/sdk/platform-tools&quot;export GRADLE_HOME=&quot;/Users/Bob_ge/Documents/android_dev/gradle/gradle-2.4/bin&quot;export PATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/X11/bin:/usr/local/ant/bin:/opt/reverse:$&#123;SDK_PATH&#125;:$&#123;NDK_PATH&#125;:$&#123;GRADLE_HOME&#125; 更新 bash_profile 1source .bash-profile 输入adb 检测是否配置正确 1gradle -version]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>DevEnvironment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ListView Adapter 4]]></title>
    <url>%2Farticle%2F2414640248%2F</url>
    <content type="text"><![CDATA[GitHub库代码链接 Gradlecompile &#39;com.march.adapterlibs:adapterlibs:1.0.6&#39; 前言 基于前端时间总结的EasyAdapter（看原理的可以看这些博客）重新构建了代码，基本思想还是一样的，目的是对外开放更加简单的API,其中的原理，想知晓的可以去看我以前的博客。现在的版本已经与以前的版本独立开了。 单类型抽象适配QuickAdapter123456789101112QuickAdapter&lt;Demo&gt; adapter =new QuickAdapter&lt;Demo&gt;(BaseApplication.getInst(), R.layout.item_quickadapter, data) &#123; @Override public void bindData4View(ViewHolder holder, Demo data, int pos) &#123; holder.setText(R.id.item_quickadapter_title, data.getmDemoTitle()); &#125; @Override public void bindListener4View(ViewHolder holder, Demo data, int pos) &#123; //在这里给内部控件绑定监听不是必须实现的 &#125; &#125;; 使用QuickTypeAdapter QuickTypeAdapter的带layout资源参数构造方法,注意不要调用addType了,实体类需要实现QuickInterface接口 1234567891011QuickTypeAdapter&lt;Demo&gt; typeAdapter =new QuickTypeAdapter&lt;Demo&gt;(BaseApplication.getInst(), data,R.layout.item_a) &#123; @Override public void bindData4View(ViewHolder holder, Demo data, int type, int pos) &#123; //单类型,type一直返回0 &#125; @Override public void bindListener4View(ViewHolder holder, Demo data, int type, int pos) &#123; //在这里给内部控件绑定监听不是必须实现的 &#125;&#125;; 多类型适配1234567891011121314151617181920212223//实体类需要实现QuickInterface接口QuickTypeAdapter&lt;Demo&gt; typeAdapter = new QuickTypeAdapter&lt;Demo&gt;(BaseApplication.getInst(), data) &#123; @Override public void bindData4View(ViewHolder holder, Demo data, int type, int pos) &#123; switch (type) &#123; case Demo.CODE_DETAIL: holder.setText(R.id.item_quickadapter_type_title, data.getmDemoTitle()); break; case Demo.JUST_TEST: holder.setText(R.id.item_quickadapter_title, data.getmDemoTitle()); break; &#125; &#125; @Override public void bindListener4View(ViewHolder holder, Demo data, int type, int pos) &#123; //在这里给内部控件绑定监听不是必须实现的 &#125; &#125;;//添加每种类型的xml文件typeAdapter.addType(Demo.CODE_DETAIL, R.layout.item_quickadapter_type) .addType(Demo.JUST_TEST, R.layout.item_quickadapter); 加载网络图片 可以提前创建图片加载工具,然后调用ViewHodler.setImg()方法可以直接加载 12345678//你可以在Activity或者Application调用这段代码进行全局配置,第二次调用会将以前的设置覆盖,所以只需要执行一次Quick.init(new Quick.QuickLoad() &#123; @Override public void load(Context context, String url, ImageView view) &#123; Log.e("chendong","加载图片"); Glide.with(context).load("http://www.fresco-cn.org/static/fresco-logo.png").into(view); &#125; &#125;); 更新使用方法12345678910111213//Demo类是我的实体类//如果你使用的控件ViewHolder没有为你集成,如何避免强转?使用泛型解决 holder.&lt;Button&gt;getView(R.id.abc).setText("");//设置监听事件public ViewHolder setLis(int resId,View.OnClickListener listener,Object tag)//带有tag监听public ViewHolder setLis(int resId,View.OnClickListener listener)//不带tag监听public ViewHolder setTag(int resId, Object tag)//给控件设置tagpublic &lt;T&gt; T getTag(int resId)//从ViewHolder获取tag,包含泛型,你可以这样holder.&lt;Demo&gt;getTag(R.id.xxx)//如果你在控件中设置了tag,当你在适配器外部使用tag时务必使用改方法获取,用来替代view.getTag()方法,包含泛型,你可以这样用 Quick.&lt;Demo&gt;getTagOutOfAdapter(listView);Quick.getTagOutOfAdapter(View view)]]></content>
      <categories>
        <category>Android</category>
        <category>Adapter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ListView</tag>
        <tag>Adapter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Android平台下合成Gif]]></title>
    <url>%2Farticle%2F3121499733%2F</url>
    <content type="text"><![CDATA[本文介绍在 Android 平台下合成 GIF 的方法，查阅资料的过程中发现大致有两种方案。 使用 giflen (一个 C 的合成 gif 的库) 进行 gif 合成。 使用 java 层的 GifEncoder、LZWEncoder、NeuQuant 来进行 gif 合成。 当然二者都是基于 LZW 算法，简单测试的结果是，速度上差不多，由于对 C 不是很擅长，因此我选择了 java 层进行合成的方法，但是两种方法速度上都是 很慢很慢 😭。 因此本文还将会使用多线程独立编码的方法来进行优化，每帧图片并行编码，加快合成速度，现在的成果是 600 * 450 的图片 20 张的话，时间大约在 12s 左右。 本文相关源码在 GitHub - GifMaker 使用 giflen 合成使用 jni 合成，感兴趣的同学可以 google 一下 giflen 这个库，这里有一个编译好的 so 和 jar 文件，以及相关 C 源码，备份在 GitHub 上，有需要的同学可以直接下载使用。经过我的简单尝试发现，使用 so 合成的速度和 java 合成的速度差不多，都是慢的要死… 优化后的 java 合成原始的合成方法，真的慢…特别慢，简直不能忍。 原始的合成方法是将每一个 Bitmap 使用 LZWEncoder 进行编码，由于是一个串行的逻辑，后面的图片需要等待前面的编码完成才可以继续下一张编码，优化后的逻辑是启动一个线程池，每张图片独立编码，最后在所有图片编码完成之后输出流合并，输出到文件中，就完成了 gif 的合成。 缺点：大量的 Bitmap 持有在内存中并行编码，可能会 OOM，不过我测试 20 张 450 * 600 的图片，暂时没有出现问题。合成的图片要求宽高应该是一样的，当然使用宽高不一致的图片也不会有问题，但是会优先使用第一张的图片的宽高作为 gif 的宽高，出来的图片就有些尴尬，因此图片的转换和处理需要在外面完成。 简单演示12345678910111213private void composeGif(List&lt;Bitmap&gt; bitmaps) &#123; String absolutePath = new File(Environment.getExternalStorageDirectory() , System.currentTimeMillis() + ".gif").getAbsolutePath(); new GifMaker(100, mExecutorService) .makeGifInThread(bitmaps, absolutePath, new GifMaker.OnGifMakerListener() &#123; @Override public void onMakeGifSucceed(String outPath) &#123; if (!isFinishing()) &#123; GlideUtils.with(mActivity, outPath).into(mImageView); &#125; &#125; &#125;);&#125; 看一下输出的结果，20 张大约维持在 12s 左右 123456789101112131415161718192021I/GifMaker: 完成第10帧,耗时:9.594 s - bitmap [600,450]I/GifMaker: 完成第11帧,耗时:9.774 s - bitmap [600,450]I/GifMaker: 完成第18帧,耗时:9.880 s - bitmap [450,600]I/GifMaker: 完成第9帧,耗时:10.41 s - bitmap [600,450]I/GifMaker: 完成第17帧,耗时:10.145 s - bitmap [450,600]I/GifMaker: 完成第16帧,耗时:10.331 s - bitmap [450,600]I/GifMaker: 完成第6帧,耗时:10.586 s - bitmap [450,600]I/GifMaker: 完成第5帧,耗时:10.557 s - bitmap [450,600]I/GifMaker: 完成第8帧,耗时:10.701 s - bitmap [450,600]I/GifMaker: 完成第15帧,耗时:10.715 s - bitmap [450,600]I/GifMaker: 完成第4帧,耗时:10.736 s - bitmap [450,600]I/GifMaker: 完成第1帧,耗时:10.835 s - bitmap [450,600]I/GifMaker: 完成第19帧,耗时:10.842 s - bitmap [450,600]I/GifMaker: 完成第13帧,耗时:10.940 s - bitmap [450,600]I/GifMaker: 完成第0帧,耗时:10.944 s - bitmap [450,600]I/GifMaker: 完成第14帧,耗时:10.967 s - bitmap [450,600]I/GifMaker: 完成第3帧,耗时:10.989 s - bitmap [450,600]I/GifMaker: 完成第12帧,耗时:10.994 s - bitmap [450,600]I/GifMaker: 完成第2帧,耗时:10.994 s - bitmap [450,600]I/GifMaker: 完成第7帧,耗时:11.148 s - bitmap [450,600]I/GifMaker: 合成完成,耗时:11.167 s]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AndroidTips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android物理按键及物理连接]]></title>
    <url>%2Farticle%2F4013192295%2F</url>
    <content type="text"><![CDATA[本文主要介绍 Android 手机物理按键触发监听，以及外接蓝牙，耳机等设备的检测。 事件分发 拦截按键按下抬起时的事件分发 12345678@Override public boolean dispatchKeyEvent(KeyEvent event) &#123; //如果是长按事件交给onKeyLongPress处理 if (event.getRepeatCount() &gt; 0) return onKeyLongPress(event.getKeyCode(), event); return super.dispatchKeyEvent(event); &#125; 返回按键12345//返回键的监听很常见，android提供了简便的方法@Overridepublic void onBackPressed() &#123; finishThisPage();&#125; 按键按下事件处理 (音量，耳机按键，back键) 123456789101112131415161718192021222324//home键和power键没有监听到//我当时需要的是音量键和耳机按键可以拍照，是可以监听到的@Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; L.info(event.toString()); switch (keyCode) &#123; case KeyEvent.KEYCODE_VOLUME_DOWN: L.info("KEYCODE_VOLUME_DOWN-音量键减小声音"); return true; case KeyEvent.KEYCODE_VOLUME_UP: L.info("KEYCODE_VOLUME_UP-音量键增加声音"); return true; case KeyEvent.KEYCODE_VOLUME_MUTE: L.info("KEYCODE_VOLUME_MUTE-音量键静音"); return true; case KeyEvent.KEYCODE_HEADSETHOOK: L.info("KEYCODE_HEADSETHOOK-耳机线按键"); return true; case KeyEvent.KEYCODE_BACK: L.info("KEYCODE_BACK-返回键"); return true; &#125; return super.onKeyDown(keyCode, event); &#125; 其他事件1234567891011121314151617181920212223242526272829303132// 使用快捷键可以快速选中菜单中的某一项，在Android没有什么卵用@Override public boolean onCreateOptionsMenu(Menu menu) &#123; MenuItem add = menu.add(""); add.setShortcut('A','A'); return super.onCreateOptionsMenu(menu); &#125;@Override public boolean onKeyShortcut(int keyCode, KeyEvent event) &#123; L.info("onKeyShortcut " + event.toString()); return super.onKeyShortcut(keyCode, event); &#125;@Override public boolean onKeyLongPress(int keyCode, KeyEvent event) &#123; L.info("onKeyLongPress " + event.toString()); return super.onKeyLongPress(keyCode, event); &#125; //暂时没有用到，网上有说在手写和汉字输入时会触发@Override public boolean onKeyMultiple(int keyCode, int repeatCount, KeyEvent event) &#123; L.info("onKeyMultiple " + event.toString()); return super.onKeyMultiple(keyCode, repeatCount, event); &#125;//按键抬起时会触发@Override public boolean onKeyUp(int keyCode, KeyEvent event) &#123; L.info("onKeyUp " + event.toString()); return super.onKeyUp(keyCode, event); &#125; 外设监测 检测耳机线，蓝牙耳机是否连接 1234567891011121314151617181920212223242526272829303132private boolean checkControlIsConnected() &#123; //检测耳机线是否连接 AudioManager am = (AudioManager) getSystemService(AUDIO_SERVICE); //这个方法已经过时，api介绍仅仅用来检测是否连接，可以注册广播接收者接受耳机插拔的广播 if (am.isWiredHeadsetOn()) &#123; //耳机插入 return true; &#125; //检测蓝牙设备是否连接 BluetoothAdapter ba = BluetoothAdapter.getDefaultAdapter(); //蓝牙适配器是否存在，即是否发生了错误 if (ba == null || !ba.isEnabled()) &#123; //蓝牙不可用 return false; &#125; else if (ba.isEnabled()) &#123; Set&lt;BluetoothDevice&gt; bondedDevices = ba.getBondedDevices(); if (bondedDevices == null || bondedDevices.size() &lt;= 0) &#123; //当前没有设备连接 return false; &#125; else &#123; for (BluetoothDevice d : bondedDevices) &#123; if (d.getBondState() == BluetoothDevice.BOND_BONDED) &#123; //当前有设备接入并处于连接状态 return true; &#125; &#125; &#125; &#125; return false; &#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AndroidTips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python开发-1-基础]]></title>
    <url>%2Farticle%2F1811789999%2F</url>
    <content type="text"><![CDATA[前言 我使用的Pycharm编译器，刚开始就遇到了一个问题，不能输入中文，解决办法就是在文件头部添加代码#-*- coding:utf8 -*- Python交互12345678910111213141516171819# 使用python交互模式# 在命令行界面输入｀python｀进入交互模式# ｀help()｀进入帮助模式# 尝试｀keywords｀获取关键字帮助#｀help("modules")｀查看modules# ｀quit｀ 退出帮助模式#dir(object) 它返回传递给它的任何对象的属性名称经过排序的列表#dir()当前倒入的模块#下面以内建函数id为例#获取文档介绍,｀id.__doc__｀#获取名称,并不是所有的都有`id.__name__`属性#`hasattr(dir,'__doc__')`,`getattr(dir,'__doc__')`获取一个对象的属性#callable可调用性`callable("a")` false,`callable(dir)` true#`isinstance("python", str)`,`issubclass(child.father)` 数据类型12345678# 列表(同类型数据构成的数组)list ＝ ［1，2，3，4］# 元组（数据类型可以不同，简单方便的数据聚合，类似结构体）tuple = (1,"second",1.2)# set（数据不重复，使用list构建，无序，不能使用索引访问）set = set([1,2,3,4])# 字典（键值对存储数据）dict ＝ ｛"a":"b","c":"d"｝ 基础语法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218# 打印# 自动追加换行符print "hello world"# 将不会打印换行符号print "hello world",＃ 使用匹配符num = 100num2 = 200print "num is %d"%numprint "num is %d,num2 is %d"%(num,num2)# 内建函数id()和type()a = 3# 获取内存地址print "id(a) is ", id(a)# 获取变量类型print "type(a) is ", type(a)# 运算符(两个比较特殊的)# 级数乘2的3次方print "use ** = ", 2 ** 3# 除后取整print "use // = ", 9 // 4# 逻辑运算 and | or | notif a == 0 and b == 0: a = 2# for in 循环for i in [1, 2, 3, 4]: print i,# 模块的导入的几种方式import mathfrom math import powfrom math import pow,absfrom math import *print pow(10, 3)from math import pow as pingfangprint pingfang(10, 3)# 赋值# 多个赋值可以直接顺序写，会挨个自动赋值x, y, z = 1, "abc", [1, 2, 3]print x, y, z# 自动创建元组，将后面的数据,装入元组xx = 1, 2, 3, 4, "qqq"print xx# 交换数据的方式yy, zz = 3, 4print yy, zzyy, zz = zz, yyprint yy, zz# 链式赋值,两个变量指向统一空间,id()一样的m = n = 123print m, nprint m is n# 判断结构xxx = 1if xxx == 1: print "this is test ", 1elif xxx == 2: print "this is test ", 2else: print "this is test ", 100#获取控制台输入inputNum = raw_input()# 三元运算# A = X if B else Y# 如果B为真,执行A = X,否则执行A = Ymm, nn = 1, 2rstStr = "abc" if mm &gt; nn else "def"print rstStr# for循环和内建函数range(start,stop,step),range(start,stop,1),range(0,stop,1)返回的是数字元素的列表start开始,stop结束,每次增加step个strx = "abcdefg"for i in range(len(strx)): print strx[i],range(9)range(3, 9)range(3, 9, 4)＃ 一个可迭代的对象可以直接转换为序列对象print list(strx)print set(strx)print tuple(strx)# 遍历字典dictStr = &#123;"a": "b", "c": "d"&#125;# 不建议使用,效率相对低for key in dictStr: print "1key value is ", key, dictStr[key]# 遍历keyfor key in dictStr.keys(): print "2key value is ", key, dictStr[key] for key, value in dictStr.items(): print "3key value is ", key, value# 更优for key, value in dictStr.iteritems(): print "4key value is ", key, value # 单独取value使用下面的方法效率更高for value in dictStr.values(): print "5value is ", value# 内建函数zip(),将两个序列数据类型,每一项取出来,合并为一个元组,构成元组的liststr1 = "abcdef"str2 = "12345"print zip(str1, str2, str2)# [('a', '1', '1'), ('b', '2', '2'), ('c', '3', '3'), ('d', '4', '4'), ('e', '5', '5')]# 交换key,value,每个item是两个元素的tuple的list可以直接转换为dictdict1 = &#123;"a": "1", "b": "2", "c": "3"&#125;print dict(zip(dict1.values(), dict1.keys()))# 内建函数enumerate()生成的是（item为下标和元素构成的两元元组）的可迭代对象，可以直接转换为列表mList = ["a", "b", "c", "d", "e"]for (i, j) in enumerate(mList): print i, " -- ", jprint list(enumerate(mList, start=1))#[(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd'), (5, 'e')]# 替换字符串中的字符,字符串正则分割originStr = "Do u like Canglaoshi? Canglaoshi is a good teather!"splitStrs = originStr.split(" ")for i, s in enumerate(splitStrs): if "Canglaoshi" in s: splitStrs[i] = "Python"# list解析,去掉元素前后空格,list解析可以简单快捷的修改每一个元素，生成新的listoriginList = [" abc", " vbf ", "rtg "]afterList = [one.strip() for one in originList]print afterList# list切片[start = 0,stop = len(list),step = 1],一个简单从list提取部分数据的方式list2cut = [1,2,3,4,5,6,7]listRst = list2cut[0:5:2]print "list2Rst is " ,listRst# 一个猜数字的小程序，简单介绍循环结构和判断结构的简单实用import randomnumber = random.randint(1,100)while(True): print "请输入一个数字,猜测约定的数字是多少?" input = raw_input() if (int)(input) == number: print "正确!" break elif (int)(input) &lt; number: print "太小了!" else: print "太大了!"# for... else 和 while... else# 跳出循环结构之后执行else语句for i in range(1,100): print i,else: print "end"# 迭代list2Iter = [1,2,3,4,5,6]iterIt = iter(list2Iter)# 这里会提示一个警告while True: print iterIt.next()# 文件迭代#f其实是一个可以迭代的对象,可以使用列表操作list2File = [line for line in open(fileName)]print "list2File is ",list2File# 可以更简单list2File = list(open(fileName))print "list2File2 is ",list2File 文件简单操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455文件操作fileName = "/Users/march/123.txt"# 以一种模式打开文件获取可迭代索引file = open(fileName, "rw")for line in file: print line,file.close()#打开文件的模式r 以读方式打开文件，可读取文件信息。w 以写方式打开文件，可向文件写入信息。如文件存在，则清空该文件，再写入新内容a 以追加模式打开文件（即一打开文件，文件指针自动移到文件末尾），如果文件不存在则创建r+ 以读写方式打开文件，可对文件进行读和写操作。w+ 消除文件内容，然后以读写方式打开文件。a+ 以读写方式打开文件，并把文件指针移到文件尾。b 以二进制模式打开文件，而不是以文本模式。该模式只对 Windows 或 Dos 有效，类 Unix 的文件是用二进制模式进行操作的。# 不需要关闭的安全方法with open("/Users/march/123.txt", "a") as ff: ff.write("this is new line")# 获取文件状态import osfileStatus = os.stat(fileName)print fileStatusimport timeprint time.localtime(fileStatus.st_ctime)# 指定size时读取指定size的数据,否则读取全文，下面的所有方法都遵循这一规则file = open(fileName)# 读取字节file.read()file.read(100)# 读取一行file.readline()file.readline(100)# 读取所有数据存储在列表中file.readlines()file.readlines(100)# 移动指针file.seek(10)# 当前指针的位置file.tell()# 另外一种简化的读取文件的方式import fileinputfor line in fileinput.input(fileName): print "use fileinput print is " , line 列表操作12345678910111213141516171819charList = ['1A','2','3','4','5','6','7','8','9','10','11','11']strList = ["1","2","3","4","5","6","7","8","9","10","11","11"]charList.append("new_a")#在指定位置添加元素,指定位置之后的元素向后移动一个,长度+1charList.insert(1,12)#当前元素在列表中的位置print("pos of 3 ",charList.index("3"))#当前元素在列表中出现的次数print("total num of 11 ",charList.count('11'))#将当前字符串\列表(可迭代类型的数据)拆分成单个字符添加在末尾，返回值是noneprint(charList.extend(strList))#从末尾弹出一个元素,或从指定位置弹出,返回值 是该元素print(charList.pop(2))#移除指定元素,不能使用下标做参数charList.remove('1A')#列表反向charList.reverse()#针对第一个字母或数字排序,更多参数比较复杂charList.sort()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android图像处理相关]]></title>
    <url>%2Farticle%2F2699277879%2F</url>
    <content type="text"><![CDATA[Bitmap和Drawable转换12345678910111213141516//drawable 转 bitmappublic static Bitmap drawableToBitmap(Drawable drawable) &#123; int width = drawable.getIntrinsicWidth(); int height = drawable.getIntrinsicHeight(); Bitmap bitmap = Bitmap.createBitmap(width, height, drawable.getOpacity() != PixelFormat.OPAQUE ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565); Canvas canvas = new Canvas(bitmap); drawable.setBounds(0, 0, width, height); drawable.draw(canvas); return bitmap; &#125; //bitmap 转 drawablepublic static Drawable bitmapToDrawble(Bitmap bitmap,Context mcontext)&#123; Drawable drawable = new BitmapDrawable(mcontext.getResources(), bitmap); return drawable; &#125; 获取图片创建的时间1234567891011121314151617181920212223//文件修改的时间File file = new File("");file.lastModified();//获取照片拍摄的时间// MediaStore.Images.Media下面有DATE_TAKEN,DATE_ADD,DATE_MODIFIED的参数，分别是照片拍摄的时间，添加到ContentProvider的时间，最后修改的时间，经过测试显示，DATE_TAKEN这个字段下面的时间是最靠谱的，不说他是不是准确，但是系统相册也是使用的这个时间作为照片信息，亲测。另外，有趣的是，只有DATE_TAKEN这个字段下是毫秒级的，另外两个都是秒级的。public static long getImgCreateTime(Context context, String path) &#123; long createTime = -1; Uri mImageUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI; ContentResolver mContentResolver = context.getContentResolver(); Cursor mCursor = mContentResolver.query(mImageUri, new String[]&#123;MediaStore.Images.Media.DATE_TAKEN&#125;, MediaStore.Images.Media.DATA + "=?", new String[]&#123;path&#125;, MediaStore.Images.Media.DATE_TAKEN); if (mCursor == null) &#123; return -1; &#125; while (mCursor.moveToNext()) &#123; //获取图片的路径 String str = mCursor.getString(mCursor .getColumnIndex(MediaStore.Images.Media.DATE_TAKEN)); createTime = Long.parseLong(str); &#125; return createTime ; &#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AndroidTips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Handler源码分析]]></title>
    <url>%2Farticle%2F541527599%2F</url>
    <content type="text"><![CDATA[Android 中使用 Handler 来进行消息的处理，它是 Handler意思是处理者，它是android特有的用来消息处理的一个类。使用它可以解决很多android中常见的问题. Handler体现的是一种消息的发送与处理异步进行的机制，消息发送时即刻返回，将消息加入队列中，另一端looper负责循环取出消息进行操作。 需要注意的是Handler可以发送Message也可以发送Runnable对象。但是消息处理必定是在Handler所在的线程中，也就是说UI线程中的Handler发送的消息也是在UI线程中执行，所以同样不能执行耗时操作。 使用场景： 发送延时消息，执行延时任务，使用线程睡眠的方式过于粗糙。。通常是用Handler发送延时消息或者使用Timer来完成延时操作。 在子线程“操作”UI，众所周知子线程是不能操作UI的，想要在子线程的任务执行完之后更改UI,就需要在子线程向主线程发送消息让主线程来修改UI。 结合异步任务实现任务回调，这个实际上是等同于2的，因为异步任务内部也是子线程，使用Handler+异步任务可以实现请求的回调，但是通常我们更加偏向于接口回调的方式，而不是传递Handler。 在子线程中使用Handler,对任务进行串行化处理，可以更加高效的管理任务的执行。 Handler原理图解： Looper类介绍 Looper类负责在消息队列的另一端取出消息进行处理，Handler采用消息的先进先出原则。 成员变量 Looper中的成员变量ThreadLocal，提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。查了很多资料，这里有很好的的解释，大家可以去膜拜一下。 Looper类中，首先ThreadLocal变量是private static的，每个线程只能有一个Looper对象，在我看来，使用ThreadLocal是为了对每个线程的Looper进行管理。使用ThreadLocal存储Looper就可以很方便的隔离其他线程随时存取本线程的Looper对象，结合后面的代码，发现创建Looper时会使用当前线程为键，新创建的Looper为值存放到ThreadLocal中，prepare()又会进行判断是否已经创建了该线程的Looper,这么说可能有些抽象，建议看完后面的代码，再回来看这段也许会更加清晰一点。 123456//ThreadLocal.get() will return null unless you've called prepare().static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();private static Looper sMainLooper; // guarded by Looper.class（被这个类保护）final MessageQueue mQueue;final Thread mThread; 构造方法 构造方法,私有化的构造方法，并不允许外部调用，做的操作是创建一个MessageQueue和将mThread对象指向了本线程。这里有个重要的地方是，MessageQueue是Looper创建并首先持有的。 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 在Looper之中有一个private static Looper sMainLooper;变量，这个变量代表主线程（UI）的Looper，这也就是我们不需要在UI线程显式调用Looper.prepare()方法的原因，看下面的代码及注释： 12345678910111213141516171819202122/**//初始化当前线程Looper,将它标记为应用的主要Looper。应用程序的主Looer是Android环境创建的 ,所以你应该不需要自己调用这个函数* Initialize the current thread as a looper, marking it as an* application's main looper. The main looper for your application* is created by the Android environment, so you should never need* to call this function yourself. See also: &#123;@link #prepare()&#125;*/public static void prepareMainLooper() &#123;//进行一次准备并且是不允许打断的prepare(false);synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException("The main Looper has already been prepared."); &#125;//获取这个loopersMainLooper = myLooper();&#125;&#125;//myLooper返回的是本线程的Looperpublic static Looper myLooper() &#123;return sThreadLocal.get();&#125; 成员方法 prepare方法,创建Looper放入sThreadLocal，同时要求每个线程只能有一个Looper对象，多创建会报异常。 123456789public static void prepare() &#123;prepare(true);&#125;private static void prepare(boolean quitAllowed) &#123;if (sThreadLocal.get() != null) &#123;throw new RuntimeException("Only one Looper may be created per thread");&#125;sThreadLocal.set(new Looper(quitAllowed));&#125; loop方法，使用该方法循环取出MessageQueue的消息。死循环取出消息，进行处理，处理完之后，同时消息会被回收掉，使用这个机制可以进行消息对象的复用，这里loop()结合MessageQueue的next()方法，形成了一个轮询的过程，详细的内容会在MessageQueue类的分析中来看，到时候会解释死循环轮询消息的机制。这里有其他对象的部分方法，暂且不去考虑，做下标记，看到Message的源码自然就会明白。 ###留下的问题： Message msg = queue.next();msg.target.dispatchMessage(msg);msg.recycleUnchecked();稍后我们会去解决。 123456789101112131415161718192021222324public static void loop() &#123;final Looper me = myLooper();if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");&#125;final MessageQueue queue = me.mQueue;// Make sure the identity of this thread is that of the local process,// and keep track of what that identity token actually is.Binder.clearCallingIdentity();final long ident = Binder.clearCallingIdentity();//死循环取出消息，进行处理，当取不到消息时，return掉，等待下次调用loop(),同时消息会被回收掉，使用这个机制可以进行消息对象的复用，这里涉及了Message对象的部分方法，暂且不去考虑，做下标记，看到Message的源码自然就会明白for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123;// No message indicates that the message queue is quitting. return;&#125;msg.target.dispatchMessage(msg);// Make sure that during the course of dispatching the// identity of the thread wasn't corrupted.final long newIdent = Binder.clearCallingIdentity();msg.recycleUnchecked(); &#125;&#125; Message类成员变量 Message类十分类似于Bean类，毕竟它是用来承载消息的。 what,arg1,arg2,obj都是预设好用来盛放简单消息内容的变量，原文的注释中使用了lower-cost表示使用这些变量可以降低开销，就是不用自己创建维护这些变量，而且消息是可以被复用的，确实降低了开销。 target变量，是一个Handler,后面的代码中会具体介绍他的作用，这个变量也算这个类的核心了。 Runnable callback,代表一个任务，前面说过Handler可以发送简单消息也可以发送任务。 Message next，代表下一个Message的引用，由此形成了一个链表的结构。 还有很多常量，变量不做一一介绍。下面有注释，不太详细，大家可以看完后面的再回来看也许会更加清晰。感兴趣的可以仔细去看源码注释。 123456789101112131415161718192021public int what;//消息标示public int arg1; public int arg2;public Object obj;public Messenger replyTo;public int sendingUid = -1;//标示该消息正在使用之中static final int FLAG_IN_USE = 1 &lt;&lt; 0;static final int FLAG_ASYNCHRONOUS = 1 &lt;&lt; 1;tatic final int FLAGS_TO_CLEAR_ON_COPY_FROM = FLAG_IN_USE;int flags;long when;Bundle data;Handler target;//Handler重点哦Runnable callback;//一个任务可以用来发送，类似于Bean的一个属性Message next;//下一个Message，用于构成链表private static final Object sPoolSync = new Object();//同步对象private static Message sPool;//链表根节点，他维护了一个空的Message队列用来复用private static int sPoolSize = 0;//链表的长度private static final int MAX_POOL_SIZE = 50;//链表最大数量private static boolean gCheckRecycle = true; 成员方法obtain() Message类中实现了obtain()的8个重载方法，提供了各种各样的参数，为的只是我们在外部用起来好用，所以大家使用Message时不妨多去用用其他方法，我到现在为止一般都是偏用参数为空的方法，其他的重载基本没看过，另外Handler也提供了大量的obtain方法，是的Message的重用和管理更加的方便了，所以千万不要去new Message。其他的方法也会回调空参方法然后进行一下外围的初始化，所以我们就来看看空参方法。 代码不多，解释一下，首先这个变量sPoolSync，看名字就知道他是用来同步操作的，目的是当一个操作在获取Message是进行同步操作，避免其他的操作再来创建Message，否则会怎么样？Message本身形成了一个链表的结构，不进行同步就会，出现多个头，或者一个Message后面接入多个Message，那么后接入的就会覆盖掉，是这样吗？还是出错误。 接下来是一个判断，我们看到sPool这个变量，它是一个Message对象，经过我的研究它是这个链表的头指针，同时sPool维护的是一个曾经创建过的空的可复用的Message队列，了解这一点至关重要，这是Message可复用的关键。看看他是怎么操作的 如果这个根sPool为空，则返回一个新的Message，Message的构造方法我看了，是个空的，所有的属性都在外部或者发送的那一刻设置。 如果不是空，那么表示可复用Message队列可用，则取出头部的MessageMessage m = sPool,同时指针向后移动一位sPool = m.next;此时m是等于sPool的，以此表示sPool后移一位，然后将取出的Message.next置为null，因为这个消息是要拿来发送的，他此时可是指向的可复用Message队列的头，所以将它的next置为null，不然会怎么样？我们看Looper源码时，循环何时终止呢，就是在next==null时终止，如果不置为null,for循环是不会停止的，会把空的Message队列遍历一遍。最后可复用的链表长度减一sPoolSize--; 其他的obtain方法我们不再去研究，大同小异吧。12345678910111213public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; &#125; &#125; return new Message();&#125; Message的回收方法 看一下代码，了解了上面说的机制，这个代码不难理解。解释一下，如何回收一个Message,要有一个概念就是Message调用该方法回收的是自己，首先将自己的next指向sPoolnext = sPool;也就是说。此时自己已经链接到了可复用的Message队列头部（每次都叫他。可复用的Message队列。真麻烦），然后sPool = this;sPool指针又指向了 可复用的Message队列头部，队列长度++完成了消息的回收。在Looper中提到的msg.recycleUnchecked();这个方法就是在这里实现的。 12345678910 void recycleUnchecked() &#123;.....//这里进行了好多代码，做了一个操作，将成员变量清空。 synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125; &#125; ###补充 Message实现了Parcelable接口表明它是可以传输的。 1public final class Message implements Parcelable &#123;&#125; MessageQueue类介绍 内部通过链接Message形成了一个消息队列，有两个比较核心的方法。boolean enqueueMessage(Message msg, long when){}和Message next()方法，Looper类中遗留的第二个问题Message msg = queue.next();会在这里解释。 入队方法 前面巴拉巴拉一通判断，内部的target不能是null,Message对象不能被占用，线程不能退出。。。。 这里的mMessages变量起到了与Message中sPool相同的作用，它是队列的指针，指向消息队列的头，只是这里维护的队列是要被处理的消息队列。但是由于sendMsgDelay方法的存在，入队时不能单纯的链接消息，还需要判断时间戳。 if (p == null || when == 0 || when &lt; p.when)这个判断if(是第一个消息 ||要被处理的时间是0 ||要被处理的时间小于当前队列头消息的时间也就是已经到达处理这个消息的时间)，此时将会将消息链接在队列头部msg.next = p;，同时指针指向它mMessages = msg;,并且此消息是不要被唤醒的needWake = mBlocked;,这个操作与Message中的操作十分相似，不多做介绍。 else语句块中表明此消息是一个延时消息，此时进行的操作是采用了一个for循环，完成的功能是找到这个消息被处理的时间when，大于这个时间的第一个消息，将它插入到该位置。如果没有找到会一直循环，最后找到preMsg指向的前一个消息和p = mMessage指向的后一消息，进行链接操作，msg.next = p; prev.next = msg;就是普通的链接操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950boolean enqueueMessage(Message msg, long when) &#123;if (msg.target == null) &#123;throw new IllegalArgumentException("Message must have a target.");&#125;if (msg.isInUse()) &#123;throw new IllegalStateException(msg + " This message is already in use.");&#125;synchronized (this) &#123;if (mQuitting) &#123;IllegalStateException e = new IllegalStateException( msg.target + " sending message to a Handler on a dead thread"); Log.w("MessageQueue", e.getMessage(), e);msg.recycle();return false;&#125;//核心方法从这里开始msg.markInUse();msg.when = when;Message p = mMessages;boolean needWake;if (p == null || when == 0 || when &lt; p.when) &#123;// New head, wake up the event queue if blocked.msg.next = p;mMessages = msg;needWake = mBlocked;&#125; else &#123;// Inserted within the middle of the queue. Usually we don't have to wake// up the event queue unless there is a barrier at the head of the queue// and the message is the earliest asynchronous message in the queue.needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();Message prev;for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125;&#125;msg.next = p; // invariant: p == prev.nextprev.next = msg;&#125;// We can assume mPtr != 0 because mQuitting is false.if (needWake) &#123; nativeWake(mPtr);&#125;&#125;return true;&#125; 出队方法 之前在Looper.loop()方法中看到有这么一段代码,结合MessageQueue的出队方法，可以发现这是一个循环轮询消息队列的操作。在死循环中调用了Message msg = queue.next(); // might block方法，当返回msg==null，循环体结束，什么时候会结束，看next()方法中返回null的只有一种情况就是线程结束时，返回null，线程结束，他的Looper自然应该结束。 死循环实际是发生在MessageQueue中的，我在注释中写了说明。关于MessageQueue的很多本地方法的介绍，大家可以参考这里 12345Message msg = queue.next(); // might blockif (msg == null) &#123;// No message indicates that the message queue is quitting.return;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101Message next() &#123;//// Return here if the message loop has already quit and been disposed.// This can happen if the application tries to restart a looper after quit// which is not supported.final long ptr = mPtr;if (ptr == 0) &#123; return null;&#125;int pendingIdleHandlerCount = -1; // -1 only during first iteration//超时时间int nextPollTimeoutMillis = 0;//开始循环取出消息for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands();&#125;nativePollOnce(ptr, nextPollTimeoutMillis);//接下来进行锁定，开始取出消息synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; //取到消息是空，然后进行一个循环查找下一个可用消息 if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125;if (msg != null) &#123; if (now &lt; msg.when) &#123;// Next message is not ready. Set a timeout to wake up when it is ready.//当前时间没有达到执行这个消息的时间。将会进行超时等待 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; //取出头部的消息返回 // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; return msg;&#125;&#125; else &#123; // No more messages. nextPollTimeoutMillis = -1;&#125;// Process the quit message now that all pending messages have been handled.//线程不存在时返回null，loop()也会随之结束if (mQuitting) &#123; dispose(); return null;&#125;// If first time idle, then get the number of idlers to run.// Idle handles only run if the queue is empty or if the first message// in the queue (possibly a barrier) is due to be handled in the future.if (pendingIdleHandlerCount &lt; 0&amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size();&#125;//死循环发生在这里，具体还没有很明白，需要再去研究if (pendingIdleHandlerCount &lt;= 0) &#123;// No idle handlers to run. Loop and wait some more. mBlocked = true;continue;&#125;if (mPendingIdleHandlers == null) &#123;mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];&#125;mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);&#125;// Run the idle handlers.// We only ever reach this code block during the first iteration.for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handlerboolean keep = false;try &#123; keep = idler.queueIdle();&#125; catch (Throwable t) &#123;Log.wtf("MessageQueue", "IdleHandler threw exception", t);&#125;if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125;&#125;&#125;// Reset the idle handler count to 0 so we do not run them again.pendingIdleHandlerCount = 0;// While calling an idle handler, a new message could have been delivered// so go back and look again for a pending message without waiting.nextPollTimeoutMillis = 0; &#125;&#125; Handler类成员变量12345678//从这里看得出Handler很好的连接了Looper和MessageQueuefinal MessageQueue mQueue;final Looper mLooper;//这是一个接口，用来处理消息，下面是具体实现，也是我们通常要实现的方法。final Callback mCallback;public interface Callback &#123; public boolean handleMessage(Message msg);&#125; 构造方法 重载了多个构造方法，老规矩，我们只看没有最底层的构造方法和我们最常用的构造方法 123456789101112131415161718//常用空参构造方法public Handler() &#123; this(null, false);&#125;//根构造方法public Handler(Callback callback, boolean async) &#123;//获得当前线程的Looper，大家还记得Looper.myLooper()方法吧，return sThreadLocal.get();mLooper = Looper.myLooper();if (mLooper == null) &#123;//必须先调用Looper.prepare()throw new RuntimeException("Can't create handler inside thread that has not called Looper.prepare()");&#125;//拿到Looper的MessageQueue,这个MessageQueue是Looper创建的。mQueue = mLooper.mQueue;//这个是回调，用来处理消息mCallback = callback;mAsynchronous = async;&#125; 成员方法 obtain()方法，这个方法不做解释，返回的是Message的obtain()方法，详细请看Message类的分析。 发送消息，我们浏览一下所有发送消息的方法。方法很多，大致的思想是，填充消息，发送消息，很多方法都是重载互相调用的，关注最后一个方法，它调用了MessageQueue的入队方法，同时将msg.target设置为this,将这个消息插入到了队列中，也就是被发送的Message持有发送它的Handler的引用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//以下是各种发送消息的方法，可以浏览一下。public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0);&#125;public final boolean postAtTime(Runnable r, long uptimeMillis)&#123; return sendMessageAtTime(getPostMessage(r), uptimeMillis);&#125;public final boolean postAtTime(Runnable r, Object token, long uptimeMillis)&#123; return sendMessageAtTime(getPostMessage(r, token), uptimeMillis);&#125;public final boolean postDelayed(Runnable r, long delayMillis)&#123; return sendMessageDelayed(getPostMessage(r), delayMillis);&#125;public final boolean postAtFrontOfQueue(Runnable r)&#123; return sendMessageAtFrontOfQueue(getPostMessage(r));&#125;public final boolean sendMessage(Message msg)&#123; return sendMessageDelayed(msg, 0);&#125;public final boolean sendEmptyMessage(int what)&#123; return sendEmptyMessageDelayed(what, 0);&#125;public final boolean sendEmptyMessageDelayed(int what, long delayMillis) &#123; Message msg = Message.obtain(); msg.what = what; return sendMessageDelayed(msg, delayMillis);&#125;public final boolean sendEmptyMessageAtTime(int what, long uptimeMillis) &#123; Message msg = Message.obtain(); msg.what = what; return sendMessageAtTime(msg, uptimeMillis);&#125;public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123;delayMillis = 0;&#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125;public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException(this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125;public final boolean sendMessageAtFrontOfQueue(Message msg) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException(this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, 0);&#125;//这两个方法是发送Runnable任务时会调用的方法private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m;&#125;private static Message getPostMessage(Runnable r, Object token) &#123; Message m = Message.obtain(); m.obj = token; m.callback = r; return m;&#125;//消息入队，同时Message将会持有发送它的Handler的引用private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123;msg.setAsynchronous(true);&#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 事件分发与处理 还记得Looper中遗留的问题吗？msg.target.dispatchMessage(msg);结合发送消息的方法，可以得出，msg.target就是发送它的那个Handler,处理消息时调用dispatchMessage方法，也就是下面的方法，所以，Message携带它的发送者，谁发送的消息誰来处理它。 分析一下下面的逻辑。msg.callback是消息中包含的任务，如果是一个任务的消息，那么不需要外部处理，直接调用该Runnable任务的run方法，所以还是在当前线程执行，并没有开启新的线程，不要看到Runnable就想到线程，这也是我以前的一个误区 不是一个Runnable任务，mCallback是一个接口，在介绍成员变量是提到过，他可以通过构造方法在外部实现，当然不是必须实现的，如果实现了这个接口，那么调用这个接口的mCallback.handleMessage(msg)方法处理消息。 如果没有实现这个接口，则调用handleMessage(msg);方法，这个方法是空的，需要你在子类中重载，如果你没有重载他不会执行任何操作。这算提供了处理消息的两种方式。 1234567891011121314151617public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125;private static void handleCallback(Message message) &#123; message.callback.run();&#125;public void handleMessage(Message msg) &#123;&#125; ##总结 线程中Handler消息机制的使用,Looper类中给出了很好的示例代码。注意的是在非UI线程需要我们显式的调用Looper.prepare(); Looper.loop();方法来完成消息的轮询。 123456789101112class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; Looper.prepare(); mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; // process incoming messages here &#125; &#125;; Looper.loop(); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SourceCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList源码分析]]></title>
    <url>%2Farticle%2F1697740661%2F</url>
    <content type="text"><![CDATA[开始看源代码了才知道android和java的源代码有好多出入，我把java和android源码比较了一下，相似的还是多的。我是以android源码为主，因为感觉android比较繁琐，不同的地方会贴java的代码对比。 java真的设计的很好，很多类内部实现差别很大，但是在外部看起来是一样的，比如LinkedList和ArrayList,设计良好的API使我们不需要去关注内部的实现，举个例子说，我们需要一个绳子，他可以是真丝制成的，那么它比较坚固，也可以是牛皮制成的，那么它可以不怕水，但是对使用绳子的人来说，他声明自己需要的绳子需要具有什么样的特性，但是他却不知道真丝的需要什么工艺，牛皮的又需要什么工艺。我们程序员就是使用绳子的人，各种各样的List就是绳子，虽然内部实现大相径庭，但是都对外开放了一条绳子的外表，使得我们可以极为方便的使用它，这体现了面向对象的编程思想，也可以使java程序员更加专注的实现功能而不尽量少的关心逻辑和算法。 ArrayList类 ArrayList内部基于数组实现,继承了AbstractList类，实现了Cloneable接口表示其可被克隆复制，实现了Serializable接口表示其可被序列化，实现了RandomAccess接口，表示其可快速随机访问（但是这个接口是空的，只是表示它具有这样的特性）。1public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements Cloneable, Serializable, RandomAccess&#123;&#125; 一些常量和成员 android中提供了最小容量，java中并没有这个成员，而是使用了10这个数字作为初始容量。 1234567//anrdroid源码//最小容量private static final int MIN_CAPACITY_INCREMENT = 12;//元素数量int size;//对象数组，transient表示在序列化时它会被忽略。。啥意思？transient Object[] array; 初始化指定初始容量构造 首先容量大于0，如果容量==0会使用EmptyArray.OBJECT来初始化，在android的源码里面链接不到EmptyArray这个类，去了这个网站看到了源码，EmptyArray.OBJECT是一个容量是0的数组。所以也就是说，如果指定容量==0则创建一个容量是0的对象数组，反之创建一个指定容量大小的数组。(java中没有做这个判断，本来这个判断就什么用) 1234567//android 源码public ArrayList(int capacity) &#123; if (capacity &lt; 0) &#123; throw new IllegalArgumentException("capacity &lt; 0: " + capacity); &#125; array = (capacity == 0 ? EmptyArray.OBJECT : new Object[capacity]); &#125; 无参构造函数 同上，初始容量是0。但是java源码中初始容量是10。 12345678//android 源码 public ArrayList() &#123; array = EmptyArray.OBJECT; &#125; //java源码 public ArrayList() &#123;this(10); &#125; 初始化时拷贝集合 主要的操作是判断是不是一个对象数组，如果是直接内部数组直接指向，如果不是进行一次拷贝，java中所有类都继承自Object。这是为了防止基本数据类型吗？（&lt;-这是我不懂的地方）用的方法不一样，java代码更少一点。 System.arraycopy()方法是native修饰的，使用C实现的底层方法。 Arrays.copyOf()函数内部也使用了System.arraycopy()方法。 就是我不懂的那个地方了,感觉使用这个方法可以解决不是对象数组的问题，但是不懂这个判断是为了什么，System.arraycopy又是如何内部实现的。 1234//android 源码if (a.getClass() != Object[].class) &#123;System.arraycopy(a, 0, newArray, 0, a.length);&#125; 1234567891011121314//android 源码public ArrayList(Collection&lt;? extends E&gt; collection) &#123; if (collection == null) &#123; throw new NullPointerException("collection == null"); &#125; Object[] a = collection.toArray(); if (a.getClass() != Object[].class) &#123; Object[] newArray = new Object[a.length]; System.arraycopy(a, 0, newArray, 0, a.length); a = newArray; &#125; array = a; size = a.length;&#125; 12345678//java源码public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); size = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class);&#125; Add方法Android中的实现123456789101112131415161718192021222324252627282930313233343536@Override public boolean add(E object) &#123; Object[] a = array; int s = size; if (s == a.length) &#123; Object[] newArray = new Object[s + (s &lt; (MIN_CAPACITY_INCREMENT / 2) ? MIN_CAPACITY_INCREMENT : s &gt;&gt; 1)]; System.arraycopy(a, 0, newArray, 0, s); array = a = newArray; &#125; a[s] = object; size = s + 1; modCount++; return true; &#125; @Override public void add(int index, E object) &#123; Object[] a = array; int s = size; if (index &gt; s || index &lt; 0) &#123; throwIndexOutOfBoundsException(index, s); &#125; if (s &lt; a.length) &#123; System.arraycopy(a, index, a, index + 1, s - index); &#125; else &#123; // assert s == a.length; Object[] newArray = new Object[newCapacity(s)]; System.arraycopy(a, 0, newArray, 0, index); System.arraycopy(a, index, newArray, index + 1, s - index); array = a = newArray; &#125; a[index] = object; size = s + 1; modCount++; &#125; Java中的实现 跟android基本一样的，之所以代码简单了，是因为java将判断扩容的操作放在了方法实现，但是androd只是将计算新容量的方法提取出来了。 123456789101112131415public boolean add(E e) &#123; ensureCapacity(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125;public void add(int index, E element) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException( "Index: "+index+", Size: "+size); ensureCapacity(size+1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; 核心代码分析 解释一下下面这段代码，在java中也是如此实现的只是提取到了方法中，会在下面的扩容机制中说明。 首先最后都进行了一个赋值操作a[index] = object;前面的代码的工作就是将这个位置空出来。代码5 如果当前的size没有超过length,则将index位置之后的位置向后移动一位，将index位置空出来（代码1），如果超过长度了，则进行一次扩容（代码2），将数据拷贝到新数组（代码3），再将数组后移一位（代码4） 它是怎么移动的呢？System.arraycopy(a, index, newArray, index + 1, s - index)了解参数的含义（src,源数组中开始复制的位置，dest,目标数组开始粘贴的位置，复制的长度），这样就明白了，包括代码1是一样的意思，a数组和newArray数组是相同的，将a中index开始的数据复制到newArray中index+1开始的位置，然后复制的长度是s-index,刚好index位置被空出来了，举个例子，数据a={21，22，23，25，26}，newArray={21，22，23，25，26},需要在3的位置插入一个24，则将3开始的size-index(5-3=2)长度的数组也就是25，26，复制到newArray中index+1(3+1=4)开始的位置，得到新数组21，22，23，空，25，26，然后array[3]=24; 123456789101112Object[] a = array;int s = size;if (s &lt; a.length) &#123;System.arraycopy(a, index, a, index + 1, s - index);//---1&#125; else &#123; Object[] newArray = new Object[newCapacity(s)];//---2System.arraycopy(a, 0, newArray, 0, index);//---3System.arraycopy(a, index, newArray, index + 1, s - index);//---4array = a = newArray;&#125;a[index] = object;//5size = s + 1; 扩容机制 单独拿出来是因为android和java扩容机制稍有不同 Android中的实现 扩容时，如果当前容量小于6则让其等于12，否则扩大为原来的两倍。 12345678private static int newCapacity(int currentCapacity) &#123;int increment = (currentCapacity &lt; (MIN_CAPACITY_INCREMENT / 2) ?MIN_CAPACITY_INCREMENT : currentCapacity &gt;&gt; 1);return currentCapacity + increment;&#125;//这只是计算了新的容量，真正的扩容如此实现Object[] newArray = new Object[newCapacity(s)];System.arraycopy(a, 0, newArray, 0, index); java中的实现, java中数组拷贝都是用Arrays.copyOf()方法的，基本原理相同。 可以发现java扩容将容量扩大到了原来容量的1.5倍。 这里有一行代码,看注释的意思是这个方法更加优化了，调皮的程序员a.大意是minCapacity 通常更加逼近size. 1if (newCapacity &lt; minCapacity) newCapacity = minCapacity; 123456789101112public void ensureCapacity(int minCapacity) &#123; modCount++; int oldCapacity = elementData.length; if (minCapacity &gt; oldCapacity) &#123; Object oldData[] = elementData; int newCapacity = (oldCapacity * 3)/2 + 1; if (newCapacity &lt; minCapacity) newCapacity = minCapacity; // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125;&#125; 综上 就是核心方法了吧，已经可以了解到它基本的原理，当然还有indexOf(),contains(),remove(),writeObject(),readObject(),内部迭代器的实现，toArray()的实现，set(),addAll()…..其中的原理与上面提到的很多都是相同的，感兴趣的可以自行了解，这里不介绍了，后面有时间再贴一下吧。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>SourceCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ListView Adapter 3]]></title>
    <url>%2Farticle%2F294185431%2F</url>
    <content type="text"><![CDATA[前言 上一篇文章介绍了如何进行分类适配，虽然比较完美的实现了分类适配以及复用，但是代码相当繁琐，我们有两种类型时已经出现了多层if嵌套，如果有三四种类型，估计自己都要转晕了，而且就像我们对单类型适配器抽象时做的，避免重复代码！如果没看过上一篇，建议浏览一下，这里写的很多都是基于第一篇的。 抽象ViewHolder12345678910111213141516171819202122232425public static class MultiViewHolder extends ViewHolder&#123; /** * SparseArray */ private SparseArray&lt;View&gt; cacheViews; private View itemView; public MultiViewHolder(View itemView, int viewCount) &#123; super(); this.itemView = itemView; cacheViews = new SparseArray&lt;View&gt;(viewCount); &#125; @Override public View getView(int resId) &#123; View v = cacheViews.get(resId); if (v == null) &#123; v = itemView.findViewById(resId); if (v != null) &#123; cacheViews.put(resId, v); &#125; &#125; return v; &#125;&#125; 使用接口获取对象的类型 我们在分类适配的时候不可避免的要获得数据的对象，以此作为根据装载不同的布局文件. 123456789/** 1. 接口，分类适配的对象需要实现的接口，目的是约束实体类实现getType方法 2. 3. @author chendong 4. */public interface MultiEasyAdapterInterface &#123; public int getType();&#125; 抽象分类适配器 我们需要避免在子类中避免重复编码，同时在子类实现自己的方法，使用抽象父类。 我们不了解传递进来的数据是什么类型，使用泛型。 我们需要限制传进来的数据必须实现获得获得子类的方法，所以必须要求数据实现MultiEasyAdapterInterface接口，使用泛型限定符确定上限。 12public abstract class MultiEasyAdapter&lt;T extends MultiEasyAdapterInterface&gt; extends BaseAdapter &#123;&#125; 成员变量12private LayoutInflater layoutInflater;private List&lt;T&gt; datas; 分析一下其他成员，根据上一篇传统分类适配的写法，我们姑且忽略类型的差异 每个类型需要一个布局资源文件id 每个类型布局文件中字UI控件的个数（用来优化） 每个类型一个唯一的键值（用来解决复用Item空指针的问题） 我们用一个实体类存储这些信息 123456789101112131415161718192021222324252627282930** * 存储类型信息的实体类 * * @author chendong * @功能：分类适配器配置信息实体类 */public class MultiEasyAdapterEntity &#123; /** * @param type * item类型，int类型变量，Item是什么类型的就填写什么类型 * @param resId * 资源id，对应类型的资源id，你需要装载的资源文件的ID * @param viewCount * 资源文件中对应的需要获取的视图的个数 */ public MultiEasyAdapterEntity(int type, int resId, int viewCount) &#123; super(); this.resId = resId; this.viewCount = viewCount; &#125; private int type; private int resId; private int viewCount; public MultiEasyAdapterEntity() &#123; super(); &#125;&#125; 可能有点繁琐，type和viewCount 可以省略掉，加入type是为了更灵活的获得数据类型，viewCount则是为了优化SparseArray,综上第三个成员变量，就是使用type作为键，MultiEasyAdapterEntity作为值的一个SparseArray，他的作用就是存储不同类型的数据适配时需要的配置信息，有点类似配置文件的意思。 1private SparseArray&lt;MultiEasyAdapterEntity&gt; Res4Type; 完善代码 结合分类适配的方法，变量我们已经存储到了SparseArray中，所以代码就很清晰了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/** * version 2&lt;br/&gt;注意事项：类型数为n时，那么定义的类型必须在0-n-1之间，这是使用listview自带缓存的要求。 * 抽象适配器升级版，可以进行分类适配，使用了模板方法模式，将设置item显示内容的部分抽象到了类外&lt;br/&gt; * @param &lt;T&gt; &lt;br/&gt;必须实现MultiEasyAdapterInterface接口&#123;@link MultiEasyAdapterInterface&#125;&lt;br/&gt; * @author chendong */public abstract class MultiEasyAdapter&lt;T extends MultiEasyAdapterInterface&gt; extends BaseAdapter &#123; private LayoutInflater layoutInflater; private List&lt;T&gt; datas; private SparseArray&lt;MultiEasyAdapterEntity&gt; Res4Type; private Context context; /** * @param context 上下文对象 * @param datas 数据集 * @param Res4Type 资源配置文件&#123;@link MultiEasyAdapterEntity&#125;this is like a config entity */ public MultiEasyAdapter(Context context, List&lt;T&gt; datas, SparseArray&lt;MultiEasyAdapterEntity&gt; Res4Type) &#123; super(); this.layoutInflater = LayoutInflater.from(context); this.datas = datas; this.Res4Type = Res4Type; this.context = context; &#125; protected Context getContext()&#123; return context; &#125; protected List&lt;T&gt; getDatas()&#123; return datas; &#125; public void swapData(List&lt;T&gt; datas)&#123; this.datas = datas; notifyDataSetChanged(); &#125; @Override public int getViewTypeCount() &#123; return Res4Type.size(); &#125; @Override public int getItemViewType(int position) &#123; return datas.get(position).getType(); &#125; public int getCount() &#123; return datas.size(); &#125; public Object getItem(int position) &#123; return datas.get(position); &#125; public long getItemId(int position) &#123; return position; &#125; public View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder holder = null; /* get the type*/ int type = datas.get(position).getType(); if (convertView == null) &#123; int resId = Res4Type.get(type).getResId(); convertView = layoutInflater.inflate(resId, parent, false); holder = new ViewHolder(convertView, Res4Type.get(type) .getViewCount()); convertView.setTag(holder); bindListener4View(holder,datas.get(position), type, position); &#125; else &#123; holder = (ViewHolder) convertView.getTag(); &#125; bindData4View(holder,datas.get(position), type, position); return convertView; &#125; /** * 绑定数据 * bind data * * @param holder the viewholder * @param type data&apos;s type * @param data data */ public abstract void bindData4View(ViewHolder holder, T data, int type,int pos); /** * 绑定监听 * bind listener * * @param holder the viewholder * @param type data&apos;s type * @param pos position */ public abstract void bindListener4View(ViewHolder holder, T data, int type,int pos);&#125; 测试1234567891011121314151617181920212223242526272829303132333435363738listview = (ListView) findViewById(R.id.listview); list = new ArrayList&lt;Student&gt;(); for (int i = 0; i &lt; 20; i++) &#123; if (i % 5 == 0) list.add(new Student(&quot;name&quot; + i, &quot;age&quot; + i, &quot;sex&quot;, 3)); else list.add(new Student(&quot;name&quot; + i, &quot;age&quot; + i, &quot;sex&quot;, i % 2 == 0 ? 1 : 2)); &#125; SparseArray&lt;MultiEasyAdapterEntity&gt; sparseArray = new SparseArray&lt;MultiEasyAdapterEntity&gt;( 3); sparseArray.put(1, new MultiEasyAdapterEntity(1, R.layout.item_type1, 4)); sparseArray.put(2, new MultiEasyAdapterEntity(2, R.layout.item_type2, 4)); sparseArray.put(3, new MultiEasyAdapterEntity(3, R.layout.item_type3, 4)); listview.setAdapter(new MultiEasyAdapter&lt;Student&gt;( getApplicationContext(), list, sparseArray) &#123; @Override public void bindData4View(ViewHolder holder, Student data, int type) &#123; ((TextView) holder.getView(R.id.tv_name)).setText(data .getName()); ((TextView) holder.getView(R.id.tv_sex)).setText(data.getSex()); ((TextView) holder.getView(R.id.tv_age)).setText(data.getAge() + &quot;&quot;); if (type == 3) ((TextView) holder.getView(R.id.tv_type)).setText(data .getType()+&quot;&quot;); &#125;@Override public void bindListener4View(ViewHolder holder, Student data, int type) &#123; //绑定监听事件 &#125; &#125;); 效果 大家可以看到三中布局适配的没有问题，只有蓝色背景的布局显示了type,他是类型3的数据]]></content>
      <categories>
        <category>Android</category>
        <category>Adapter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ListView</tag>
        <tag>Adapter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ListView Adapter 2]]></title>
    <url>%2Farticle%2F1720703307%2F</url>
    <content type="text"><![CDATA[前言 在使用适配器为ListView填充数据时，数据类型往往不是单一的，单一的数据显示太单调，对数据格式要求也比较高，我们在项目中往往使用网络请求获取json数据然后将其显示在Item中，此时获取的数据类型可能会有两到三种格式，此时就用到了分类适配，使用分类适配可以更加友好显示ListView。 既然需要分类适配，我们就必须拿到数据的类型，你的数据也就必须直接或者间接的实现获取类型的方法，其实ListView中已经包含了这个获取类型的方法，当然你也可以使用自己的获取类型的方法。 12345678910//重写以下两个方法，listview在内部会准备getViewTypeCount()个缓冲区，用来复用同种类型的View,不同类型的View不会出现复用错误。@Overridepublic int getItemViewType(int position) &#123; int type = Integer.parseInt(newsEntities.get(position).getType()); return type;&#125;@Overridepublic int getViewTypeCount() &#123; return count;&#125; 进行分类适配12345678910111213141516171819202122232425262728293031323334public View getView(int position, View convertView, ViewGroup parent) &#123; if (getItemViewType(position) == 1) &#123; ViewHolderVertical holder = null; if (convertView == null) &#123; convertView = layoutInflater.inflate( R.layout.item_firstpagelist_vertical, parent, false); holder = new ViewHolderVertical(); holder.iv = (ImageView) convertView .findViewById(R.id.item_firstpagelist_vertical_iv); //获取其他的控件.... convertView.setTag(holder); &#125; else &#123; holder = (ViewHolderVertical) convertView.getTag(); &#125; NewsEntity entity = newsEntities.get(position); //为控件设置显示的数据.... &#125; else &#123; ViewHolder holder = null; if (convertView == null) &#123; convertView = layoutInflater.inflate( R.layout.item_firstpagelist_horizontal, parent, false); holder = new ViewHolder(); holder.iv = (ImageView) convertView .findViewById(R.id.item_firstpagelist_iv); //获取其他的控件.... convertView.setTag(holder); &#125; else &#123; holder = (ViewHolder) convertView.getTag(); &#125; NewsEntity entity = newsEntities.get(position); //为控件设置显示的数据.... &#125; return convertView; &#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Adapter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ListView</tag>
        <tag>Adapter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ListView Adapter 1]]></title>
    <url>%2Farticle%2F4287006971%2F</url>
    <content type="text"><![CDATA[前言 介绍一下适配器的抽象，在我们做项目的时候会有很多很多地方使用ListView，也就意味着需要写很多很多的适配器，当我们写的项目很大时就会很烦很烦，每次都要写同样的代码片实现类似的功能，所以我们就有必要对传统的适配器抽象一下。 传统适配器的优化写法 核心代码就是getVIew()方法，在里面我们进行Item的复用，而相对于其他方法就会显得很多余，因为每个适配器都在重复相同的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class FirstpageGridAdapter extends BaseAdapter &#123; /* gridview数据 */ private String[] choices = new String[] &#123; &quot;新房&quot;, &quot;二手房&quot;, &quot;租房&quot;, &quot;资讯&quot;, &quot;打折优惠&quot;, &quot;最新开盘&quot;, &quot;房贷计算&quot;, &quot;更多&quot; &#125;; private int[] images = new int[] &#123; R.drawable.selector_xinfang, R.drawable.selector_ershou, R.drawable.selector_zufang, R.drawable.selector_zixun, R.drawable.selector_youhui, R.drawable.selector_kaipan, R.drawable.selector_calculator, R.drawable.selector_more &#125;; private LayoutInflater layoutInflater; private onClickChildIbListener listener; public FirstpageGridAdapter(Context context, onClickChildIbListener listener) &#123; super(); this.layoutInflater = LayoutInflater.from(context); this.listener = listener; &#125; public interface onClickChildIbListener &#123; public void clickChild(int pos,View view); &#125; public int getCount() &#123; return choices.length; &#125; public Object getItem(int position) &#123; return choices[position]; &#125; public long getItemId(int position) &#123; return position; &#125; public View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder holder = null; if (convertView == null) &#123; holder = new ViewHolder(); convertView = layoutInflater.inflate(R.layout.item_main_grid, parent, false); holder.ib = (ImageButton) convertView .findViewById(R.id.item_main_grid_ib); holder.tv = (TextView) convertView .findViewById(R.id.item_main_grid_tv); convertView.setTag(holder); &#125; else &#123; holder = (ViewHolder) convertView.getTag(); &#125; holder.ib.setBackgroundResource(images[position]); holder.tv.setText(choices[position]); final int pos = position; holder.ib.setOnClickListener(new OnClickListener() &#123; public void onClick(View v) &#123; listener.clickChild(pos,v); &#125; &#125;); return convertView; &#125; private class ViewHolder &#123; ImageButton ib; TextView tv; &#125;&#125; 抽象ViewHolder 我们可以分析一下ViewHolder类，它维护一个Item的一组UI组件，如果我们要使用使用通用的ViewHolder就会遇到一个问题，你不知道不同的布局有什么组件在里面，如何维护一组UI呢，数组？链表？或者Map?当查找View时我们使用id来进行查找，那么想在ViewHolder中查找View就需要使用id作为键，我们选择使用SparseArray，也就是稀疏数组，什么是稀疏数组，使用id（大整数）作为键值存储数据会造成大多数的未被使用，如果使用一般的表存储会造成很大的浪费，稀疏数组对数组进行了压缩，节约了很大空间，详见这里 1private SparseArray&lt;View&gt; cacheViews; 使用稀疏数组存储UI控件以后我们需要一个获取UI控件的方法，方法很清晰的，itemView是传递进来的父控件，就是convertView从中根据id获取控件 1234567891011@Override public View getView(int resId) &#123; View v = cacheViews.get(resId); if (v == null) &#123; v = itemView.findViewById(resId); if (v != null) &#123; cacheViews.put(resId, v); &#125; &#125; return v; &#125; ViewHolder完整代码，这里传入了一个viewCount,为什么呢？就像ArrayList一样，不定义空间大小时初始容量16，超出空间大小时每次增加25，但就是初始容量的16对于我们来说已经是浪费了，一个Item不可能有16个控件那么多。指定大小提高内存使用。 12345678910111213141516171819202122232425262728293031/** * * @author chendong * 用来实现复用加载的单类型ViewHolder * */ public static class SingleViewHolder&#123; /** * 使用SparseArray */ private SparseArray&lt;View&gt; cacheViews; private View itemView; public SingleViewHolder(View itemView, int viewCount) &#123; super(); this.itemView = itemView; cacheViews = new SparseArray&lt;View&gt;(viewCount); &#125; @Override public View getView(int resId) &#123; View v = cacheViews.get(resId); if (v == null) &#123; v = itemView.findViewById(resId); if (v != null) &#123; cacheViews.put(resId, v); &#125; &#125; return v; &#125; &#125; 抽象适配器 传统的适配器有太多的重复代码需要编写，我们可以把重复的代码在父类中编写好，使得子类可以直接复用，！使用抽象父类 父类的getView()方法中使用了一个抽象方法，使用了一个设计模式模板方法模式，将方法的实现推迟到了子类中 泛型，传递的数据类型是不确定的，使用泛型可以解决这个问题，泛型的使用不了解的建议搜一下，后面深入的介绍会使用更复杂的泛型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** 1. 抽象适配器，使用了模板方法模式，将设置item显示内容的部分抽象到了类外 这是单类型的抽象适配 2. 3. @author chendong 4. 5. @param &lt;T&gt; 6. 泛型 */public abstract class SingleEasyAdapter&lt;T&gt; extends BaseAdapter &#123; private LayoutInflater layoutInflater; private int resId; private List&lt;T&gt; datas; private int viewCount = 5; /** * @param context * 上下文对象，建议使用getApplicationContext(); * @param resId * item布局id * @param datas * 数据集 * @param viewCount * item中的view个数，用来优化SparseArray&lt;View&gt; */ public SingleEasyAdapter(Context context, int resId, List&lt;T&gt; datas, int viewCount) &#123; super(); this.layoutInflater = LayoutInflater.from(context); this.resId = resId; this.datas = datas; this.viewCount = viewCount; &#125; public int getCount() &#123; return datas.size(); &#125; public Object getItem(int position) &#123; return datas.get(position); &#125; public long getItemId(int position) &#123; return position; &#125; public View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder holder = null; if (convertView == null) &#123; convertView = layoutInflater.inflate(resId, parent, false); holder = new ViewHolder(convertView, viewCount); convertView.setTag(holder); //在这里绑定监听，避免重复绑定。 bindListener4View(holder, datas.get(position), position); &#125; else &#123; holder = (ViewHolder) convertView.getTag(); &#125; bindData4View(holder, datas.get(position), position); return convertView; &#125; /** * 绑定数据 * * @param holder * @param data */ public abstract void bindData4View(ViewHolder holder, T data, int pos); /** * 绑定监听 * * @param holder * @param pos */ public abstract void bindListener4View(ViewHolder holder, T data, int pos); &#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * 抽象适配器，使用了模板方法模式，将设置item显示内容的部分抽象到了类外 这是单类型的抽象适配 * * @param &lt;T&gt; 泛型 * @author chendong */public abstract class SingleEasyAdapter&lt;T&gt; extends BaseAdapter &#123; private LayoutInflater layoutInflater; private int resId; private List&lt;T&gt; datas; private int viewCount = 5; private Context context; /** * @param context 上下文对象，建议使用getApplicationContext(); * @param resId item布局id * @param datas 数据集 * @param viewCount item中的view个数，用来优化SparseArray&lt;View&gt; */ public SingleEasyAdapter(Context context, int resId, List&lt;T&gt; datas, int viewCount) &#123; super(); this.layoutInflater = LayoutInflater.from(context); this.resId = resId; this.datas = datas; this.viewCount = viewCount; this.context = context; &#125; public Context getContext() &#123; return this.context; &#125; public List&lt;T&gt; getData() &#123; return datas; &#125; public void swapData(List&lt;T&gt; datas) &#123; this.datas = datas; notifyDataSetChanged(); &#125; public int getCount() &#123; return datas.size(); &#125; public Object getItem(int position) &#123; return datas.get(position); &#125; public long getItemId(int position) &#123; return position; &#125; public View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder holder = null; if (convertView == null) &#123; convertView = layoutInflater.inflate(resId, parent, false); holder = new ViewHolder(convertView, viewCount); convertView.setTag(holder); //在这里绑定监听 bindListener4View(holder, datas.get(position), position); &#125; else &#123; holder = (ViewHolder) convertView.getTag(); &#125; bindData4View(holder, datas.get(position), position); return convertView; &#125; /** * 绑定数据 * * @param holder * @param data */ public abstract void bindData4View(ViewHolder holder, T data, int pos); /** * 绑定监听 * * @param holder * @param pos */ public abstract void bindListener4View(ViewHolder holder, T data, int pos);&#125; 测试123456789101112131415161718192021222324listview = (ListView) findViewById(R.id.listview); list = new ArrayList&lt;Student&gt;(); for (int i = 0; i &lt; 20; i++) &#123; if (i % 5 == 0) list.add(new Student(&quot;name&quot; + i, &quot;age&quot; + i, &quot;sex&quot;, 3)); else list.add(new Student(&quot;name&quot; + i, &quot;age&quot; + i, &quot;sex&quot;, i % 2 == 0 ? 1 : 2)); &#125; listview.setAdapter(new SingleEasyAdapter&lt;Student&gt;( getApplicationContext(), R.layout.item_type1, list, 4) &#123; @Override public void bindData4View(SingleViewHolder holder, Student data，int pos) &#123; ((TextView)holder.getView(R.id.tv_name)).setText(data.getName()); //此处省略若干代码 &#125;@Override public void bindListener4View(SingleViewHolder holder, Student data，int pos) &#123; //此处省略若干代码 &#125; &#125;); 效果 可以看到我们只用了很少的代码就完成了功能，而且很清晰，简单地适配不需要创建适配器类了，使用匿名的也很快就可以实现。演示有点丑，基本都实现了。 总结 将适配器抽象出来作为一个类库，再使用的时候就会简单很多很多，当然如果你的适配器数据很复杂，那么也可以继承抽象父类生成自己的类。!]]></content>
      <categories>
        <category>Android</category>
        <category>Adapter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ListView</tag>
        <tag>Adapter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap源码分析]]></title>
    <url>%2Farticle%2F1753510098%2F</url>
    <content type="text"><![CDATA[对 HashMap 源码的简单分析。 基本的数据结构有数组，链表，树，图。 数组的特点是长度固定，空间连续，占用内存很大，空间复杂度是O(n),但是寻址容易，时间复杂度O(1).总结：寻址容易，插入删除困难。 链表的特点是长度可变，存储空间离散，占用内存小，空间复杂度是O(1),但是寻址困难，时间复杂度为O(n).总结：寻址困难，插入删除容易。 哈希表基于数组结构，采用键值的方式存储数据，插入删除容易，寻址是根据键值直接查找数据，时间复杂度是O(1)，但是使用哈希值存储数据总会出现哈希冲突，解决哈希冲突的方法主要有，开放定址法（再散列），再哈希法，链地址法（拉链法），建立公共溢出区。缺点：存储空间填满时需要将其复制到另一个更大的数组结构中，并进行再哈希计算，这是哈希表内存占用的暴涨点，这是基于数组结构的一个缺点。哈希表不能以一种特定的顺序遍历数据结构中的所有数据，如果需要按序存储，使用哈希表并不合适。 介绍 HashMap是线程不安全的HashTable是线程安全的。 HashMap就是基于链地址法实现的数据存储。也就是链表的数组。 HashMap允许键 值 为null。HashTable是不允许的。 在Android和Java里面对HashMap的实现，稍有不同，开始我还以为是我的jdk有问题。 在HashMap的基础数组中，每一个数组项称之为一个桶，HashMap就是基于这种桶+链表的结构。 存储方式，使用key值取哈希，一般的算法是hash(key)/len获得他存放位置的下标，这样就将key与下标对应起来。 存储的数据结构 总结来说，HashMap就是数组+内部类（Entry）实现，Entry中具有下一个Entry的引用，由此构成了链表的结构。第一行的代码是用来对HashMap进行操作时使用的变量，比如迭代HashMap所有的子项，添加一个EntrySet到HashMap中，删除，修改。。。。 12private transient Set&lt;Entry&lt;K, V&gt;&gt; entrySet;transient HashMapEntry&lt;K, V&gt;[] table; HashMapEntry HashMap中有一个很重要的存储结构HashMapEntry,用来保存键值对，和下一个Entry的引用，这就形成了一个链表结构。 在Java中，这个静态内部类叫Entry,在android中叫HashMapEntry，在功能上应该是相似的。是一个存储数据的基础bean,关注一下源码： 123456789101112131415161718192021222324252627282930313233343536373839static class HashMapEntry&lt;K, V&gt; implements Entry&lt;K, V&gt; &#123; final K key; V value; final int hash; HashMapEntry&lt;K, V&gt; next; HashMapEntry(K key, V value, int hash, HashMapEntry&lt;K, V&gt; next) &#123; this.key = key; this.value = value; this.hash = hash; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final V setValue(V value) &#123; V oldValue = this.value; this.value = value; return oldValue; &#125; @Override public final boolean equals(Object o) &#123; if (!(o instanceof Entry)) &#123; return false; &#125; Entry&lt;?, ?&gt; e = (Entry&lt;?, ?&gt;) o; return Objects.equal(e.getKey(), key) &amp;&amp; Objects.equal(e.getValue(), value); &#125; @Override public final int hashCode() &#123; return (key == null ? 0 : key.hashCode()) ^ (value == null ? 0 : value.hashCode()); &#125; @Override public final String toString() &#123; return key + "=" + value; &#125;&#125; 哈希值的计算 存储数据是根据key的哈希值来存储的，类似这样的方法hash(key.hashcode()) Java和Android中对求哈希值的操作相似但是哈希算法不同，当进行存取操作时，key都需要使用这个算法进行中转。 在Android中使用的是Collections类下的静态方法及进行哈希计算，但是这里的h是key的hashcode(),看注释使用的是Wang/Jenkins哈希算法的变体,源代码： 1234567891011//java实现private static int secondaryHash(int h) &#123; // Spread bits to regularize both segment and index locations, // using variant of single-word Wang/Jenkins hash. h += (h &lt;&lt; 15) ^ 0xffffcd7d; h ^= (h &gt;&gt;&gt; 10); h += (h &lt;&lt; 3); h ^= (h &gt;&gt;&gt; 6); h += (h &lt;&lt; 2) + (h &lt;&lt; 14); return h ^ (h &gt;&gt;&gt; 16);&#125; 12345678//android实现static int hash(int h) &#123; // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125; put方法 检查键值是否为空，null时将存储到forNullEntry所在的链表中。 获取哈希值之后获得下标索引，检查key是否已经存在，是则替换，否则添加到当前链表，基本思想是这样的，几个不同的点 putForNullKey(value)方法，在Android和Java中都有实现，当键值为null时，分配一个数组的一项，这个数组指向key == null 的Entry 一个不同点，Java中是在添加Entry之后重新计算容量，而Android是在AddNewEntry之前进行。 扩容的方法都是扩大为原来的两倍。 在Android中的实现基本类似，使用Collections静态方法进行二次哈希计算，计算下表索引 123456789101112131415161718192021222324252627282930313233//在java中的实现代码:public V put(K key, V value) &#123; if (key == null) return putForNullKey(value); int hash = hash(key.hashCode()); //计算hash值，使用indexFor（）这个函数获得该哈希值对应数组下标，由此可以得到对应的那个链表。 int i = indexFor(hash, table.length ); for (Entry&lt;K,V&gt; e = table [i]; e != null; e = e.next) &#123; Object k; //关注这部分代码是替换掉已经存在的key对应的value if (e.hash == hash &amp;&amp; ((k = e.key ) == key || key.equals(k))) &#123; V oldValue = e. value; e. value = value; e.recordAccess( this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null ; &#125; //解释一下这部分代码，做的操作就是将新添加的Entry放在链表的头部，而原来的链表会接在这个新的Entry后面。void addEntry(int hash, K key, V value, int bucketIndex) &#123;//注意这里的bucketIndex是上一个函数得到的数组下标。取到该数组项链接的Entry给了临时变量eEntry&lt;K,V&gt; e = table [bucketIndex];//新建了一个Entry将其链接到了数组项上，然后把e给了新的Entry的Next,也就是后面的链表重新链接到了新的Entry后面，而新的Entry作为了该链表的第一项。table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e);//添加之后重新计算容量。if (size ++ &gt;= threshold) resize(2 * table.length );&#125; 12345678910111213141516171819202122232425262728293031//android中的实现@Override public V put(K key, V value) &#123; if (key == null) &#123; return putValueForNullKey(value); &#125; int hash = Collections.secondaryHash(key); HashMapEntry&lt;K, V&gt;[] tab = table; int index = hash &amp; (tab.length - 1); for (HashMapEntry&lt;K, V&gt; e = tab[index]; e != null; e = e.next) &#123; if (e.hash == hash &amp;&amp; key.equals(e.key)) &#123; preModify(e); V oldValue = e.value; e.value = value; return oldValue; &#125; &#125; // No entry for (non-null) key is present; create one modCount++; //注意这里是先进行扩容后进行添加的 if (size++ &gt; threshold) &#123; tab = doubleCapacity(); index = hash &amp; (tab.length - 1); &#125; addNewEntry(key, value, hash, index); return null;&#125;//Android添加代码就更简单了，不过也很好理解，操作与java中是一样的。不过方法很巧//妙，简化了代码，让我想起了InputStream is = new FileInputStream("path")is = new BufferedInputStream(is)`void addNewEntry(K key, V value, int hash, int index) &#123;table[index] = new HashMapEntry&lt;K, V&gt;(key, value, hash, table[index]);&#125; get方法 同样的获取hashcode,再哈希计算哈希值，获得下标索引，得到对应链表，遍历链表得到结果，在Java和Android中实现大同小异. 1234567891011121314//java中的实现public V get(Object key) &#123; if (key == null) return getForNullKey(); int hash = hash(key.hashCode()); for (Entry&lt;K,V&gt; e = table [indexFor(hash, table.length )]; e != null; e = e. next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value ; &#125; return null; &#125; 123456789101112131415161718//Android中的实现public V get(Object key) &#123; if (key == null) &#123; HashMapEntry&lt;K, V&gt; e = entryForNullKey; return e == null ? null : e.value; &#125; int hash = Collections.secondaryHash(key); HashMapEntry&lt;K, V&gt;[] tab = table; for (HashMapEntry&lt;K, V&gt; e = tab[hash &amp; (tab.length - 1)]; e != null; e = e.next) &#123; K eKey = e.key; if (eKey == key || (e.hash == hash &amp;&amp; key.equals(eKey))) &#123; return e.value; &#125; &#125; return null;&#125; 初始化 在Java和Android中HashMap的初始化略有不同,Android中初始容量是2，Java中初始容量是16。 Java实现 Java中的初始容量和负载因子是学习Java比较经典的内容，看一下Java中HashMap的默认构造方法 123456789static final int DEFAULT_INITIAL_CAPACITY = 16;static final float DEFAULT_LOAD_FACTOR = 0.75f;public HashMap() &#123;//默认的构造方法会初始化一个容量是16，负载因子0.75的HashMap,threshold有阈值的意思，就是当前容量可以承受的负载,当超过这个负载时就会进行扩容。this.loadFactor = DEFAULT_LOAD_FACTOR;threshold = (int )(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR );table = new Entry[DEFAULT_INITIAL_CAPACITY];init();&#125; 带有参数的构造方法实现 12345678910111213141516171819202122232425262728293031323334//指定容量和负载因子时会检查容量和负载因子的值是不是有问题//然后会进行一个位运算算法获得-》大于当前要求的容量的-》最小的2的幂//（也就是如果是7--》8如果是9--》16）public HashMap(int initialCapacity, float loadFactor) &#123;if (initialCapacity &lt; 0)throw new IllegalArgumentException("Illegal initial capacity: " +initialCapacity);if (initialCapacity &gt; MAXIMUM_CAPACITY)initialCapacity = MAXIMUM_CAPACITY;if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))throw new IllegalArgumentException("Illegal load factor: " +loadFactor);// Find a power of 2 &gt;= initialCapacity//算法原理：capacity初始为1，当capacity小于initialCapacity时左移一位，就是*2,直到找到大于当前要求的容量最小的2的幂int capacity = 1;while (capacity &lt; initialCapacity)capacity &lt;&lt;= 1;this.loadFactor = loadFactor;threshold = (int )(capacity * loadFactor);table = new Entry[capacity];init();&#125;//容量增加，transfer(newTable);会将原来的数据再哈希重新放入数据void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length ; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; Entry[] newTable = new Entry[newCapacity]; transfer(newTable); table = newTable; threshold = (int)(newCapacity * loadFactor); &#125; 在Android中的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//默认的初始最小容量是4，一个静态的初始数组的容量是最小容量无符号右移1位，也就是2，默认构造时，会将该静态数组交给table,这里有一行源码的注释（ Forces first put invocation to replace EMPTY_TABLE），意思是根据第一次put方法加入的数量来扩充数组，此时负载容量是-1，添加时会立刻扩充容量，这可能也是为什么Android中添加元素是先检查扩充容量再添加的原因。。在put时第一次百分百检测到容量不够，此时进行一次doubleCapacity()将容量加倍，在这个方法中会调用private static final int MINIMUM_CAPACITY = 4;private static final Entry[] EMPTY_TABLE = new HashMapEntry[MINIMUM_CAPACITY &gt;&gt;&gt; 1];public HashMap() &#123; table = (HashMapEntry&lt;K, V&gt;[]) EMPTY_TABLE; threshold = -1; // Forces first put invocation to replace EMPTY_TABLE&#125;//容量增长或初始化时会调用该方法，重置阈值，与Java稍有不同，使用固定的容量的3/4来作为阈值，Java中还要比较容量的大小，取Math.min(容量，)private HashMapEntry&lt;K, V&gt;[] doubleCapacity() &#123; HashMapEntry&lt;K, V&gt;[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; return oldTable; &#125; int newCapacity = oldCapacity * 2; HashMapEntry&lt;K, V&gt;[] newTable = makeTable(newCapacity); if (size == 0) &#123; return newTable; &#125; for (int j = 0; j &lt; oldCapacity; j++) &#123; /* * Rehash the bucket using the minimum number of field writes. * This is the most subtle and delicate code in the class. */ HashMapEntry&lt;K, V&gt; e = oldTable[j]; if (e == null) &#123; continue; &#125; int highBit = e.hash &amp; oldCapacity; HashMapEntry&lt;K, V&gt; broken = null; newTable[j | highBit] = e; for (HashMapEntry&lt;K, V&gt; n = e.next; n != null; e = n, n = n.next) &#123; int nextHighBit = n.hash &amp; oldCapacity; if (nextHighBit != highBit) &#123; if (broken == null) newTable[j | nextHighBit] = n; else broken.next = n; broken = e; highBit = nextHighBit; &#125; &#125; if (broken != null) broken.next = null; &#125; return newTable;&#125;private HashMapEntry&lt;K, V&gt;[] makeTable(int newCapacity) &#123; @SuppressWarnings("unchecked") HashMapEntry&lt;K, V&gt;[] newTable = (HashMapEntry&lt;K, V&gt;[]) new HashMapEntry[newCapacity]; table = newTable; //阈值时是容量的3/4,使用了位运算 threshold = (newCapacity &gt;&gt; 1) + (newCapacity &gt;&gt; 2); // 3/4 capacity return newTable;&#125;//同样的检查机制，然后使用了一个方法，又是Collections类中的方法Collections.roundUpToPowerOfTwo(capacity);，作用是一样的，将容量修改为大于输入容量的最小的2的幂。但是使用二进制实现，会不会更牛逼一点。public HashMap(int capacity) &#123; if (capacity &lt; 0) &#123; throw new IllegalArgumentException("Capacity: " + capacity); &#125; if (capacity == 0) &#123; @SuppressWarnings("unchecked") HashMapEntry&lt;K, V&gt;[] tab = (HashMapEntry&lt;K, V&gt;[]) EMPTY_TABLE; table = tab; threshold = -1; // Forces first put() to replace EMPTY_TABLE return; &#125; if (capacity &lt; MINIMUM_CAPACITY) &#123; capacity = MINIMUM_CAPACITY; &#125; else if (capacity &gt; MAXIMUM_CAPACITY) &#123; capacity = MAXIMUM_CAPACITY; &#125; else &#123; capacity = Collections.roundUpToPowerOfTwo(capacity); &#125; makeTable(capacity);&#125;//看不懂啊，应该收藏一下关于二进制的算法，高大上的别人都看不懂public static int roundUpToPowerOfTwo(int i) &#123; i--; // If input is a power of two, shift its high-order bit right. // "Smear" the high-order bit all the way to the right. i |= i &gt;&gt;&gt; 1; i |= i &gt;&gt;&gt; 2; i |= i &gt;&gt;&gt; 4; i |= i &gt;&gt;&gt; 8; i |= i &gt;&gt;&gt; 16; return i + 1;&#125; 更多 JDK1.8在容量过大时使用红黑树存储数据，事件复杂度O(logn),对于红黑树不是很了解，算法很菜，暂时放放吧。 阈值 = 容量 负载因子，当容量超过阈值时会进行扩容和再散列，此时是hashmap的内存占用的增长点，扩容会将容量扩大为原来的两倍然后将数据拷贝到新的区域进行再散列。但是这里有个问题不太懂：HashMap扩容，每次添加一个元素size++,当size&gt;阈值（容量负载因子）时进行扩容，但是HashMap是基于数组+链表的，添加的元素不一定集中到一个数组项。举个例子说，当一个hashmap容量是16，阈值就是12，此时添加的元素如果有12个了，但是却只是集中在某几个数组项所在 的链表中，那么此时进行扩容合适吗？暂时合理的解释是hash（）算法可以很好的将数据分散在所有的数组项中，那么这种比较也是比较合理的。 为什么要将初始容量计算得到大于该容量的最小的2的幂？我们可以看一下这个代码int index = hash &amp; (tab.length - 1);在java中有相同的设计是一个函数indexfor(int hash)在计算hashcode对应的数组下标时使用hash&amp;len-1代替了hash%len，只有在len是2的幂时，这两个方法才是等价不等效的。可能不太好理解，举个例子：len是16时，二进制10000，len-1是01111，如果得到的hash小于16时，比如是3吧，进行&amp;运算01111&amp;00011得到的结果是3，也就是本身。确实等价于3%16，再比如大于16，是19吧，再大也是一个意思，也就是01111&amp;10011得到的结果是3，等价于19%16，右数第5位以上的1都被过滤掉了，说这么多只是解释一下确实hash&amp;len-1等价于hash%len，但是使用位运算效率会大大提高，在源码中位运算随处可见。ps:我总觉的还有别的作用，但是没有了解到。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SourceCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView]]></title>
    <url>%2Farticle%2F2021227864%2F</url>
    <content type="text"><![CDATA[RecycerView 是 Design 包下的新控件，用来实现列表功能，相比原来的 ListView 和 GridView 要强大的多，并且有自动回收复用的机制，已经可以完全替代原先的列表控件了。 借助 LayoutManager 实现列表的展示方式，支持水平方向和垂直方向，支持列表、网格和瀑布流，支持自定义展示方式。 借助 ViewHolder 持有控件，用来回收和复用。 借助 ItemDecoration 为列表增加分割线，实际上是控制在每一项周边绘制不同的间隔。 借助 ItemAnimator 实现列表项更新动画。 借助 SnapHelper 可以实现类似 ViewPager 的效果。 借助 ItemTouchHelper 可以实现拖动、侧滑。 LayoutManager在代码中设置 LayoutManager，需要在设置 adapter 之前设置 LayoutManager 123456789101112RecyclerView.LayoutManager layoutManager = null;//线性布局，第二个参数支持水平垂直两种方向，第三个参数用来设置是否反向显示layoutManager = new LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false);//网格布局，第二个参数设置列数，第三个参数支持水平垂直两种方向，第四个参数用来设置是否反向显示layoutManager = new GridLayoutManager(this,3,GridLayoutManager.HORIZONTAL,false);//瀑布流布局，第一个参数设置列数，第二个参数支持水平垂直两种方向layoutManager = new StaggeredGridLayoutManager(3,StaggeredGridLayoutManager.VERTICAL);recyclerView.setLayoutManager(layoutManager); ViewHolder继承 Recycler.ViewHolder 实现自定义 ViewHolder 这里只是实现简单的功能，旨在介绍了解 RecyclerView 的使用。需要注意的一点是，RecyclerView 并没有实现 OnItemClickListener 事件，也就是我们无法直接获得 Item 的点击事件。采用的方法是在最外层的父布局添加点击事件来模拟 Item 点击。getAdapterPosition(); 函数获取当前 Item 在 Adapter 中的位置getLayoutPosition()); 函数获得当前 Item 在布局中的位置 123456789101112131415class CustomViewHolder extends RecyclerView.ViewHolder &#123; TextView tv; public CustomViewHolder(View itemView) &#123; super(itemView); tv = (TextView) itemView.findViewById(R.id.test_tv); itemView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.i("chendong", "点击了item" + getAdapterPosition() + " layout --" + getLayoutPosition()); &#125; &#125;); &#125;&#125; Adapter继承 Recycler.Adapter 实现适配器，下面是一个基本的实现，在实际过程中通常会封装来简化 Adapter，这里是我封装的一个类库，扩展了一些常用的功能 RecyclerView LightAdapter。 12345678910111213141516171819202122232425class ContentAdapter extends RecyclerView.Adapter&lt;CustomViewHolder&gt; &#123; public ContentAdapter() &#123; //在这里获得需要的参数 &#125; @Override public int getItemViewType(int position) &#123; // 获取数据的类型，用于多类型适配 return 0; &#125; @Override public CustomViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; // 获取对应类型的 ViewHolder,加载不同的布局，类似 ListView 中 getView() 的代码 View view = getLayoutInflater().inflate(R.layout.test, parent, false); return new CustomViewHolder(view); &#125; @Override public void onBindViewHolder(CustomViewHolder holder, int position) &#123; holder.tv.setText("a"); &#125; @Override public int getItemCount() &#123; //获取Item个数 return 0; &#125;&#125; 数据更新类似 ListView 的数据更新，但是开放了更多方法，支持局部更新，而不用更新整个列表。 12345678910111213141516// 更新列表adapter.notifyDataSetChanged();// 删除某一位置的Itemadapter.notifyItemRemoved(0);// 修改某一位置的Itemadapter.notifyItemChanged(0);// 向某一位置掺入Itemadapter.notifyItemInserted(0);// 将pos1的Item移动到pos2adapter.notifyItemMoved(0,1);// 通知部分Item改变adapter.notifyItemRangeChanged(0,4);// 向0-4的位置插入数据adapter.notifyItemRangeInserted(0,4);// 移除0-4的数据adapter.notifyItemRangeRemoved(0,4); 分割线RecyclerView 提供了插入分隔线的方法，但是是个抽象类，需要我们自己重写，并且没有实现好的默认分隔线。 1234567891011121314151617mReplyRv.addItemDecoration(new RecyclerView.ItemDecoration() &#123; // onDraw方法先于绘制Item @Override public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; super.onDraw(c, parent, state); &#125; // onDrawOver在绘制Item之后，一般我们选择复写其中一个即可。 @Override public void onDrawOver(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; super.onDrawOver(c, parent, state); &#125; // getItemOffsets 可以通过outRect.set()为每个Item设置一定的偏移量，主要用于绘制 @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; super.getItemOffsets(outRect, view, parent, state); &#125;&#125;); 动画效果RecyclerView 为数据的更新增加了动画效果，并且提供了一个默认的动画，我们可以通过实现 ItemAnimator 实现自己的动画效果。 1recyclerView.setItemAnimator(new DefaultItemAnimator()); ItemTouchHelper123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class ItemTouchHelperWrap &#123; public static &lt;D&gt; ItemTouchHelper init(final Activity activity, final List&lt;D&gt; datas, final RecyclerView.Adapter adapter, RecyclerView recyclerView) &#123; ItemTouchHelper itemTouchHelper = new ItemTouchHelper(new ItemTouchHelper.Callback() &#123; @Override public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) &#123; // getMovementFlags 用于设置是否处理拖拽事件和滑动事件 // 以及拖拽和滑动操作的方向，比如如果是列表类型的RecyclerView // 拖拽只有UP、DOWN两个方向，而如果是网格类型的则有UP、DOWN、LEFT、RIGHT四个方向 int dragFlags; int swipeFlags; if (recyclerView.getLayoutManager() instanceof GridLayoutManager) &#123; dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN | ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT; swipeFlags = 0; swipeFlags = ItemTouchHelper.START | ItemTouchHelper.END; &#125; else &#123; dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN; swipeFlags = ItemTouchHelper.START | ItemTouchHelper.END; &#125; return makeMovementFlags(dragFlags, swipeFlags); &#125; @Override public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) &#123; // 如果我们设置了非0的dragFlags // 那么当我们长按item的时候就会进入拖拽并在拖拽过程中不断回调onMove()方法 // 我们就在这个方法里获取当前拖拽的item和已经被拖拽到所处位置的item的ViewHolder // 有了这2个ViewHolder，我们就可以交换他们的数据集并调用Adapter的notifyItemMoved方法来刷新item int fromPos = viewHolder.getAdapterPosition(); int toPos = target.getAdapterPosition(); Log.e("chendong", "moved -&gt; " + fromPos + " " + toPos); if (fromPos &lt; toPos) &#123; for (int i = fromPos; i &lt; toPos; i++) &#123; Collections.swap(datas, i, i + 1); &#125; &#125; else &#123; for (int i = fromPos; i &gt; toPos; i--) &#123; Collections.swap(datas, i, i - 1); &#125; &#125; adapter.notifyItemMoved(fromPos, toPos); return true; &#125; @Override public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) &#123; int pos = viewHolder.getAdapterPosition(); adapter.notifyItemRemoved(pos); datas.remove(pos); &#125; @Override public void onSelectedChanged(RecyclerView.ViewHolder viewHolder, int actionState) &#123; //当长按选中item的时候（拖拽开始的时候）调用 if (actionState != ItemTouchHelper.ACTION_STATE_IDLE &amp;&amp; actionState != ItemTouchHelper.ACTION_STATE_SWIPE) &#123; viewHolder.itemView.setBackgroundColor(Color.LTGRAY); Vibrator vib = (Vibrator) activity.getSystemService(Service.VIBRATOR_SERVICE); vib.vibrate(70); &#125;// if (viewHolder != null) &#123;// getDefaultUIUtil().onSelected(((RvViewHolder) viewHolder).getView(R.id.item_quickadapter_title));// &#125; super.onSelectedChanged(viewHolder, actionState); &#125; @Override public void clearView(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) &#123; // 当手指松开的时候（拖拽完成的时候）调用 super.clearView(recyclerView, viewHolder); // getDefaultUIUtil().clearView(((RvViewHolder) viewHolder).getView(R.id.item_quickadapter_title)); viewHolder.itemView.setBackgroundColor(Color.WHITE); &#125; @Override public boolean isLongPressDragEnabled() &#123; return false; &#125; &#125;); itemTouchHelper.attachToRecyclerView(recyclerView); return itemTouchHelper; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义控件—继承ViewGroup]]></title>
    <url>%2Farticle%2F844112004%2F</url>
    <content type="text"><![CDATA[前言 继承ViewGroup是自定义控件的一般方法，根据需要选择需要继承的ViewGroup的子类，本章将使用纯代码添加控件,方式确实不直观，但是可以用来练习使用代码操作控件的方法，毕竟不是所有的代码都可以用xml文件代替。 案例介绍 这次的目的实现一个类似这样的组合控件，出现这种需求是因为需要在一个ListView中添加一个类似ListView的部分，但是数量很少，可以不需要使用ListView,而是使用动态添加控件的方式。 代码 完全使用代码来写控件，没有xml布局，调试的时候是个大问题，写的代码往往不能实时的显示在预览界面。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181public class SpecialItemView extends RelativeLayout &#123; //分析该布局定义以下组件 //图片 private ImageView imgIcon; //标题 private TextView txtTitle; //子标题 private TextView txtSubTitle; //专辑数量 private TextView txtNum; //右边更多按钮 private ImageButton ibArrow; //下方横线，因为最后一行是不显示横线的 private ImageView ivLine; /** * 代码中new时使用 * * @param context */ public SpecialItemView(Context context) &#123; this(context, null); &#125; /** * 在xml文件中使用 * * @param context * @param attrs */ public SpecialItemView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(context, attrs); &#125; /** * 初始化 * * @param context * @param attributeSet */ private void init(Context context, AttributeSet attributeSet) &#123; //获取屏幕宽度 int width = context.getResources().getDisplayMetrics().widthPixels; //设置当前控件的padding this.setPadding(6,10,6,10); //初始化控件 imgIcon = new ImageView(context); //LayoutParams对象用来控制控件在ViewGroup中显示的样子 RelativeLayout.LayoutParams layoutParams = new LayoutParams((int) (width*0.2),(int) (width*0.2)); //垂直居中相当于layout_centervertical=true layoutParams.addRule(CENTER_VERTICAL); //配置控件 imgIcon.setScaleType(ImageView.ScaleType.CENTER_CROP); imgIcon.setLayoutParams(layoutParams); //相当于android:id imgIcon.setId(R.id.sp_item_icon); imgIcon.setImageResource(R.mipmap.finding_zone_img); //添加控件到ViewGroup addView(imgIcon); //除了可以设置为具体的数值，也可以使用常量，相当于xml文件中使用android：layout_width = "wrap_content" layoutParams = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); //左边margin layoutParams.leftMargin = 20; //相当于android:aligntop="R.id.sp_item_icon" layoutParams.addRule(ALIGN_TOP, R.id.sp_item_icon); layoutParams.addRule(RIGHT_OF, R.id.sp_item_icon); //以下是textview的设置 txtTitle.setText("标题"); txtTitle = new TextView(context); txtTitle.setId(R.id.sp_item_title); txtTitle.setTextSize(TypedValue.COMPLEX_UNIT_SP,18); txtTitle.setTextColor(Color.BLACK); txtTitle.setLayoutParams(layoutParams); txtTitle.setSingleLine(); txtTitle.setEllipsize(TextUtils.TruncateAt.END); addView(txtTitle); txtSubTitle = new TextView(context); txtSubTitle.setId(R.id.sp_item_subtitle); layoutParams = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); //todo sp2dp layoutParams.addRule(CENTER_VERTICAL); layoutParams.addRule(ALIGN_LEFT, R.id.sp_item_title); txtSubTitle.setText("字标题"); //todo sp2dp txtSubTitle.setTextSize(TypedValue.COMPLEX_UNIT_SP, 16); txtSubTitle.setTextColor(Color.GRAY); txtSubTitle.setLayoutParams(layoutParams); txtSubTitle.setPadding(0,0,16,0); txtSubTitle.setSingleLine(); txtSubTitle.setEllipsize(TextUtils.TruncateAt.END); addView(txtSubTitle); txtNum = new TextView(context); txtNum.setId(R.id.sp_item_subtitle); layoutParams = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); //todo sp2dp layoutParams.addRule(ALIGN_LEFT, R.id.sp_item_title); layoutParams.addRule(ALIGN_BOTTOM, R.id.sp_item_icon); txtNum.setText("共有几张专辑"); //todo sp2dp txtNum.setTextSize(TypedValue.COMPLEX_UNIT_SP, 16); txtNum.setTextColor(Color.GRAY); txtNum.setLayoutParams(layoutParams); txtNum.setSingleLine(); txtNum.setEllipsize(TextUtils.TruncateAt.END); txtNum.setGravity(CENTER_VERTICAL); //图标必须经过setbounds Drawable leftD = ContextCompat.getDrawable(getContext(), R.mipmap.finding_album_img); leftD.setBounds(0, 0, 20, 0); txtNum.setCompoundDrawablesWithIntrinsicBounds(leftD, null, null, null); txtNum.setId(R.id.sp_item_num); addView(txtNum); ibArrow = new ImageButton(context); ibArrow.setId(R.id.sp_item_subtitle); layoutParams = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); //todo sp2dp layoutParams.addRule(CENTER_VERTICAL); layoutParams.addRule(ALIGN_PARENT_RIGHT); //todo sp2dp layoutParams.rightMargin = 16; ibArrow.setBackgroundResource(R.drawable.selector_more); //todo sp2dp ibArrow.setLayoutParams(layoutParams); addView(ibArrow); ivLine = new ImageView(context); layoutParams = new LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,1); layoutParams.addRule(ALIGN_LEFT,R.id.sp_item_title); layoutParams.addRule(BELOW,R.id.sp_item_num); //todo sp2dp layoutParams.topMargin=10; ivLine.setLayoutParams(layoutParams); ivLine.setBackgroundResource(R.drawable.shape_line); addView(ivLine); &#125; public void setTitle(String txt)&#123; txtTitle.setText(txt==null?"":txt); &#125; public void setSubTitle(String txt)&#123; txtSubTitle.setText(txt==null?"":txt); &#125; public void setNum(String txt)&#123; txtNum.setText(txt==null?"":txt); &#125; public void setShowLine(int xx)&#123; ivLine.setVisibility(xx); &#125; public void setImg(String url)&#123; Picasso.with(getContext()).load(url).into(imgIcon); &#125; public ImageView getImgIcon()&#123; return imgIcon; &#125; public ImageButton getImgArrow()&#123; return ibArrow; &#125; private OnMoreClick onMoreClick; public //使用接口将ibArrow点击事件传递出去 public interface OnMoreClick&#123; void click(); &#125;&#125; 在xml文件中使用1234&lt;com.march.himalayasfm.app.widgets.SpecialItemView android:layout_width="match_parent" android:layout_height="wrap_content" /&gt;]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CardView]]></title>
    <url>%2Farticle%2F2807458501%2F</url>
    <content type="text"><![CDATA[本文介绍 CardView 的用法 compile &#39;com.android.support:cardview-v7:21.+ xml文件1234567891011121314&lt;android.support.v7.widget.CardViewandroid:layout_marginTop="20dp" android:layout_width="wrap_content"android:layout_height="wrap_content"app:cardCornerRadius="10dp"app:cardElevation="5dp"app:contentPadding="10dp" app:cardPreventCornerOverlap="true"&gt;&lt;ImageView android:scaleType="centerCrop"android:src="@mipmap/test" android:layout_width="match_parent" android:layout_height="wrap_content"/&gt;&lt;/android.support.v7.widget.CardView&gt; 几个属性值1234567891011121314app:cardElevation=&quot;5dp&quot;//阴影app:cardElevation 阴影的大小app:cardMaxElevation 阴影最大高度app:cardBackgroundColor 卡片的背景色app:cardCornerRadius 卡片的圆角大小app:contentPadding 卡片内容于边距的间隔app:contentPaddingBottomapp:contentPaddingTopapp:contentPaddingLeftapp:contentPaddingRightapp:contentPaddingStartapp:contentPaddingEndapp:cardUseCompatPadding 设置内边距，V21+的版本和之前的版本仍旧具有一样的计算方式app:cardPreventConrerOverlap 在V20和之前的版本中添加内边距，这个属性为了防止内容和边角的重叠]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ADB命令大全]]></title>
    <url>%2Farticle%2F4015034291%2F</url>
    <content type="text"><![CDATA[ADB，即 Android Debug Bridge，它是 Android 开发/测试人员不可替代的强大工具，也是 Android 设备玩家的好玩具。 持续更新中，欢迎提 PR 和 Issue 补充指正，觉得有用的可以将 此 GitHub 仓库 Star 收藏备用。 注：有部分命令的支持情况可能与 Android 系统版本及定制 ROM 的实现有关。 基本用法 命令语法 为命令指定目标设备 启动/停止 查看 adb 版本 以 root 权限运行 adbd 指定 adb server 的网络端口 设备连接管理 查询已连接设备/模拟器 USB 连接 无线连接（需要借助 USB 线） 无线连接（无需借助 USB 线） 应用管理 查看应用列表 所有应用 系统应用 第三方应用 包名包含某字符串的应用 安装 APK 卸载应用 清除应用数据与缓存 查看前台 Activity 与应用交互 调起 Activity 调起 Service 发送广播 强制停止应用 文件管理 复制设备里的文件到电脑 复制电脑里的文件到设备 模拟按键/输入 电源键 菜单键 HOME 键 返回键 音量控制 媒体控制 点亮/熄灭屏幕 滑动解锁 输入文本 查看日志 Android 日志 按级别过滤日志 按 tag 和级别过滤日志 日志格式 清空日志 内核日志 查看设备信息 型号 电池状况 屏幕分辨率 屏幕密度 显示屏参数 android_id IMEI Android 系统版本 Mac 地址 CPU 信息 内存信息 更多硬件与系统属性 实用功能 屏幕截图 录制屏幕 重新挂载 system 分区为可写 查看连接过的 WiFi 密码 设置系统日期和时间 重启手机 检测设备是否已 root 使用 Monkey 进行压力测试 开启/关闭 WiFi 刷机相关命令 重启到 Recovery 模式 从 Recovery 重启到 Android 重启到 Fastboot 模式 通过 sideload 更新系统 更多 adb shell 命令 查看进程 查看实时资源占用情况 其它 adb 的非官方实现 致谢 参考链接 基本用法命令语法adb 命令的基本语法如下： 1adb [-d|-e|-s &lt;serialNumber&gt;] &lt;command&gt; 如果只有一个设备/模拟器连接时，可以省略掉 [-d|-e|-s &lt;serialNumber&gt;] 这一部分，直接使用 adb &lt;command&gt;。 为命令指定目标设备如果有多个设备/模拟器连接，则需要为命令指定目标设备。 参数 含义 -d 指定当前唯一通过 USB 连接的 Android 设备为命令目标 -e 指定当前唯一运行的模拟器为命令目标 -s &lt;serialNumber&gt; 指定相应 serialNumber 号的设备/模拟器为命令目标 在多个设备/模拟器连接的情况下较常用的是 -s &lt;serialNumber&gt; 参数，serialNumber 可以通过 adb devices 命令获取。如： 12345$ adb devicesList of devices attachedcf264b8f deviceemulator-5554 device 输出里的 cf264b8f 和 emulator-5554 即为 serialNumber。比如这时想指定 cf264b8f 这个设备来运行 adb 命令获取屏幕分辨率： 1adb -s cf264b8f shell wm size 遇到多设备/模拟器的情况均使用这几个参数为命令指定目标设备，下文中为简化描述，不再重复。 启动/停止启动 adb server 命令： 1adb start-server （一般无需手动执行此命令，在运行 adb 命令时若发现 adb server 没有启动会自动调起。） 停止 adb server 命令： 1adb kill-server 查看 adb 版本命令： 1adb version 示例输出： 12Android Debug Bridge version 1.0.36Revision 8f855a3d9b35-android 以 root 权限运行 adbdadb 的运行原理是 PC 端的 adb server 与手机端的守护进程 adbd 建立连接，然后 PC 端的 adb client 通过 adb server 转发命令，adbd 接收命令后解析运行。 所以如果 adbd 以普通权限执行，有些需要 root 权限才能执行的命令无法直接用 adb xxx 执行。这时可以 adb shell 然后 su 后执行命令，也可以让 adbd 以 root 权限执行，这个就能随意执行高权限命令了。 命令： 1adb root 正常输出： 1restarting adbd as root 现在再运行 adb shell，看看命令行提示符是不是变成 # 了？ 有些手机 root 后也无法通过 adb root 命令让 adbd 以 root 权限执行，比如三星的部分机型，会提示 adbd cannot run as root in production builds，此时可以先安装 adbd Insecure，然后 adb root 试试。 相应地，如果要恢复 adbd 为非 root 权限的话，可以使用 adb unroot 命令。 指定 adb server 的网络端口命令： 1adb -P &lt;port&gt; start-server 默认端口为 5037。 设备连接管理查询已连接设备/模拟器命令： 1adb devices 输出示例： 123List of devices attachedcf264b8f deviceemulator-5554 device 输出格式为 [serialNumber] [state]，serialNumber 即我们常说的 SN，state 有如下几种： offline —— 表示设备未连接成功或无响应。 device —— 设备已连接。注意这个状态并不能标识 Android 系统已经完全启动和可操作，在设备启动过程中设备实例就可连接到 adb，但启动完毕后系统才处于可操作状态。 no device —— 没有设备/模拟器连接。 以上输出显示当前已经连接了两台设备/模拟器，cf264b8f 与 emulator-5554 分别是它们的 SN。从 emulator-5554 这个名字可以看出它是一个 Android 模拟器。 常见异常输出： 没有设备/模拟器连接成功。 1List of devices attached 设备/模拟器未连接到 adb 或无响应。 12List of devices attachedcf264b8f offline USB 连接通过 USB 连接来正常使用 adb 需要保证几点： 硬件状态正常。 包括 Android 设备处于正常开机状态，USB 连接线和各种接口完好。 Android 设备的开发者选项和 USB 调试模式已开启。 可以到「设置」-「开发者选项」-「Android 调试」查看。 如果在设置里找不到开发者选项，那需要通过一个彩蛋来让它显示出来：在「设置」-「关于手机」连续点击「版本号」7 次。 设备驱动状态正常。 这一点貌似在 Linux 和 Mac OS X 下不用操心，在 Windows 下有可能遇到需要安装驱动的情况，确认这一点可以右键「计算机」-「属性」，到「设备管理器」里查看相关设备上是否有黄色感叹号或问号，如果没有就说明驱动状态已经好了。否则可以下载一个手机助手类程序来安装驱动先。 通过 USB 线连接好电脑和设备后确认状态。 1adb devices 如果能看到 1xxxxxx device 说明连接成功。 无线连接（需要借助 USB 线）除了可以通过 USB 连接设备与电脑来使用 adb，也可以通过无线连接——虽然连接过程中也有需要使用 USB 的步骤，但是连接成功之后你的设备就可以在一定范围内摆脱 USB 连接线的限制啦！ 操作步骤： 将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。 将设备与电脑通过 USB 线连接。 应确保连接成功（可运行 adb devices 看是否能列出该设备）。 让设备在 5555 端口监听 TCP/IP 连接： 1adb tcpip 5555 断开 USB 连接。 找到设备的 IP 地址。 一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到。 通过 IP 地址连接设备。 1adb connect &lt;device-ip-address&gt; 这里的 &lt;device-ip-address&gt; 就是上一步中找到的设备 IP 地址。 确认连接状态。 1adb devices 如果能看到 1&lt;device-ip-address&gt;:5555 device 说明连接成功。 如果连接不了，请确认 Android 设备与电脑是连接到了同一个 WiFi，然后再次执行 adb connect &lt;device-ip-address&gt; 那一步； 如果还是不行的话，通过 adb kill-server 重新启动 adb 然后从头再来一次试试。 断开无线连接 命令： 1adb disconnect &lt;device-ip-address&gt; 无线连接（无需借助 USB 线）注：需要 root 权限。 上一节「无线连接（需要借助 USB 线）」是官方文档里介绍的方法，需要借助于 USB 数据线来实现无线连接。 既然我们想要实现无线连接，那能不能所有步骤下来都是无线的呢？答案是能的。 在 Android 设备上安装一个终端模拟器。 已经安装过的设备可以跳过此步。我使用的终端模拟器下载地址是：Terminal Emulator for Android Downloads 将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。 打开 Android 设备上的终端模拟器，在里面依次运行命令： 12susetprop service.adb.tcp.port 5555 找到 Android 设备的 IP 地址。 一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到。 在电脑上通过 adb 和 IP 地址连接 Android 设备。 1adb connect &lt;device-ip-address&gt; 这里的 &lt;device-ip-address&gt; 就是上一步中找到的设备 IP 地址。 如果能看到 connected to &lt;device-ip-address&gt;:5555 这样的输出则表示连接成功。 应用管理查看应用列表查看应用列表的基本命令格式是 1adb shell pm list packages [-f] [-d] [-e] [-s] [-3] [-i] [-u] [--user USER_ID] [FILTER] 即在 adb shell pm list packages 的基础上可以加一些参数进行过滤查看不同的列表，支持的过滤参数如下： 参数 显示列表 无 所有应用 -f 显示应用关联的 apk 文件 -d 只显示 disabled 的应用 -e 只显示 enabled 的应用 -s 只显示系统应用 -3 只显示第三方应用 -i 显示应用的 installer -u 包含已卸载应用 &lt;FILTER&gt; 包名包含 &lt;FILTER&gt; 字符串 所有应用命令： 1adb shell pm list packages 输出示例： 12345678910111213package:com.android.smoketestpackage:com.example.android.livecubespackage:com.android.providers.telephonypackage:com.google.android.googlequicksearchboxpackage:com.android.providers.calendarpackage:com.android.providers.mediapackage:com.android.protipspackage:com.android.documentsuipackage:com.android.gallerypackage:com.android.externalstorage...// other packages here... 系统应用命令： 1adb shell pm list packages -s 第三方应用命令： 1adb shell pm list packages -3 包名包含某字符串的应用比如要查看包名包含字符串 mazhuang 的应用列表，命令： 1adb shell pm list packages mazhuang 当然也可以使用 grep 来过滤： 1adb shell pm list packages | grep mazhuang 安装 APK命令格式： 1adb install [-lrtsdg] &lt;path_to_apk&gt; 参数： adb install 后面可以跟一些可选参数来控制安装 APK 的行为，可用参数及含义如下： 参数 含义 -l 将应用安装到保护目录 /mnt/asec -r 允许覆盖安装 -t 允许安装 AndroidManifest.xml 里 application 指定 android:testOnly=&quot;true&quot; 的应用 -s 将应用安装到 sdcard -d 允许降级覆盖安装 -g 授予所有运行时权限 运行命令后如果见到类似如下输出（状态为 Success）代表安装成功： 123[100%] /data/local/tmp/1.apk pkg: /data/local/tmp/1.apkSuccess 上面是当前最新版 v1.0.36 的 adb 的输出，会显示 push apk 文件到手机的进度百分比。 使用旧版本 adb 的输出则是这样的： 12312040 KB/s (22205609 bytes in 1.801s) pkg: /data/local/tmp/SogouInput_android_v8.3_sweb.apkSuccess 而如果状态为 Failure 则表示安装失败，比如： 123[100%] /data/local/tmp/map-20160831.apk pkg: /data/local/tmp/map-20160831.apkFailure [INSTALL_FAILED_ALREADY_EXISTS] 常见安装失败输出代码、含义及可能的解决办法如下： 输出 含义 解决办法 INSTALL_FAILED_ALREADY_EXISTS 应用已经存在 使用 -r 参数 INSTALL_FAILED_INVALID_APK 无效的 APK 文件 INSTALL_FAILED_INVALID_URI 无效的 APK 文件名 确保 APK 文件名里无中文 INSTALL_FAILED_INSUFFICIENT_STORAGE 空间不足 清理空间 INSTALL_FAILED_DUPLICATE_PACKAGE 已经存在同名程序 INSTALL_FAILED_NO_SHARED_USER 请求的共享用户不存在 INSTALL_FAILED_UPDATE_INCOMPATIBLE 已经安装过签名不一样的同名应用，且数据没有移除 INSTALL_FAILED_SHARED_USER_INCOMPATIBLE 请求的共享用户存在但签名不一致 INSTALL_FAILED_MISSING_SHARED_LIBRARY 安装包使用了设备上不可用的共享库 INSTALL_FAILED_REPLACE_COULDNT_DELETE 替换时无法删除 INSTALL_FAILED_DEXOPT dex 优化验证失败或空间不足 INSTALL_FAILED_OLDER_SDK 设备系统版本低于应用要求 INSTALL_FAILED_CONFLICTING_PROVIDER 设备里已经存在与应用里同名的 content provider INSTALL_FAILED_NEWER_SDK 设备系统版本高于应用要求 INSTALL_FAILED_TEST_ONLY 应用是 test-only 的，但安装时没有指定 -t 参数 INSTALL_FAILED_CPU_ABI_INCOMPATIBLE 包含不兼容设备 CPU 应用程序二进制接口的 native code INSTALL_FAILED_MISSING_FEATURE 应用使用了设备不可用的功能 INSTALL_FAILED_CONTAINER_ERROR sdcard 访问失败 确认 sdcard 可用，或者安装到内置存储 INSTALL_FAILED_INVALID_INSTALL_LOCATION 不能安装到指定位置 切换安装位置，添加或删除 -s 参数 INSTALL_FAILED_MEDIA_UNAVAILABLE 安装位置不可用 一般为 sdcard，确认 sdcard 可用或安装到内置存储 INSTALL_FAILED_VERIFICATION_TIMEOUT 验证安装包超时 INSTALL_FAILED_VERIFICATION_FAILURE 验证安装包失败 INSTALL_FAILED_PACKAGE_CHANGED 应用与调用程序期望的不一致 INSTALL_FAILED_UID_CHANGED 以前安装过该应用，与本次分配的 UID 不一致 清除以前安装过的残留文件 INSTALL_FAILED_VERSION_DOWNGRADE 已经安装了该应用更高版本 使用 -d 参数 INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE 已安装 target SDK 支持运行时权限的同名应用，要安装的版本不支持运行时权限 INSTALL_PARSE_FAILED_NOT_APK 指定路径不是文件，或不是以 .apk 结尾 INSTALL_PARSE_FAILED_BAD_MANIFEST 无法解析的 AndroidManifest.xml 文件 INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION 解析器遇到异常 INSTALL_PARSE_FAILED_NO_CERTIFICATES 安装包没有签名 INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES 已安装该应用，且签名与 APK 文件不一致 先卸载设备上的该应用，再安装 INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING 解析 APK 文件时遇到 CertificateEncodingException INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME manifest 文件里没有或者使用了无效的包名 INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID manifest 文件里指定了无效的共享用户 ID INSTALL_PARSE_FAILED_MANIFEST_MALFORMED 解析 manifest 文件时遇到结构性错误 INSTALL_PARSE_FAILED_MANIFEST_EMPTY 在 manifest 文件里找不到找可操作标签（instrumentation 或 application） INSTALL_FAILED_INTERNAL_ERROR 因系统问题安装失败 INSTALL_FAILED_USER_RESTRICTED 用户被限制安装应用 INSTALL_FAILED_DUPLICATE_PERMISSION 应用尝试定义一个已经存在的权限名称 INSTALL_FAILED_NO_MATCHING_ABIS 应用包含设备的应用程序二进制接口不支持的 native code INSTALL_CANCELED_BY_USER 应用安装需要在设备上确认，但未操作设备或点了取消 在设备上同意安装 INSTALL_FAILED_ACWF_INCOMPATIBLE 应用程序与设备不兼容 does not contain AndroidManifest.xml 无效的 APK 文件 is not a valid zip file 无效的 APK 文件 Offline 设备未连接成功 先将设备与 adb 连接成功 unauthorized 设备未授权允许调试 error: device not found 没有连接成功的设备 先将设备与 adb 连接成功 protocol failure 设备已断开连接 先将设备与 adb 连接成功 Unknown option: -s Android 2.2 以下不支持安装到 sdcard 不使用 -s 参数 No space left on devicerm 空间不足 清理空间 Permission denied … sdcard … sdcard 不可用 参考：PackageManager.java adb install 内部原理简介 adb install 实际是分三步完成： push apk 文件到 /data/local/tmp。 调用 pm install 安装。 删除 /data/local/tmp 下的对应 apk 文件。 所以，必要的时候也可以根据这个步骤，手动分步执行安装过程。 卸载应用命令： 1adb uninstall [-k] &lt;packagename&gt; &lt;packagename&gt; 表示应用的包名，-k 参数可选，表示卸载应用但保留数据和缓存目录。 命令示例： 1adb uninstall com.qihoo360.mobilesafe 表示卸载 360 手机卫士。 清除应用数据与缓存命令： 1adb shell pm clear &lt;packagename&gt; &lt;packagename&gt; 表示应用名包，这条命令的效果相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据」。 命令示例： 1adb shell pm clear com.qihoo360.mobilesafe 表示清除 360 手机卫士的数据和缓存。 查看前台 Activity命令： 1adb shell dumpsys activity activities | grep mFocusedActivity 输出示例： 1mFocusedActivity: ActivityRecord&#123;8079d7e u0 com.cyanogenmod.trebuchet/com.android.launcher3.Launcher t42&#125; 其中的 com.cyanogenmod.trebuchet/com.android.launcher3.Launcher 就是当前处于前台的 Activity。 与应用交互主要是使用 am &lt;command&gt; 命令，常用的 &lt;command&gt; 如下： command 用途 start [options] &lt;INTENT&gt; 启动 &lt;INTENT&gt; 指定的 Activity startservice [options] &lt;INTENT&gt; 启动 &lt;INTENT&gt; 指定的 Service broadcast [options] &lt;INTENT&gt; 发送 &lt;INTENT&gt; 指定的广播 force-stop &lt;packagename&gt; 停止 &lt;packagename&gt; 相关的进程 &lt;INTENT&gt; 参数很灵活，和写 Android 程序时代码里的 Intent 相对应。 用于决定 intent 对象的选项如下： 参数 含义 -a &lt;ACTION&gt; 指定 action，比如 android.intent.action.VIEW -c &lt;CATEGORY&gt; 指定 category，比如 android.intent.category.APP_CONTACTS -n &lt;COMPONENT&gt; 指定完整 component 名，用于明确指定启动哪个 Activity，如 com.example.app/.ExampleActivity &lt;INTENT&gt; 里还能带数据，就像写代码时的 Bundle 一样： 参数 含义 --esn &lt;EXTRA_KEY&gt; null 值（只有 key 名） `-e –es ` string 值 --ez &lt;EXTRA_KEY&gt; &lt;EXTRA_BOOLEAN_VALUE&gt; boolean 值 --ei &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt; integer 值 --el &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt; long 值 --ef &lt;EXTRA_KEY&gt; &lt;EXTRA_FLOAT_VALUE&gt; float 值 --eu &lt;EXTRA_KEY&gt; &lt;EXTRA_URI_VALUE&gt; URI --ecn &lt;EXTRA_KEY&gt; &lt;EXTRA_COMPONENT_NAME_VALUE&gt; component name --eia &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;[,&lt;EXTRA_INT_VALUE...] integer 数组 --ela &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;[,&lt;EXTRA_LONG_VALUE...] long 数组 调起 Activity命令格式： 1adb shell am start [options] &lt;INTENT&gt; 例如： 1adb shell am start -n com.tencent.mm/.ui.LauncherUI 表示调起微信主界面。 1adb shell am start -n org.mazhuang.boottimemeasure/.MainActivity --es "toast" "hello, world" 表示调起 org.mazhuang.boottimemeasure/.MainActivity 并传给它 string 数据键值对 toast - hello, world。 调起 Service命令格式： 1adb shell am startservice [options] &lt;INTENT&gt; 例如： 1adb shell am startservice -n com.tencent.mm/.plugin.accountsync.model.AccountAuthenticatorService 表示调起微信的某 Service。 发送广播命令格式： 1adb shell am broadcast [options] &lt;INTENT&gt; 例如： 1adb shell am broadcast -a android.intent.action.BOOT_COMPLETED -n org.mazhuang.boottimemeasure/.BootCompletedReceiver 表示向 org.mazhuang.boottimemeasure/.BootCompletedReceiver 发送一个 BOOT_COMPLETED 广播，这类用法在测试的时候很实用，比如某个广播的场景很难制造，可以考虑通过这种方式来发送广播。 强制停止应用命令： 1adb shell am force-stop &lt;packagename&gt; 命令示例： 1adb shell am force-stop com.qihoo360.mobilesafe 表示停止 360 安全卫士的一切进程与服务。 文件管理复制设备里的文件到电脑命令： 1adb pull &lt;设备里的文件路径&gt; [电脑上的目录] 其中 电脑上的目录 参数可以省略，默认复制到当前目录。 例： 1adb pull /sdcard/sr.mp4 ~/tmp/ 小技巧：设备上的文件路径可能需要 root 权限才能访问，如果你的设备已经 root 过，可以先使用 adb shell 和 su 命令在 adb shell 里获取 root 权限后，先 cp /path/on/device /sdcard/filename 将文件复制到 sdcard，然后 adb pull /sdcard/filename /path/on/pc。 复制电脑里的文件到设备命令： 1adb push &lt;电脑上的文件路径&gt; &lt;设备里的目录&gt; 例： 1adb push ~/sr.mp4 /sdcard/ 小技巧：设备上的文件路径普通权限可能无法直接写入，如果你的设备已经 root 过，可以先 adb push /path/on/pc /sdcard/filename，然后 adb shell 和 su 在 adb shell 里获取 root 权限后，cp /sdcard/filename /path/on/device。 模拟按键/输入在 adb shell 里有个很实用的命令叫 input，通过它可以做一些有趣的事情。 input 命令的完整 help 信息如下： 12345678910111213141516171819202122Usage: input [&lt;source&gt;] &lt;command&gt; [&lt;arg&gt;...]The sources are: mouse keyboard joystick touchnavigation touchpad trackball stylus dpad gesture touchscreen gamepadThe commands and default sources are: text &lt;string&gt; (Default: touchscreen) keyevent [--longpress] &lt;key code number or name&gt; ... (Default: keyboard) tap &lt;x&gt; &lt;y&gt; (Default: touchscreen) swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen) press (Default: trackball) roll &lt;dx&gt; &lt;dy&gt; (Default: trackball) 比如使用 adb shell input keyevent &lt;keycode&gt; 命令，不同的 keycode 能实现不同的功能，完整的 keycode 列表详见 KeyEvent，摘引部分我觉得有意思的如下： keycode 含义 3 HOME 键 4 返回键 5 打开拨号应用 6 挂断电话 24 增加音量 25 降低音量 26 电源键 27 拍照（需要在相机应用里） 64 打开浏览器 82 菜单键 85 播放/暂停 86 停止播放 87 播放下一首 88 播放上一首 122 移动光标到行首或列表顶部 123 移动光标到行末或列表底部 126 恢复播放 127 暂停播放 164 静音 176 打开系统设置 187 切换应用 207 打开联系人 208 打开日历 209 打开音乐 210 打开计算器 220 降低屏幕亮度 221 提高屏幕亮度 223 系统休眠 224 点亮屏幕 231 打开语音助手 276 如果没有 wakelock 则让系统休眠 下面是 input 命令的一些用法举例。 电源键命令： 1adb shell input keyevent 26 执行效果相当于按电源键。 菜单键命令： 1adb shell input keyevent 82 HOME 键命令： 1adb shell input keyevent 3 返回键命令： 1adb shell input keyevent 4 音量控制增加音量： 1adb shell input keyevent 24 降低音量： 1adb shell input keyevent 25 静音： 1adb shell input keyevent 164 媒体控制播放/暂停： 1adb shell input keyevent 85 停止播放： 1adb shell input keyevent 86 播放下一首： 1adb shell input keyevent 87 播放上一首： 1adb shell input keyevent 88 恢复播放： 1adb shell input keyevent 126 暂停播放： 1adb shell input keyevent 127 点亮/熄灭屏幕可以通过上文讲述过的模拟电源键来切换点亮和熄灭屏幕，但如果明确地想要点亮或者熄灭屏幕，那可以使用如下方法。 点亮屏幕： 1adb shell input keyevent 224 熄灭屏幕： 1adb shell input keyevent 223 滑动解锁如果锁屏没有密码，是通过滑动手势解锁，那么可以通过 input swipe 来解锁。 命令（参数以机型 Nexus 5，向上滑动手势解锁举例）： 1adb shell input swipe 300 1000 300 500 参数 300 1000 300 500 分别表示起始点x坐标 起始点y坐标 结束点x坐标 结束点y坐标。 输入文本在焦点处于某文本框时，可以通过 input 命令来输入文本。 命令： 1adb shell input text hello 现在 hello 出现在文本框了。 查看日志Android 系统的日志分为两部分，底层的 Linux 内核日志输出到 /proc/kmsg，Android 的日志输出到 /dev/log。 Android 日志命令格式： 1[adb] logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ... 常用用法列举如下： 按级别过滤日志Android 的日志分为如下几个级别： V —— Verbose（最低，输出得最多） D —— Debug I —— Info W —— Warning E —— Error F —— Fatal S —— Silent（最高，啥也不输出） 按某级别过滤日志则会将该级别及以上的日志输出。 比如，命令： 1adb logcat *:W 会将 Warning、Error、Fatal 和 Silent 日志输出。 按 tag 和级别过滤日志比如，命令： 1adb logcat ActivityManager:I MyApp:D *:S 表示输出 tag ActivityManager 的 Info 以上级别日志，输出 tag MyApp 的 Debug 以上级别日志，及其它 tag 的 Silent 级别日志（即屏蔽其它 tag 日志）。 日志格式可以用 adb logcat -v &lt;format&gt; 选项指定日志输出格式。 日志支持按以下几种 &lt;format&gt;： brief 默认格式。格式为： 1&lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt; 示例： 1D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0 process 格式为： 1&lt;priority&gt;(&lt;pid&gt;) &lt;message&gt; 示例： 1D( 1785) Disconnected process message: 10, size: 0 (HeadsetStateMachine) tag 格式为： 1&lt;priority&gt;/&lt;tag&gt;: &lt;message&gt; 示例： 1D/HeadsetStateMachine: Disconnected process message: 10, size: 0 raw 格式为： 1&lt;message&gt; 示例： 1Disconnected process message: 10, size: 0 time 格式为： 1&lt;datetime&gt; &lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt; 示例： 108-28 22:39:39.974 D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0 threadtime 格式为： 1&lt;datetime&gt; &lt;pid&gt; &lt;tid&gt; &lt;priority&gt; &lt;tag&gt;: &lt;message&gt; 示例： 108-28 22:39:39.974 1785 1832 D HeadsetStateMachine: Disconnected process message: 10, size: 0 long 格式为： 12[ &lt;datetime&gt; &lt;pid&gt;:&lt;tid&gt; &lt;priority&gt;/&lt;tag&gt; ]&lt;message&gt; 示例： 12[ 08-28 22:39:39.974 1785: 1832 D/HeadsetStateMachine ]Disconnected process message: 10, size: 0 指定格式可与上面的过滤同时使用。比如： 1adb logcat -v long ActivityManager:I *:S 清空日志1adb logcat -c 内核日志命令： 1adb shell dmesg 输出示例： 1234567&lt;6&gt;[14201.684016] PM: noirq resume of devices complete after 0.982 msecs&lt;6&gt;[14201.685525] PM: early resume of devices complete after 0.838 msecs&lt;6&gt;[14201.753642] PM: resume of devices complete after 68.106 msecs&lt;4&gt;[14201.755954] Restarting tasks ... done.&lt;6&gt;[14201.771229] PM: suspend exit 2016-08-28 13:31:32.679217193 UTC&lt;6&gt;[14201.872373] PM: suspend entry 2016-08-28 13:31:32.780363596 UTC&lt;6&gt;[14201.872498] PM: Syncing filesystems ... done. 中括号里的 [14201.684016] 代表内核开始启动后的时间，单位为秒。 通过内核日志我们可以做一些事情，比如衡量内核启动时间，在系统启动完毕后的内核日志里找到 Freeing init memory 那一行前面的时间就是。 查看设备信息型号命令： 1adb shell getprop ro.product.model 输出示例： 1Nexus 5 电池状况命令： 1adb shell dumpsys battery 输入示例： 123456789101112Current Battery Service state: AC powered: false USB powered: true Wireless powered: false status: 2 health: 2 present: true level: 44 scale: 100 voltage: 3872 temperature: 280 technology: Li-poly 其中 scale 代表最大电量，level 代表当前电量。上面的输出表示还剩下 44% 的电量。 屏幕分辨率命令： 1adb shell wm size 输出示例： 1Physical size: 1080x1920 该设备屏幕分辨率为 1080px * 1920px。 屏幕密度命令： 1adb shell wm density 输出示例： 1Physical density: 420 该设备屏幕密度为 420dpi。 显示屏参数命令： 1adb shell dumpsys window displays 输出示例： 1234WINDOW MANAGER DISPLAY CONTENTS (dumpsys window displays) Display: mDisplayId=0 init=1080x1920 420dpi cur=1080x1920 app=1080x1794 rng=1080x1017-1810x1731 deferred=false layoutNeeded=false 其中 mDisplayId 为 显示屏编号，init 是初始分辨率和屏幕密度，app 的高度比 init 里的要小，表示屏幕底部有虚拟按键，高度为 1920 - 1794 = 126px 合 42dp。 android_id命令： 1adb shell settings get secure android_id 输出示例： 151b6be48bac8c569 IMEI在 Android 4.4 及以下版本可通过如下命令获取 IMEI： 1adb shell dumpsys iphonesubinfo 输出示例： 123Phone Subscriber Info: Phone Type = GSM Device ID = 860955027785041 其中的 Device ID 就是 IMEI。 而在 Android 5.0 及以上版本里这个命令输出为空，得通过其它方式获取了（需要 root 权限）： 123adb shellsuservice call iphonesubinfo 1 输出示例： 1234Result: Parcel( 0x00000000: 00000000 0000000f 00360038 00390030 '........8.6.0.9.' 0x00000010: 00350035 00320030 00370037 00350038 '5.5.0.2.7.7.8.5.' 0x00000020: 00340030 00000031 '0.4.1... ') 把里面的有效内容提取出来就是 IMEI 了，比如这里的是 860955027785041。 参考：adb shell dumpsys iphonesubinfo not working since Android 5.0 Lollipop Android 系统版本命令： 1adb shell getprop ro.build.version.release 输出示例： 15.0.2 Mac 地址命令： 1adb shell cat /sys/class/net/wlan0/address 输出示例： 1f8:a9:d0:17:42:4d CPU 信息命令： 1adb shell cat /proc/cpuinfo 输出示例： 1234567891011121314151617181920212223Processor : ARMv7 Processor rev 0 (v7l)processor : 0BogoMIPS : 38.40processor : 1BogoMIPS : 38.40processor : 2BogoMIPS : 38.40processor : 3BogoMIPS : 38.40Features : swp half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivtCPU implementer : 0x51CPU architecture: 7CPU variant : 0x2CPU part : 0x06fCPU revision : 0Hardware : Qualcomm MSM 8974 HAMMERHEAD (Flattened Device Tree)Revision : 000bSerial : 0000000000000000 这是 Nexus 5 的 CPU 信息，我们从输出里可以看到使用的硬件是 Qualcomm MSM 8974，processor 的编号是 0 到 3，所以它是四核的，采用的架构是 ARMv7 Processor rev 0 (v71)。 内存信息命令： 1adb shell cat /proc/meminfo 输出示例： 12345678910111213141516171819202122232425262728293031323334353637MemTotal: 1027424 kBMemFree: 486564 kBBuffers: 15224 kBCached: 72464 kBSwapCached: 24152 kBActive: 110572 kBInactive: 259060 kBActive(anon): 79176 kBInactive(anon): 207736 kBActive(file): 31396 kBInactive(file): 51324 kBUnevictable: 3948 kBMlocked: 0 kBHighTotal: 409600 kBHighFree: 132612 kBLowTotal: 617824 kBLowFree: 353952 kBSwapTotal: 262140 kBSwapFree: 207572 kBDirty: 0 kBWriteback: 0 kBAnonPages: 265324 kBMapped: 47072 kBShmem: 1020 kBSlab: 57372 kBSReclaimable: 7692 kBSUnreclaim: 49680 kBKernelStack: 4512 kBPageTables: 5912 kBNFS_Unstable: 0 kBBounce: 0 kBWritebackTmp: 0 kBCommitLimit: 775852 kBCommitted_AS: 13520632 kBVmallocTotal: 385024 kBVmallocUsed: 61004 kBVmallocChunk: 209668 kB 其中，MemTotal 就是设备的总内存，MemFree 是当前空闲内存。 更多硬件与系统属性设备的更多硬件与系统属性可以通过如下命令查看： 1adb shell cat /system/build.prop 这会输出很多信息，包括前面几个小节提到的「型号」和「Android 系统版本」等。 输出里还包括一些其它有用的信息，它们也可通过 adb shell getprop &lt;属性名&gt; 命令单独查看，列举一部分属性如下： 属性名 含义 ro.build.version.sdk SDK 版本 ro.build.version.release Android 系统版本 ro.build.version.security_patch Android 安全补丁程序级别 ro.product.model 型号 ro.product.brand 品牌 ro.product.name 设备名 ro.product.board 处理器型号 ro.product.cpu.abilist CPU 支持的 abi 列表 persist.sys.isUsbOtgEnabled 是否支持 OTG dalvik.vm.heapsize 每个应用程序的内存上限 ro.sf.lcd_density 屏幕密度 实用功能屏幕截图命令： 1adb shell screencap -p /sdcard/sc.png 然后将 png 文件导出到电脑： 1adb pull /sdcard/sc.png 可以使用 adb shell screencap -h 查看 screencap 命令的帮助信息，下面是两个有意义的参数及含义： 参数 含义 -p 指定保存文件为 png 格式 -d display-id 指定截图的显示屏编号（有多显示屏的情况下） 实测如果指定文件名以 .png 结尾时可以省略 -p 参数；否则需要使用 -p 参数。如果不指定文件名，截图文件的内容将直接输出到 stdout。 录制屏幕录制屏幕以 mp4 格式保存到 /sdcard： 1adb shell screenrecord /sdcard/filename.mp4 需要停止时按 Ctrl-C，默认录制时间和最长录制时间都是 180 秒。 如果需要导出到电脑： 1adb pull /sdcard/filename.mp4 可以使用 adb shell screenrecord --help 查看 screenrecord 命令的帮助信息，下面是常见参数及含义： 参数 含义 –size WIDTHxHEIGHT 视频的尺寸，比如 1280x720，默认是屏幕分辨率。 –bit-rate RATE 视频的比特率，默认是 4Mbps。 –time-limit TIME 录制时长，单位秒。 –verbose 输出更多信息。 重新挂载 system 分区为可写注：需要 root 权限。 /system 分区默认挂载为只读，但有些操作比如给 Android 系统添加命令、删除自带应用等需要对 /system 进行写操作，所以需要重新挂载它为可读写。 步骤： 进入 shell 并切换到 root 用户权限。 命令： 12adb shellsu 查看当前分区挂载情况。 命令： 1mount 输出示例： 12345678910111213141516171819202122232425rootfs / rootfs ro,relatime 0 0tmpfs /dev tmpfs rw,seclabel,nosuid,relatime,mode=755 0 0devpts /dev/pts devpts rw,seclabel,relatime,mode=600 0 0proc /proc proc rw,relatime 0 0sysfs /sys sysfs rw,seclabel,relatime 0 0selinuxfs /sys/fs/selinux selinuxfs rw,relatime 0 0debugfs /sys/kernel/debug debugfs rw,relatime 0 0none /var tmpfs rw,seclabel,relatime,mode=770,gid=1000 0 0none /acct cgroup rw,relatime,cpuacct 0 0none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0tmpfs /mnt/asec tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0tmpfs /mnt/obb tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0none /dev/memcg cgroup rw,relatime,memory 0 0none /dev/cpuctl cgroup rw,relatime,cpu 0 0none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0none /sys/fs/cgroup/freezer cgroup rw,relatime,freezer 0 0/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/userdata /data ext4 rw,seclabel,nosuid,nodev,relatime,noauto_da_alloc,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/cache /cache ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/persist /persist ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/modem /firmware vfat ro,context=u:object_r:firmware_file:s0,relatime,uid=1000,gid=1000,fmask=0337,dmask=0227,codepage=cp437,iocharset=iso8859-1,shortname=lower,errors=remount-ro 0 0/dev/fuse /mnt/shell/emulated fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0/dev/fuse /mnt/shell/emulated/0 fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0 找到其中我们关注的带 /system 的那一行： 1/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0 重新挂载。 命令： 1mount -o remount,rw -t yaffs2 /dev/block/platform/msm_sdcc.1/by-name/system /system 这里的 /dev/block/platform/msm_sdcc.1/by-name/system 就是我们从上一步的输出里得到的文件路径。 如果输出没有提示错误的话，操作就成功了，可以对 /system 下的文件为所欲为了。 查看连接过的 WiFi 密码注：需要 root 权限。 命令： 123adb shellsucat /data/misc/wifi/*.conf 输出示例： 123456789101112131415161718network=&#123; ssid="TP-LINK_9DFC" scan_ssid=1 psk="123456789" key_mgmt=WPA-PSK group=CCMP TKIP auth_alg=OPEN sim_num=1 priority=13893&#125;network=&#123; ssid="TP-LINK_F11E" psk="987654321" key_mgmt=WPA-PSK sim_num=1 priority=17293&#125; ssid 即为我们在 WLAN 设置里看到的名称，psk 为密码，key_mgmt 为安全加密方式。 设置系统日期和时间注：需要 root 权限。 命令： 123adb shellsudate -s 20160823.131500 表示将系统日期和时间更改为 2016 年 08 月 23 日 13 点 15 分 00 秒。 重启手机命令： 1adb reboot 检测设备是否已 root命令： 12adb shellsu 此时命令行提示符是 $ 则表示没有 root 权限，是 # 则表示已 root。 使用 Monkey 进行压力测试Monkey 可以生成伪随机用户事件来模拟单击、触摸、手势等操作，可以对正在开发中的程序进行随机压力测试。 简单用法： 1adb shell monkey -p &lt;packagename&gt; -v 500 表示向 &lt;packagename&gt; 指定的应用程序发送 500 个伪随机事件。 Monkey 的详细用法参考 官方文档。 开启/关闭 WiFi注：需要 root 权限。 有时需要控制设备的 WiFi 状态，可以用以下指令完成。 开启 WiFi： 12adb rootadb shell svc wifi enable 关闭 WiFi： 12adb rootadb shell svc wifi disable 若执行成功，输出为空；若未取得 root 权限执行此命令，将执行失败，输出 Killed。 刷机相关命令重启到 Recovery 模式命令： 1adb reboot recovery 从 Recovery 重启到 Android命令： 1adb reboot 重启到 Fastboot 模式命令： 1adb reboot bootloader 通过 sideload 更新系统如果我们下载了 Android 设备对应的系统更新包到电脑上，那么也可以通过 adb 来完成更新。 以 Recovery 模式下更新为例： 重启到 Recovery 模式。 命令： 1adb reboot recovery 在设备的 Recovery 界面上操作进入 Apply update-Apply from ADB。 注：不同的 Recovery 菜单可能与此有差异，有的是一级菜单就有 Apply update from ADB。 通过 adb 上传和更新系统。 命令： 1adb sideload &lt;path-to-update.zip&gt; 更多 adb shell 命令Android 系统是基于 Linux 内核的，所以 Linux 里的很多命令在 Android 里也有相同或类似的实现，在 adb shell 里可以调用。本文档前面的部分内容已经用到了 adb shell 命令。 查看进程命令： 1adb shell ps 输出示例： 12345678USER PID PPID VSIZE RSS WCHAN PC NAMEroot 1 0 8904 788 ffffffff 00000000 S /initroot 2 0 0 0 ffffffff 00000000 S kthreadd...u0_a71 7779 5926 1538748 48896 ffffffff 00000000 S com.sohu.inputmethod.sogou:classicu0_a58 7963 5926 1561916 59568 ffffffff 00000000 S org.mazhuang.boottimemeasure...shell 8750 217 10640 740 00000000 b6f28340 R ps 各列含义： 列名 含义 USER 所属用户 PID 进程 ID PPID 父进程 ID NAME 进程名 查看实时资源占用情况命令： 1adb shell top 输出示例： 1234567891011121314User 0%, System 6%, IOW 0%, IRQ 0%User 3 + Nice 0 + Sys 21 + Idle 280 + IOW 0 + IRQ 0 + SIRQ 3 = 307 PID PR CPU% S #THR VSS RSS PCY UID Name 8763 0 3% R 1 10640K 1064K fg shell top 131 0 3% S 1 0K 0K fg root dhd_dpc 6144 0 0% S 115 1682004K 115916K fg system system_server 132 0 0% S 1 0K 0K fg root dhd_rxf 1731 0 0% S 6 20288K 788K fg root /system/bin/mpdecision 217 0 0% S 6 18008K 356K fg shell /sbin/adbd ... 7779 2 0% S 19 1538748K 48896K bg u0_a71 com.sohu.inputmethod.sogou:classic 7963 0 0% S 18 1561916K 59568K fg u0_a58 org.mazhuang.boottimemeasure ... 各列含义： 列名 含义 PID 进程 ID PR 优先级 CPU% 当前瞬间占用 CPU 百分比 S 进程状态（R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程） #THR 线程数 VSS Virtual Set Size 虚拟耗用内存（包含共享库占用的内存） RSS Resident Set Size 实际使用物理内存（包含共享库占用的内存） PCY 调度策略优先级，SP_BACKGROUND/SPFOREGROUND UID 进程所有者的用户 ID NAME 进程名 top 命令还支持一些命令行参数，详细用法如下： 1234567Usage: top [ -m max_procs ] [ -n iterations ] [ -d delay ] [ -s sort_column ] [ -t ] [ -h ] -m num 最多显示多少个进程 -n num 刷新多少次后退出 -d num 刷新时间间隔（单位秒，默认值 5） -s col 按某列排序（可用 col 值：cpu, vss, rss, thr） -t 显示线程信息 -h 显示帮助文档 其它如下是其它常用命令的简单描述，前文已经专门讲过的命令不再额外说明： 命令 功能 cat 显示文件内容 cd 切换目录 chmod 改变文件的存取模式/访问权限 df 查看磁盘空间使用情况 grep 过滤输出 kill 杀死指定 PID 的进程 ls 列举目录内容 mount 挂载目录的查看和管理 mv 移动或重命名文件 ps 查看正在运行的进程 rm 删除文件 top 查看进程的资源占用情况 adb 的非官方实现 fb-adb - A better shell for Android devices (for Mac). 致谢感谢朋友们无私的分享与补充。 zxning linhua55 codeskyblue seasonyuu fan123199 参考链接 Android Debug Bridge ADB Shell Commands logcat Command-line Tool Android ADB命令大全 adb 命令行的使用记录 Android ADB命令大全(通过ADB命令查看wifi密码、MAC地址、设备信息、操作文件、查看文件、日志信息、卸载、启动和安装APK等) 那些做Android开发必须知道的ADB命令 adb shell top 像高手一样使用ADB命令行（2）]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AndroidTips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JaveIO流之压缩流(zip,Gzip)]]></title>
    <url>%2Farticle%2F837682646%2F</url>
    <content type="text"><![CDATA[JAVAIO流是java的一个很重要的部分，清晰有很复杂，各种各样的流分管不同的功能。正确使用IO流可以让你的输入输出效率增加，这篇博客主要说一下压缩流的使用，使用JAVA内置API压缩解压缩文件。 ZIP压缩主要的用到的API是123ZipFileZipInputStreamZipOutputStream 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.Closeable;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.util.Enumeration;import java.util.zip.ZipEntry;import java.util.zip.ZipException;import java.util.zip.ZipFile;import java.util.zip.ZipInputStream;import java.util.zip.ZipOutputStream;/** * * @author chendong * * &lt;/br&gt;使用java内置APIZipFile完成对文件的压缩解压缩操作 * * &lt;/br&gt;文件中如果有中文名称加压后的文件会出现乱码，但是解压之后又ok了，可以使用中文 * * &lt;/br&gt;提供了大文件异步加压解压的方法，使用回调检测是否完成 * * &lt;/br&gt;提供小文件同步加压解压更加方便 * */public class ZipUtils &#123; /** * 用于大文件加压解压的回调监听 * * @author chendong * */ public interface OnZipOverListener &#123; void onZipOver(); &#125; public interface OnUnZipOverListener &#123; void onUnZipOver(); &#125; /** * 压缩 &lt;/br&gt;构造源文件 * * @param src * 源文件路径 * @param dest * 目标文件路径 * @throws FileNotFoundException */ public static void zip(String src, String dest, OnZipOverListener listener) &#123; File srcFile = new File(src); zip(srcFile, dest, listener); &#125; /** * 压缩 &lt;/br&gt;生成压缩输出文件流 * * @param srcFile * @param dest * @throws FileNotFoundException */ public static void zip(File srcFile, String dest, OnZipOverListener listener) &#123; ZipOutputStream destOs = null; try &#123; destOs = new ZipOutputStream(new FileOutputStream(dest)); zip(srcFile, destOs, ""); close(destOs); if (listener != null) listener.onZipOver(); &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; close(destOs); &#125; &#125; /** * 压缩,使用递归 &lt;/br&gt;写文件 &lt;/br&gt;主要操作在这个函数中，使用递归如果是一个文件，将其写入流中否则进行递归 &lt;/br&gt;ZipEntry * 类是java.util.zip包下的一个类， ZipEntry 类用于表示 ZIP 文件条目。 利用这个类压缩和解压zip文件 * * @param srcFile * @param destOs * @param string * @throws IOException */ private static void zip(File srcFile, ZipOutputStream destOs, String base) &#123; BufferedInputStream bis = null; try &#123; if (srcFile.isDirectory()) &#123; /* 如果源文件是目录 */ File[] files = srcFile.listFiles(); destOs.putNextEntry(new ZipEntry(base + "/")); base = base.length() == 0 ? "" : base + "/"; for (int i = 0; i &lt; files.length; i++) &#123; zip(files[i], destOs, base + files[i].getName()); &#125; &#125; else &#123; /* 如果是文件 */ destOs.putNextEntry(new ZipEntry(base)); bis = new BufferedInputStream(new FileInputStream(srcFile)); byte[] buffer = new byte[1024]; int len = 0; while ((len = bis.read(buffer)) != -1) &#123; destOs.write(buffer, 0, len); &#125; close(bis); &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; close(bis); &#125; &#125; /** * 解压 * * @param src * 源文件，需要是zip文件 * @param dest * 目标文件， */ public static void unzip(String src, String dest, OnUnZipOverListener listener) &#123; File destFile = new File(dest); /* 目标文件不存在，创建之 */ if (!destFile.exists()) &#123; destFile.mkdirs(); &#125; /* 构造源文件 */ File srcFile = new File(src); if (!srcFile.exists()) &#123; return; &#125; unzip(srcFile, dest, listener); &#125; /** * 解压 * * @param srcFile * @param destFile */ public static void unzip(File srcFile, String dest, OnUnZipOverListener listener) &#123; BufferedInputStream bis = null; BufferedOutputStream bos = null; try &#123; ZipFile srcZipFile = new ZipFile(srcFile); /* 获得zipentry的枚举 */ Enumeration e = srcZipFile.entries(); ZipEntry entry = null;// ZipInputStream zis = new ZipInputStream(// new FileInputStream(srcFile)); // while((entry=zis.getNextEntry())!=null)&#123; while (e.hasMoreElements()) &#123; entry = (ZipEntry) e.nextElement(); if (entry.toString().equals("/")) &#123; continue; &#125; bis = new BufferedInputStream(srcZipFile.getInputStream(entry)); /* 构建对应输出流 */ bos = new BufferedOutputStream(new FileOutputStream(dest + "/" + entry.getName())); int len = 0; byte[] buffer = new byte[1024]; while ((len = bis.read(buffer)) != -1) &#123; bos.write(buffer, 0, len); &#125; bos.flush(); close(bis); close(bos); &#125; if (listener != null) listener.onUnZipOver(); &#125; catch (ZipException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; close(bis); close(bos); &#125; &#125; /** * 压缩单个或者多个文件,但是不可以同时压缩文件和文件夹 * * @param src * 想要压缩的文件路径，不可以是文件夹 * @param dest * 目标路径，xx.zip */ public static void zipFile(String[] src, String dest, OnZipOverListener listener) &#123; File parent = new File(new File(dest).getParent() + "/temp"); if (!parent.exists()) &#123; parent.mkdirs(); &#125; BufferedInputStream bis = null; BufferedOutputStream bos = null; File file = null; try &#123; int len = 0; byte[] buffer = new byte[1024]; for (String path : src) &#123; file = new File(path); bis = new BufferedInputStream(new FileInputStream(file)); bos = new BufferedOutputStream(new FileOutputStream( parent.getAbsolutePath() + "/" + file.getName())); while ((len = bis.read(buffer)) != -1) &#123; bos.write(buffer, 0, len); &#125; bos.flush(); close(bos); close(bis); &#125; zip(parent, dest, listener); for (File ff : parent.listFiles()) &#123; ff.delete(); &#125; parent.delete(); &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; close(bos); close(bis); &#125; &#125; private static void close(Closeable close) &#123; if (close != null) &#123; try &#123; close.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; GZIP压缩 这个没太搞懂，一直在弄加压解压有点烦了，改天再说吧，贴一下已经实现的简单功能。就是加压一个文件，本身GZIP就是一对一的，也就是说每次只能压缩一个文件，我们需要压缩多个问价的时候要使用tar先打包，看到网上有实现这个功能的，但是使用的阿帕奇的第三方库，就没去试,这部分的有点仓促，主要是烦了，写完这个我就去看点别的了，老看一个东西烦得慌，改天会在完善吧。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.Closeable;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.util.zip.GZIPInputStream;import java.util.zip.GZIPOutputStream;/** * * 使用java内置API完成文件的加压解压&lt;/br&gt; * 使用gzip压缩压缩效果更好，但是gzip压缩只能是一对一的，也就是说一个压缩包只能解压出一个文件，所以想压缩多个文件时就需要先使用tar压成一个包 * ，再用gzip压缩 * * @author chendong * */public class GZipUtils &#123; /** * gzip压缩，将一个文件压缩到制定包 * * @param src * @param dest */ public static void gzip(String src) &#123; File srcFile = new File(src); if (!srcFile.exists()) &#123; return; &#125; BufferedInputStream bis = null; GZIPOutputStream gos = null; File destFile = new File(src + ".gz"); try &#123; /* 获得输入流 */ bis = new BufferedInputStream(new FileInputStream(src)); /* 获得压缩输出流 */ gos = new GZIPOutputStream(new BufferedOutputStream( new FileOutputStream(destFile))); int len = 0; byte[] buffer = new byte[1024]; while ((len = bis.read(buffer)) != -1) &#123; gos.write(buffer, 0, len); &#125; gos.flush(); &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; close(gos); close(bis); &#125; &#125; /** * 解压 * @param src * @param dest */ public static void ungzip(String src, String dest) &#123; File destFile = new File(dest); File srcFile = new File(src); GZIPInputStream gis = null; BufferedOutputStream bos = null; try &#123; if (!destFile.exists()) &#123; destFile.createNewFile(); &#125; if (!srcFile.exists()) &#123; return; &#125; bos = new BufferedOutputStream(new FileOutputStream(destFile)); gis = new GZIPInputStream(new FileInputStream(srcFile)); int len = 0; byte[] buffer = new byte[1024]; while ((len = gis.read(buffer)) != -1) &#123; bos.write(buffer, 0, len); &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; close(bos); close(gis); &#125; &#125; public static void pack(File files[]) &#123; &#125; private static void close(Closeable close) &#123; if (close != null) &#123; try &#123; close.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[保存照片和视频到相册显示]]></title>
    <url>%2Farticle%2F1969447237%2F</url>
    <content type="text"><![CDATA[照片和视频保存到本地的方法大致都是通过流的方式写入文件里面就可以达到保存到文件夹的目的，但是你保存到文件夹的资源却不一定能够在相册显示出来，只能翻看文件管理。怎么能够将保存到本地的照片视频显示在系统相册中，最常用的方式是发送广播扫描的方式来通知系统扫描文件夹，但是这种方式经常不起作用，根本原因在于，向系统发送广播时系统只会去扫描系统资源的相册，如果你保存的文件夹是自己建立的，那么你发广播时系统是不会扫描到的。解决这个问题，想要显示在相册需要将数据插入到ContentProvider中，因此对于非系统能够扫描到的相册我们使用手动插入的方式。 保存到系统资源相册系统相册指的的是Camera、DCIM等等这些目录对应的相册，可能还有其他系统会自动扫描的相册，但是暂时没有去整理这些。对于系统相册来说，只需要发送广播进行扫描即可，数据会自动添加到ContentProvider中，当然如果不发送广播，在手机重启或者过一段时间之后，扫描操作仍会开启，因此绝对绝对不可以自己去进行插入操作，否则相册中会出现两张相同的照片。 12345678910111213/** * 针对系统文夹只需要扫描,不用插入内容提供者,不然会重复 * * @param context 上下文 * @param filePath 文件路径 */private static void scanFile(Context context, String filePath) &#123; if (!checkFile(filePath)) return; Intent intent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE); intent.setData(Uri.fromFile(new File(filePath))); context.sendBroadcast(intent);&#125; 保存到非系统资源相册保存到非系统资源相册中时，我们就需要进行ContentProvider的插入更新，来达到可以在相册显示的目的。 初始化 ContentValues 公共字段照片和视频是有一些公共字段，写一个初始化公共字段的方法，简化MediaStore字段的写入操作。 12345678910111213141516171819/** * 插入时初始化公共字段 * * @param filePath 文件 * @param time ms * @return ContentValues */private static ContentValues initCommonContentValues(String filePath, long time) &#123; ContentValues values = new ContentValues(); File saveFile = new File(filePath); long timeMillis = getTimeWrap(time); values.put(MediaStore.MediaColumns.TITLE, saveFile.getName()); values.put(MediaStore.MediaColumns.DISPLAY_NAME, saveFile.getName()); values.put(MediaStore.MediaColumns.DATE_MODIFIED, timeMillis); values.put(MediaStore.MediaColumns.DATE_ADDED, timeMillis); values.put(MediaStore.MediaColumns.DATA, saveFile.getAbsolutePath()); values.put(MediaStore.MediaColumns.SIZE, saveFile.length()); return values;&#125; 插入照片资源保存照片到本地，并通知相册显示，需要注意的时间的单位必须是ms 123456789101112131415161718192021222324252627/** * 保存到照片到本地，并插入MediaStore以保证相册可以查看到 * 这是更优化的方法，防止读取的照片获取不到宽高 * * @param context 上下文 * @param filePath 文件路径 * @param createTime 创建时间 &lt;=0时为当前时间 ms * @param width 宽度 * @param height 高度 */public static void insertImageToMediaStore(Context context, String filePath, long createTime, int width, int height) &#123; if (!checkFile(filePath)) return; createTime = getTimeWrap(createTime); ContentValues values = initCommonContentValues(filePath, createTime); values.put(MediaStore.Images.ImageColumns.DATE_TAKEN, createTime); values.put(MediaStore.Images.ImageColumns.ORIENTATION, 0); values.put(MediaStore.Images.ImageColumns.ORIENTATION, 0); if (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.JELLY_BEAN) &#123; if (width &gt; 0) values.put(MediaStore.Images.ImageColumns.WIDTH, 0); if (height &gt; 0) values.put(MediaStore.Images.ImageColumns.HEIGHT, 0); &#125; values.put(MediaStore.MediaColumns.MIME_TYPE, getPhotoMimeType(filePath)); context.getApplicationContext().getContentResolver() .insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values);&#125; 插入视频资源保存视频到本地，并通知相册显示，需要注意的时间的单位必须是ms 123456789101112131415161718192021222324252627/** * 保存到视频到本地，并插入MediaStore以保证相册可以查看到 * 这是更优化的方法，防止读取的视频获取不到宽高 * * @param context 上下文 * @param filePath 文件路径 * @param createTime 创建时间 &lt;=0时为当前时间 ms * @param duration 视频长度 ms * @param width 宽度 * @param height 高度 */public static void insertVideoToMediaStore(Context context, String filePath, long createTime, int width, int height, long duration) &#123; if (!checkFile(filePath)) return; createTime = getTimeWrap(createTime); ContentValues values = initCommonContentValues(filePath, createTime); values.put(MediaStore.Video.VideoColumns.DATE_TAKEN, createTime); if (duration &gt; 0) values.put(MediaStore.Video.VideoColumns.DURATION, duration); if (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.JELLY_BEAN) &#123; if (width &gt; 0) values.put(MediaStore.Video.VideoColumns.WIDTH, width); if (height &gt; 0) values.put(MediaStore.Video.VideoColumns.HEIGHT, height); &#125; values.put(MediaStore.MediaColumns.MIME_TYPE, getVideoMimeType(filePath)); context.getContentResolver().insert(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, values);&#125; 注意在应用过程中发现，vivo手机和魅族手机部分机型只支持在文件管理中查看视频，使用本文描述的方法添加后没有效果，用微信保存视频试了一下同样不能在相册中将视频显示出来，应该是手机的原因，特此声明。 附源码贴一下工具类源代码，多了一些辅助方法，比如获取mime_type的参数等方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174/** * CreateAt : 2017/5/24 * Describe : 相册更新通知帮助类 * 创建时间单位ms * 视频时长单位ms * * @author chendong */public class AlbumNotifyHelper &#123; public static final String TAG = AlbumNotifyHelper.class.getSimpleName(); /////////////////////////////////////////////////////////////////////////// // 下面是对外公开的重载的方法 /////////////////////////////////////////////////////////////////////////// public static void notifyScanDcim(Context context, String filePath) &#123; scanFile(context, filePath); &#125; public static void insertVideoToMediaStore(Context context, String filePath, long dateTaken, long duration) &#123; insertVideoToMediaStore(context, filePath, dateTaken, 0, 0, duration); &#125; public static void insertVideoToMediaStore(Context context, VideoUtil.VideoInfo videoInfo) &#123; insertVideoToMediaStore(context, videoInfo.originalVideoFilePath, videoInfo.dateTaken, videoInfo.width, videoInfo.height, videoInfo.duringTime); &#125; public static void insertImageToMediaStore(Context context, String filePath, long createTime) &#123; insertImageToMediaStore(context, filePath, createTime, 0, 0); &#125; /////////////////////////////////////////////////////////////////////////// // 扫描系统相册核心方法 /////////////////////////////////////////////////////////////////////////// /** * 针对系统文夹只需要扫描,不用插入内容提供者,不然会重复 * * @param context 上下文 * @param filePath 文件路径 */ public static void scanFile(Context context, String filePath) &#123; if (!checkFile(filePath)) return; Intent intent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE); intent.setData(Uri.fromFile(new File(filePath))); context.sendBroadcast(intent); &#125; /////////////////////////////////////////////////////////////////////////// // 非系统相册像MediaContent中插入数据，核心方法 /////////////////////////////////////////////////////////////////////////// /** * 针对非系统文件夹下的文件,使用该方法 * 插入时初始化公共字段 * * @param filePath 文件 * @param time ms * @return ContentValues */ private static ContentValues initCommonContentValues(String filePath, long time) &#123; ContentValues values = new ContentValues(); File saveFile = new File(filePath); long timeMillis = getTimeWrap(time); values.put(MediaStore.MediaColumns.TITLE, saveFile.getName()); values.put(MediaStore.MediaColumns.DISPLAY_NAME, saveFile.getName()); values.put(MediaStore.MediaColumns.DATE_MODIFIED, timeMillis); values.put(MediaStore.MediaColumns.DATE_ADDED, timeMillis); values.put(MediaStore.MediaColumns.DATA, saveFile.getAbsolutePath()); values.put(MediaStore.MediaColumns.SIZE, saveFile.length()); return values; &#125; /** * 保存到照片到本地，并插入MediaStore以保证相册可以查看到,这是更优化的方法，防止读取的照片获取不到宽高 * * @param context 上下文 * @param filePath 文件路径 * @param createTime 创建时间 &lt;=0时为当前时间 ms * @param width 宽度 * @param height 高度 */ public static void insertImageToMediaStore(Context context, String filePath, long createTime, int width, int height) &#123; if (!checkFile(filePath)) return; createTime = getTimeWrap(createTime); ContentValues values = initCommonContentValues(filePath, createTime); values.put(MediaStore.Images.ImageColumns.DATE_TAKEN, createTime); values.put(MediaStore.Images.ImageColumns.ORIENTATION, 0); values.put(MediaStore.Images.ImageColumns.ORIENTATION, 0); if (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.JELLY_BEAN) &#123; if (width &gt; 0) values.put(MediaStore.Images.ImageColumns.WIDTH, 0); if (height &gt; 0) values.put(MediaStore.Images.ImageColumns.HEIGHT, 0); &#125; values.put(MediaStore.MediaColumns.MIME_TYPE, getPhotoMimeType(filePath)); context.getApplicationContext().getContentResolver().insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values); &#125; /** * 保存到视频到本地，并插入MediaStore以保证相册可以查看到,这是更优化的方法，防止读取的视频获取不到宽高 * * @param context 上下文 * @param filePath 文件路径 * @param createTime 创建时间 &lt;=0时为当前时间 ms * @param duration 视频长度 ms * @param width 宽度 * @param height 高度 */ public static void insertVideoToMediaStore(Context context, String filePath, long createTime, int width, int height, long duration) &#123; if (!checkFile(filePath)) return; createTime = getTimeWrap(createTime); ContentValues values = initCommonContentValues(filePath, createTime); values.put(MediaStore.Video.VideoColumns.DATE_TAKEN, createTime); if (duration &gt; 0) values.put(MediaStore.Video.VideoColumns.DURATION, duration); if (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.JELLY_BEAN) &#123; if (width &gt; 0) values.put(MediaStore.Video.VideoColumns.WIDTH, width); if (height &gt; 0) values.put(MediaStore.Video.VideoColumns.HEIGHT, height); &#125; values.put(MediaStore.MediaColumns.MIME_TYPE, getVideoMimeType(filePath)); context.getContentResolver().insert(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, values); &#125; // 是不是系统相册 private static boolean isSystemDcim(String path) &#123; return path.toLowerCase().contains(&quot;dcim&quot;) || path.toLowerCase().contains(&quot;camera&quot;); &#125; // 获取照片的mine_type private static String getPhotoMimeType(String path) &#123; String lowerPath = path.toLowerCase(); if (lowerPath.endsWith(&quot;jpg&quot;) || lowerPath.endsWith(&quot;jpeg&quot;)) &#123; return &quot;image/jpeg&quot;; &#125; else if (lowerPath.endsWith(&quot;png&quot;)) &#123; return &quot;image/png&quot;; &#125; else if (lowerPath.endsWith(&quot;gif&quot;)) &#123; return &quot;image/gif&quot;; &#125; return &quot;image/jpeg&quot;; &#125; // 获取video的mine_type,暂时只支持mp4,3gp private static String getVideoMimeType(String path) &#123; String lowerPath = path.toLowerCase(); if (lowerPath.endsWith(&quot;mp4&quot;) || lowerPath.endsWith(&quot;mpeg4&quot;)) &#123; return &quot;video/mp4&quot;; &#125; else if (lowerPath.endsWith(&quot;3gp&quot;)) &#123; return &quot;video/3gp&quot;; &#125; return &quot;video/mp4&quot;; &#125; // 获得转化后的时间 private static long getTimeWrap(long time) &#123; if (time &lt;= 0) &#123; return System.currentTimeMillis(); &#125; return time; &#125; // 检测文件存在 private static boolean checkFile(String filePath) &#123; boolean result = FileUtil.fileIsExist(filePath); Log.e(TAG, &quot;文件不存在 path = &quot; + filePath); return result; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AndroidTips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义控件九宫格滑动解锁]]></title>
    <url>%2Farticle%2F2317215752%2F</url>
    <content type="text"><![CDATA[1. 前言 最近想给自己做的的app添加一个滑动解锁的功能，用的是乐视的手机，就模仿它的效果实现. 视频演示一下效果 GitHub 2. LockPoint实体 每个点是一个实体（LockPoint）用来存储这个点的所有信息，包括点的物理位置(x,y)和点的index位置(0-8) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class LockPoint &#123; // 点的位置 0-8 int index; // 点的x,y坐标 float x, y; // 构造方法，初始化一个点 LockPoint(int index, float x, float y) &#123; this.index = index; this.x = x; this.y = y; &#125; // 构造方法，从另一个点初始化 LockPoint(LockPoint p) &#123; this.x = p.x; this.y = p.y; this.index = p.index; &#125; // 默认构造方法，初始化为一个空的点 LockPoint() &#123; this.x = -1; this.y = -1; this.index = -1; &#125; // 判断该点是不是一个空的点 boolean isEmpty() &#123; return this.x == -1 &amp;&amp; this.y == -1; &#125; // 重新给位置赋值 void init(float x, float y) &#123; this.x = x; this.y = y; &#125; // 设置为另一点的值 void init(LockPoint p) &#123; this.x = p.x; this.y = p.y; this.index = p.index; &#125; // 判断一个位置是不是在该点触摸范围内,touchSensitiveRange为触摸有效半径 boolean isTouchIn(float judgeX, float judgeY) &#123; return judgeX &lt; x + touchSensitiveRange &amp;&amp; judgeX &gt; x - touchSensitiveRange &amp;&amp; judgeY &lt; y + touchSensitiveRange &amp;&amp; judgeY &gt; y - touchSensitiveRange; &#125; // 重写equals和hashCode @Override public boolean equals(Object o) &#123; LockPoint p = (LockPoint) o; return p.x == x &amp;&amp; p.y == y; &#125; @Override public int hashCode() &#123; return 2; &#125; String out(String tag) &#123; return tag + " : x = " + x + " , y = " + y; &#125; &#125; 3. 初始化 初始化九个点的位置，需要根据控件的大小动态计算，因此在onMeare()之后进行 需求是需要将九个点放在控件中间，来适应控件大小的变化，首先确定第一个点距离左边的距离startSpace，两个点之间的距离 =（控件宽度 - 2 * startSpace）／2 123456789101112int size = getMeasuredWidth(); // 将宽高设置为一样的，正方形 setMeasuredDimension(size, size); // 初始化屏幕中的九个点的位置和下标 initLockPointArray = new LockPoint[9]; // startSpace 为距离左边的距离，计算九个点的位置,保证九个点放在控件中间 if (startSpace == AUTO_START_SPACING) &#123; //默认是控件的1/4 startSpace = size / 4; &#125; // 计算每两个点之间的间隔 internalSpace = (size - 2 * startSpace) / 2; 初始化九个点的位置 12345678// 初始化九个点的位置 int index = 0; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; initLockPointArray[index] = new LockPoint(index, startSpace + j * internalSpace, startSpace + i * internalSpace); index++; &#125; &#125; onMeasure()完整代码 123456789101112131415161718192021222324252627282930// onMeasure之后初始化数据 @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int size = getMeasuredWidth(); // 将宽高设置为一样的，正方形 setMeasuredDimension(size, size); // 初始化屏幕中的九个点的位置和下标 if (initLockPointArray == null) &#123; initLockPointArray = new LockPoint[9]; // startSpace 为距离左边的距离，计算九个点的位置放在控件中间 if (startSpace == AUTO_START_SPACING) &#123; startSpace = size / 4; &#125; // 计算每两个点之间的间隔 internalSpace = (size - 2 * startSpace) / 2; // 初始化九个点的位置 int index = 0; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; initLockPointArray[index] = new LockPoint(index, startSpace + j * internalSpace, startSpace + i * internalSpace); index++; &#125; &#125; // 为了在preview时能看到效果 if (isInEditMode()) &#123; historyPointList.addAll(Arrays.asList(initLockPointArray)); &#125; &#125; &#125; 4. onDraw 绘制过程大致分为三个步骤 绘制九个点，这是每次都需要绘制的 1234LockPoint tempPoint;for (int i = 0; i &lt; initLockPointArray.length; i++) &#123; canvas.drawCircle(initLockPointArray[i].x, initLockPointArray[i].y, pointRadius, pointPaint);&#125; 绘制已经划过的点 123456// 绘制之前触过存储起来的的点,绘制第i个点和i+1个点之间的线 if (historyPointList.size() &gt; 0) &#123; for (int i = 0; i &lt; historyPointList.size() - 1; i++) &#123; canvas.drawLine(historyPointList.get(i).x, historyPointList.get(i).y, historyPointList.get(i + 1).x, historyPointList.get(i + 1).y, linePaint); &#125; &#125; 绘制触摸点和最后一个点的连线 123456// 画最后一个点和触摸的点之间的线 if (currentLockPoint != null &amp;&amp; currentLockPoint.x != -1 &amp;&amp; currentLockPoint.y != -1 &amp;&amp; touchPoint.x != -1 &amp;&amp; touchPoint.y != -1) &#123; canvas.drawLine(currentLockPoint.x, currentLockPoint.y, touchPoint.x, touchPoint.y, linePaint); &#125; 5. 事件处理 对用户touch事件进行处理 要记录当前触摸的点，用于绘制跟随手指的连线 检测触摸的点是不是在九个点中某个点的范围内，如果是的话该点要加入被触摸点的列表中 当手指抬起时，清除数据,恢复初始状态 12345678910111213141516171819202122232425262728293031323334353637@Override public boolean onTouchEvent(MotionEvent event) &#123; if (!isEnabled() || isEventOver) return false; int action = MotionEventCompat.getActionMasked(event); switch (action) &#123; // 重新初始化触摸点 case MotionEvent.ACTION_DOWN: touchPoint.init(event.getX(), event.getY()); break; // 移动时检测是否在触摸范围内 case MotionEvent.ACTION_MOVE: touchPoint.init(event.getX(), event.getY()); LockPoint tempPoint; for (int i = 0; i &lt; initLockPointArray.length; i++) &#123; tempPoint = initLockPointArray[i]; if (!historyPointList.contains(tempPoint) &amp;&amp; tempPoint.isTouchIn(event.getX(), event.getY())) &#123; historyPointList.add(new LockPoint(tempPoint)); currentLockPoint.init(tempPoint); break; &#125; &#125; break; // 抬起时结束，重新初始化 case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: touchPoint.init(-1, -1); currentLockPoint.init(-1, -1); historyPointList.clear(); break; &#125; postInvalidate(); return true; &#125; 6. 优化-多点触控事件处理 用户在触摸屏幕时可能有多个手指在操作，上面的代码在单指时没有问题，兼容多点触控的思路是： 当用户触发down事件时，我们可以获取到一个pointerId，这个id唯一的标志了这个指头，后面发生的所有事件都使用用这个pointerId来获取，只处理这个指头的事件，避免事件的错乱。 当我们开始的时候标志的那个手指抬起来了怎么办呢，两个解决方法，第一个就是直接结束整个流程，相当于单指时手指抬起。第二个方法就是转移事件，当一个指头抬起时，从该事件中获取还没抬起的手指，更改标志的pointerId,事件就转移到了另一个手指上，我们关心就是新手指的触摸啦 关于对于事件进行处理的相关机制可以看Android事件机制，写的都是比较基本的东西，后面慢慢完善，不过理解获取多指的事件9⃣️绰绰有余啦 话不多说，上代码，比较需要注意的地方我都标注在注释中，方便查找 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// 处理触摸事件，支持多点触摸 @Override public boolean onTouchEvent(MotionEvent event) &#123; // fast stop if (!isEnabled() || isEventOver) return false; // pointerIndex 是事件的在event中的下标 int pointerIndex; // 获取事件掩码 int action = MotionEventCompat.getActionMasked(event); switch (action) &#123; // 重新初始化触摸点 case MotionEvent.ACTION_DOWN: // pointerId 记录当前激活的pointerId activePointerId = event.getPointerId(0); // 根据pointerId查找事件在event中的位置 pointerIndex = event.findPointerIndex(activePointerId); // 根据位置获取到具体的事件的坐标，这里获得的坐标就是我们要记住的那个指头的坐标 touchPoint.init(event.getX(pointerIndex), event.getY(pointerIndex)); break; case MotionEvent.ACTION_MOVE: // 手指移动时还是根据激活的pointerId获取下标index,来进行后续操作，避免事件错乱 pointerIndex = event.findPointerIndex(activePointerId); // pointerIndex &lt; 0表示手指的事件获取不到了，结束响应事件 if (pointerIndex &lt; 0) &#123; Log.e(TAG, "Got ACTION_MOVE event but have an invalid active pointer id."); cancelLockDraw(); return false; &#125; // 根据移动的位置获取坐标，初始化touchPoint的值 touchPoint.init(event.getX(pointerIndex), event.getY(pointerIndex)); LockPoint tempPoint; // 检索触摸点有没有在九个点中的某一个的触摸范围内 for (int i = 0; i &lt; initLockPointArray.length; i++) &#123; tempPoint = initLockPointArray[i]; if (!historyPointList.contains(tempPoint) &amp;&amp; tempPoint.isTouchIn(event.getX(pointerIndex), event.getY(pointerIndex))) &#123; LockPoint centerPoint = findCenterPoint(tempPoint); // 优化，查找两个点之间的点，后面会有介绍 if (!centerPoint.isEmpty()) &#123; activePoint(centerPoint); &#125; activePoint(tempPoint); break; &#125; &#125; break; case MotionEventCompat.ACTION_POINTER_UP: // 多指操作中 非 最后一个手指抬起时触发ACTION_POINTER_UP，此时要获取还在屏幕上的其他手指转移事件的对象 onSecondaryPointerUp(event); break; case MotionEvent.ACTION_UP: // 最后的手指抬起触发 ACTION_UP pointerIndex = event.findPointerIndex(activePointerId); if (pointerIndex &lt; 0) &#123; Log.e(TAG, "Got ACTION_UP event but don't have an active pointer id."); activePointerId = INVALID_POINTER; return false; &#125; // 发布绘制的结果，可能是监听回调之类的 publishResult(); // 置为-1 activePointerId = INVALID_POINTER; break; case MotionEvent.ACTION_CANCEL: // 类似up cancelLockDraw(); activePointerId = INVALID_POINTER; break; &#125; postInvalidate(); return true; &#125; 转移焦点的方法,在各种控件的源代码中随处可见，我也是拷贝出来直接用的，逻辑不是很复杂 123456789101112131415 /** * 当一个手机抬起时，转移焦点 * * @param ev 事件 */private void onSecondaryPointerUp(MotionEvent ev) &#123; final int pointerIndex = MotionEventCompat.getActionIndex(ev); final int pointerId = MotionEventCompat.getPointerId(ev, pointerIndex); if (pointerId == activePointerId) &#123; // This was our active pointer going up. Choose a new // active pointer and adjust accordingly. final int newPointerIndex = pointerIndex == 0 ? 1 : 0; activePointerId = MotionEventCompat.getPointerId(ev, newPointerIndex); &#125; &#125; 发布结果 123456789101112131415161718192021222324/** * 发布绘制结果 */ private void publishResult() &#123; if (listener != null) &#123; isEventOver = true; StringBuilder sb = new StringBuilder(); for (LockPoint lockPoint : historyPointList) &#123; sb.append(lockPoint.index); &#125; String passWd = sb.toString(); boolean isFinish = listener.onFinish(LockView.this, passWd, passWd.length()); if (isFinish) &#123; // 输入合法 touchPoint.init(currentLockPoint); &#125; else &#123; // 输入不合法 cancelLockDraw(); isEventOver = false; &#125; &#125; else &#123; cancelLockDraw(); &#125; &#125; 回复初始状态,因为在多处调用了，贴一下 123456789/** * 结束绘制，恢复初始状态 */ private void cancelLockDraw() &#123; touchPoint.init(-1, -1); currentLockPoint.init(-1, -1); historyPointList.clear(); postInvalidate(); &#125; 7. 优化-自动添加两点之间连线上的点 当滑动时越过中间的点之间连接两端，自动查找和添加两点之间的点，手机上的滑动解锁也是这样的逻辑，不然会导致图形很繁琐，不美观而且不符合常见逻辑。也就是说如果当前激发的点和上一个激发的点之间有没有激发的点，那么自动给他激发。 首先如果两个点是相邻的或者是对角线上相邻，那么中间一定不会有空下来的点，需要排除这个情况 123456789101112131415161718/** * 检测相邻 * * @param p1 点1 * @param p2 点2 * @return p1和p2是否相邻，斜对角也算相邻 */ private boolean isAdjacentPoint(LockPoint p1, LockPoint p2) &#123; // internalSpace是初始化时两个点之间的距离，都是简单的计算和情况罗列 if ((p1.x == p2.x &amp;&amp; Math.abs(p1.y - p2.y) == internalSpace) || (p1.y == p2.y &amp;&amp; Math.abs(p1.x - p2.x) == internalSpace) || (Math.abs(p1.x - p2.x) == internalSpace &amp;&amp; Math.abs(p1.y - p2.y) == internalSpace)) &#123; Log.e(TAG, "相邻点，不处理"); return true; &#125; return false; &#125; 然后如何判断一个点位于首尾两个激发点的中间，思路是当这个点在两个点的连线上时且不是首尾两个点就是中间的点。判断的根据是斜率是不是相等，就是初中的数学问题啦。 12345678910111213/** * 判断c点是不是在p1-p2的直线上 * * @param p1 起始点 * @param p2 终止点 * @param c 判断的点 * @return 是否在该线上 */ private boolean isInLine(LockPoint p1, LockPoint p2, LockPoint c) &#123; float k1 = (p1.x - p2.x) * 1f / (p1.y - p2.y); float k2 = (p1.x - c.x) * 1f / (p1.y - c.y); return k1 == k2; &#125; 最后整合一下，去掉不必要的判断，在touch事件中调用 123456789101112131415161718192021222324252627282930313233/** * 检测当前激活的点和上一个激活点之间的是否有没有激发的点 * * @param activePoint 当前被激发的点 * @return 当前激活的点和上一个激活点之间的是否有没有激发的点，没有返回empty的&#123;@link LockPoint#isEmpty()&#125; */ private LockPoint findCenterPoint(LockPoint activePoint) &#123; LockPoint rstPoint = new LockPoint(); // 只有一个点不需要比较 if (historyPointList.size() &lt; 1) &#123; return rstPoint; &#125; LockPoint tempPoint; // 获取上个点 LockPoint preActivePoint = historyPointList.get(historyPointList.size() - 1); // 两个点是不是相邻的，是相邻的是坚决不会中间有点被空出来的 if (isAdjacentPoint(preActivePoint, activePoint)) return rstPoint; for (int i = 0; i &lt; initLockPointArray.length; i++) &#123; tempPoint = initLockPointArray[i]; // 没有被触摸过 &amp;&amp; 不是首点 &amp;&amp; 不是尾点 if (!historyPointList.contains(tempPoint) &amp;&amp; !preActivePoint.equals(tempPoint) &amp;&amp; !activePoint.equals(tempPoint)) &#123; // 在连线上 if (isInLine(preActivePoint, activePoint, tempPoint)) &#123; Log.e(TAG, "点在线上 " + tempPoint.out("temp") + " " + preActivePoint.out("pre") + " " + activePoint.out("active")); rstPoint.init(tempPoint); break; &#125; &#125; &#125; return rstPoint; &#125; 在onTouchEvent中调用 123456LockPoint centerPoint = findCenterPoint(tempPoint); // 优化，查找两个点之间的点 if (!centerPoint.isEmpty()) &#123; activePoint(centerPoint); &#125; activePoint(tempPoint); 8. 优化-给被触摸的点添加动画 当手指触摸到一个点时，添加一个缩放动画来反馈触摸操作 思路时，当触摸到一个点时使用ValueAnimator开启动画，不断改变半径的值，在绘制时达到实现缩放的效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 开始缩放动画 */ private void startScaleAnimation() &#123; if (mScaleAnimator == null) &#123; mScaleAnimator = ValueAnimator.ofFloat(1f, scaleMax, 1f); mScaleAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; float scale = (float) animation.getAnimatedValue(); // 不断改变半径的值 scalePointRadius = pointRadius * scale; postInvalidate(); &#125; &#125;); mScaleAnimator.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; &#125; @Override public void onAnimationEnd(Animator animation) &#123; // 动画结束后初始化回标准半径的值 scalePointRadius = pointRadius; &#125; @Override public void onAnimationCancel(Animator animation) &#123; &#125; @Override public void onAnimationRepeat(Animator animation) &#123; &#125; &#125;); mScaleAnimator.setDuration(scaleAnimDuration); &#125; if (mScaleAnimator.isRunning()) mScaleAnimator.end(); mScaleAnimator.start(); &#125; 同时在onDraw()方法中对刚刚触摸的点要进行绘制,更改onDraw()方法中绘制九个点的部分，对刚刚触摸的点使用缩放后的半径绘制。 1234567891011// 绘制九个点，当动画在执行时被激活的点会被放大 LockPoint tempPoint; for (int i = 0; i &lt; initLockPointArray.length; i++) &#123; tempPoint = initLockPointArray[i]; // 最后触摸的点 if (currentLockPoint != null &amp;&amp; currentLockPoint.equals(tempPoint)) &#123; canvas.drawCircle(tempPoint.x, tempPoint.y, scalePointRadius, pointPaint); &#125; else &#123; canvas.drawCircle(tempPoint.x, tempPoint.y, pointRadius, pointPaint); &#125; &#125; 9. 回调 使用监听将结果回调给使用者，在ACTION_UP时发布结果 12345678910111213141516171819202122232425262728293031323334353637public interface OnLockFinishListener &#123; /** * * @param lockView 控件 * @param passWd 密码 * @param passWsLength 密码长度 * @return 当返回true时，画面将会定格在绘制结束后的状态，比如当密码输入正确的时候 * 返回false时，画面会重新初始化回初始状态，比如密码重新二次输入确认或者密码错误的时候 */ boolean onFinish(LockView lockView, String passWd, int passWsLength); &#125; /** * 发布绘制结果 */ private void publishResult() &#123; if (listener != null) &#123; isEventOver = true; StringBuilder sb = new StringBuilder(); for (LockPoint lockPoint : historyPointList) &#123; sb.append(lockPoint.index); &#125; String passWd = sb.toString(); boolean isFinish = listener.onFinish(LockView.this, passWd, passWd.length()); if (isFinish) &#123; // 画面定格 touchPoint.init(currentLockPoint); &#125; else &#123; // 恢复初始化 cancelLockDraw(); isEventOver = false; &#125; &#125; else &#123; cancelLockDraw(); &#125; &#125; 10. 综上 还遗留了一个点，就是自动添加中间的点时应该也是有动画效果的，暂时还没做，有空补上吧，希望大家指正。 11. 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514/** * Project : CdLibsTest * Package : com.march.cdlibstest.widget * CreateAt : 2016/11/26 * Describe : 自定义控件实现九宫格滑动解锁 * * @author chendong */public class LockView extends View &#123; public static final String TAG = "LOCK_VIEW"; private static final int INVALID_POINTER = -1; private static final int AUTO_START_SPACING = -1; private static final int DEFAULT_MIN_POINT_NUM = 4; // 激活的触摸点id private int activePointerId = INVALID_POINTER; // 四边的间隔，默认是控件的1／4 private int startSpace; // 两点间隔 private int internalSpace; // 点的半径 private int pointRadius; // 动画scale的半径 private float scalePointRadius; // 触摸半径，在点的一定范围内触发 private int touchSensitiveRange; // 线宽度 private int lineWidth; // 点颜色 private int pointColor; // 线颜色 private int lineColor; // 缩放的大小 private float scaleMax; // 动画时间 private int scaleAnimDuration = 150; // 本次绘制结束，调用init()方法恢复初始化 private boolean isEventOver = false; class LockPoint &#123; // 点的位置 0-8 int index; // 点的x,y坐标 float x, y; // 构造方法，初始化一个点 LockPoint(int index, float x, float y) &#123; this.index = index; this.x = x; this.y = y; &#125; // 构造方法，从另一个点初始化 LockPoint(LockPoint p) &#123; this.x = p.x; this.y = p.y; this.index = p.index; &#125; // 默认构造方法，初始化为一个空的点 LockPoint() &#123; this.x = -1; this.y = -1; this.index = -1; &#125; // 判断该点是不是一个空的点 boolean isEmpty() &#123; return this.x == -1 &amp;&amp; this.y == -1; &#125; // 重新给位置赋值 void init(float x, float y) &#123; this.x = x; this.y = y; &#125; // 设置为另一点的值 void init(LockPoint p) &#123; this.x = p.x; this.y = p.y; this.index = p.index; &#125; // 判断一个位置是不是在该点触摸范围内,touchSensitiveRange为触摸有效半径 boolean isTouchIn(float judgeX, float judgeY) &#123; return judgeX &lt; x + touchSensitiveRange &amp;&amp; judgeX &gt; x - touchSensitiveRange &amp;&amp; judgeY &lt; y + touchSensitiveRange &amp;&amp; judgeY &gt; y - touchSensitiveRange; &#125; // 重写equals和hashCode @Override public boolean equals(Object o) &#123; LockPoint p = (LockPoint) o; return p.x == x &amp;&amp; p.y == y; &#125; @Override public int hashCode() &#123; return 2; &#125; String out(String tag) &#123; return tag + " : x = " + x + " , y = " + y; &#125; &#125; // 动画 private ValueAnimator mScaleAnimator; // 初始化的九个点 private LockPoint[] initLockPointArray; // 触摸过的点泪飙 private List&lt;LockPoint&gt; historyPointList; // 触摸的点 private LockPoint touchPoint; // 当前最后一个激活的点 private LockPoint currentLockPoint; // 画线 private Paint linePaint; // 画点 private Paint pointPaint; // 监听 private OnLockFinishListener listener; public interface OnLockFinishListener &#123; /** * * @param lockView 控件 * @param passWd 密码 * @param passWsLength 密码长度 * @return 当返回true时，画面将会定格在绘制结束后的状态 * 返回false时，画面会重新初始化回初始状态 */ boolean onFinish(LockView lockView, String passWd, int passWsLength); &#125; public LockView(Context context) &#123; this(context, null); &#125; public LockView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public LockView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.LockView); float density = getResources().getDisplayMetrics().density; pointRadius = (int) typedArray.getDimension(R.styleable.LockView_lock_pointRadius, (8 * density)); scalePointRadius = pointRadius; touchSensitiveRange = (int) typedArray.getDimension(R.styleable.LockView_lock_touchSensitiveRange, pointRadius * 3); startSpace = (int) typedArray.getDimension(R.styleable.LockView_lock_startSpace, AUTO_START_SPACING); lineWidth = (int) typedArray.getDimension(R.styleable.LockView_lock_lineWidth, (5 * density)); lineColor = typedArray.getColor(R.styleable.LockView_lock_lineColor, Color.WHITE); pointColor = typedArray.getColor(R.styleable.LockView_lock_pointColor, Color.WHITE); scaleAnimDuration = typedArray.getInt(R.styleable.LockView_lock_scaleAnimDuration, 180); scaleMax = typedArray.getFloat(R.styleable.LockView_lock_scaleMax, 2.5f); typedArray.recycle(); historyPointList = new ArrayList&lt;&gt;(); touchPoint = new LockPoint(); currentLockPoint = new LockPoint(); pointPaint = new Paint(); pointPaint.setAntiAlias(true); pointPaint.setColor(pointColor); pointPaint.setStyle(Paint.Style.FILL_AND_STROKE); linePaint = new Paint(); linePaint.setAntiAlias(true); linePaint.setStrokeWidth(lineWidth); linePaint.setColor(lineColor); linePaint.setStyle(Paint.Style.STROKE); &#125; public void setListener(OnLockFinishListener listener) &#123; this.listener = listener; &#125; /** * 开始缩放动画 */ private void startScaleAnimation() &#123; if (mScaleAnimator == null) &#123; mScaleAnimator = ValueAnimator.ofFloat(1f, scaleMax, 1f); mScaleAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; float scale = (float) animation.getAnimatedValue(); scalePointRadius = pointRadius * scale; postInvalidate(); &#125; &#125;); mScaleAnimator.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; &#125; @Override public void onAnimationEnd(Animator animation) &#123; scalePointRadius = pointRadius; &#125; @Override public void onAnimationCancel(Animator animation) &#123; &#125; @Override public void onAnimationRepeat(Animator animation) &#123; &#125; &#125;); mScaleAnimator.setDuration(scaleAnimDuration); &#125; if (mScaleAnimator.isRunning()) mScaleAnimator.end(); mScaleAnimator.start(); &#125; // 处理触摸事件，支持多点触摸 @Override public boolean onTouchEvent(MotionEvent event) &#123; // fast stop if (!isEnabled() || isEventOver) return false; // pointerIndex 是事件的在event中的下标 int pointerIndex; // 获取事件掩码 int action = MotionEventCompat.getActionMasked(event); switch (action) &#123; // 重新初始化触摸点 case MotionEvent.ACTION_DOWN: // pointerId 记录当前激活的pointerId activePointerId = event.getPointerId(0); // 根据pointerId查找事件在event中的位置 pointerIndex = event.findPointerIndex(activePointerId); // 根据位置获取到具体的事件的坐标，这里获得的坐标就是我们要记住的那个指头的坐标 touchPoint.init(event.getX(pointerIndex), event.getY(pointerIndex)); break; case MotionEvent.ACTION_MOVE: // 手指移动时还是根据激活的pointerId获取下标index,来进行后续操作，避免事件错乱 pointerIndex = event.findPointerIndex(activePointerId); // pointerIndex &lt; 0表示手指的事件获取不到了，结束响应事件 if (pointerIndex &lt; 0) &#123; Log.e(TAG, "Got ACTION_MOVE event but have an invalid active pointer id."); cancelLockDraw(); return false; &#125; // 根据移动的位置获取坐标，初始化touchPoint的值 touchPoint.init(event.getX(pointerIndex), event.getY(pointerIndex)); LockPoint tempPoint; // 检索触摸点有没有在九个点中的某一个的触摸范围内 for (int i = 0; i &lt; initLockPointArray.length; i++) &#123; tempPoint = initLockPointArray[i]; if (!historyPointList.contains(tempPoint) &amp;&amp; tempPoint.isTouchIn(event.getX(pointerIndex), event.getY(pointerIndex))) &#123; LockPoint centerPoint = findCenterPoint(tempPoint); if (!centerPoint.isEmpty()) &#123; activePoint(centerPoint); &#125; activePoint(tempPoint); break; &#125; &#125; break; case MotionEventCompat.ACTION_POINTER_UP: // 多指操作中 非 最后一个手指抬起时触发ACTION_POINTER_UP，此时要获取还在屏幕上的其他手指转移事件的对象 onSecondaryPointerUp(event); break; case MotionEvent.ACTION_UP: // 最后的手指抬起触发 ACTION_UP pointerIndex = event.findPointerIndex(activePointerId); if (pointerIndex &lt; 0) &#123; Log.e(TAG, "Got ACTION_UP event but don't have an active pointer id."); activePointerId = INVALID_POINTER; return false; &#125; // 发布绘制的结果，可能是监听回调之类的 publishResult(); // 置为-1 activePointerId = INVALID_POINTER; break; case MotionEvent.ACTION_CANCEL: // 类似up cancelLockDraw(); activePointerId = INVALID_POINTER; break; &#125; postInvalidate(); return true; &#125; /** * 发布绘制结果 */ private void publishResult() &#123; if (listener != null) &#123; isEventOver = true; StringBuilder sb = new StringBuilder(); for (LockPoint lockPoint : historyPointList) &#123; sb.append(lockPoint.index); &#125; String passWd = sb.toString(); boolean isFinish = listener.onFinish(LockView.this, passWd, passWd.length()); if (isFinish) &#123; // 输入合法 touchPoint.init(currentLockPoint); &#125; else &#123; // 输入不合法 cancelLockDraw(); isEventOver = false; &#125; &#125; else &#123; cancelLockDraw(); &#125; &#125; /** * 当一个手机抬起时，转移焦点 * * @param ev 事件 */ private void onSecondaryPointerUp(MotionEvent ev) &#123; final int pointerIndex = MotionEventCompat.getActionIndex(ev); final int pointerId = MotionEventCompat.getPointerId(ev, pointerIndex); if (pointerId == activePointerId) &#123; // This was our active pointer going up. Choose a new // active pointer and adjust accordingly. final int newPointerIndex = pointerIndex == 0 ? 1 : 0; activePointerId = MotionEventCompat.getPointerId(ev, newPointerIndex); &#125; &#125; /** * 检测当前激活的点和上一个激活点之间的是否有没有激发的点 * * @param activePoint 当前被激发的点 * @return 当前激活的点和上一个激活点之间的是否有没有激发的点，没有返回empty的&#123;@link LockPoint#isEmpty()&#125; */ private LockPoint findCenterPoint(LockPoint activePoint) &#123; LockPoint rstPoint = new LockPoint(); // 只有一个点不需要比较 if (historyPointList.size() &lt; 1) &#123; return rstPoint; &#125; LockPoint tempPoint; // 获取上个点 LockPoint preActivePoint = historyPointList.get(historyPointList.size() - 1); // 两个点是不是相邻的，是相邻的是坚决不会中间有点被空出来的 if (isAdjacentPoint(preActivePoint, activePoint)) return rstPoint; for (int i = 0; i &lt; initLockPointArray.length; i++) &#123; tempPoint = initLockPointArray[i]; // 没有被触摸过 &amp;&amp; 不是首点 &amp;&amp; 不是尾点 if (!historyPointList.contains(tempPoint) &amp;&amp; !preActivePoint.equals(tempPoint) &amp;&amp; !activePoint.equals(tempPoint)) &#123; if (isInLine(preActivePoint, activePoint, tempPoint)) &#123; Log.e(TAG, "点在线上 " + tempPoint.out("temp") + " " + preActivePoint.out("pre") + " " + activePoint.out("active")); rstPoint.init(tempPoint); break; &#125; &#125; &#125; return rstPoint; &#125; /** * 检测相邻 * * @param p1 点1 * @param p2 点2 * @return p1和p2是否相邻，斜对角也算相邻 */ private boolean isAdjacentPoint(LockPoint p1, LockPoint p2) &#123; if ((p1.x == p2.x &amp;&amp; Math.abs(p1.y - p2.y) == internalSpace) || (p1.y == p2.y &amp;&amp; Math.abs(p1.x - p2.x) == internalSpace) || (Math.abs(p1.x - p2.x) == internalSpace &amp;&amp; Math.abs(p1.y - p2.y) == internalSpace)) &#123; Log.e(TAG, "相邻点，不处理"); return true; &#125; return false; &#125; /** * 判断c点是不是在p1-p2的直线上 * * @param p1 起始点 * @param p2 终止点 * @param c 判断的点 * @return 是否在该线上 */ private boolean isInLine(LockPoint p1, LockPoint p2, LockPoint c) &#123; float k1 = (p1.x - p2.x) * 1f / (p1.y - p2.y); float k2 = (p1.x - c.x) * 1f / (p1.y - c.y); return k1 == k2; &#125; /** * 激活该点，该点将会添加到选中点列表中，然后执行动画 * * @param tempPoint 被激活的点 */ private void activePoint(LockPoint tempPoint) &#123; historyPointList.add(new LockPoint(tempPoint)); currentLockPoint.init(tempPoint); startScaleAnimation(); postInvalidate(); &#125; public void init() &#123; isEventOver = false; cancelLockDraw(); &#125; /** * 结束绘制，恢复初始状态 */ private void cancelLockDraw() &#123; touchPoint.init(-1, -1); currentLockPoint.init(-1, -1); historyPointList.clear(); postInvalidate(); &#125; // onMeasure之后初始化数据 @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int size = getMeasuredWidth(); // 将宽高设置为一样的，正方形 setMeasuredDimension(size, size); // 初始化屏幕中的九个点的位置和下标 if (initLockPointArray == null) &#123; initLockPointArray = new LockPoint[9]; // startSpace 为距离左边的距离，计算九个点的位置放在控件中间 if (startSpace == AUTO_START_SPACING) &#123; startSpace = size / 4; &#125; // 计算每两个点之间的间隔 internalSpace = (size - 2 * startSpace) / 2; // 初始化九个点的位置 int index = 0; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; initLockPointArray[index] = new LockPoint(index, startSpace + j * internalSpace, startSpace + i * internalSpace); index++; &#125; &#125; // 为了在preview时能看到效果 if (isInEditMode()) &#123; historyPointList.addAll(Arrays.asList(initLockPointArray)); &#125; &#125; &#125; private void log(Object... objs) &#123; StringBuilder sb = new StringBuilder(); for (Object obj : objs) &#123; sb.append(obj.toString()).append(" "); &#125; Log.e(TAG, sb.toString()); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // fast stop if (initLockPointArray == null) return; log(currentLockPoint.out("current"), touchPoint.out("touch")); // 画最后一个点和触摸的点之间的线 if (currentLockPoint != null &amp;&amp; currentLockPoint.x != -1 &amp;&amp; currentLockPoint.y != -1 &amp;&amp; touchPoint.x != -1 &amp;&amp; touchPoint.y != -1) &#123; canvas.drawLine(currentLockPoint.x, currentLockPoint.y, touchPoint.x, touchPoint.y, linePaint); &#125; // 绘制之前触过存储起来的的点 if (historyPointList.size() &gt; 0) &#123; for (int i = 0; i &lt; historyPointList.size() - 1; i++) &#123; canvas.drawLine(historyPointList.get(i).x, historyPointList.get(i).y, historyPointList.get(i + 1).x, historyPointList.get(i + 1).y, linePaint); &#125; &#125; // 绘制九个点，当动画在执行时被激活的点会被放大 LockPoint tempPoint; for (int i = 0; i &lt; initLockPointArray.length; i++) &#123; tempPoint = initLockPointArray[i]; if (currentLockPoint != null &amp;&amp; currentLockPoint.equals(tempPoint)) &#123; canvas.drawCircle(tempPoint.x, tempPoint.y, scalePointRadius, pointPaint); &#125; else &#123; canvas.drawCircle(tempPoint.x, tempPoint.y, pointRadius, pointPaint); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DES,AES 加密解密]]></title>
    <url>%2Farticle%2F3556316359%2F</url>
    <content type="text"><![CDATA[加密解密的原理是个很麻烦的问题，我之前上过一门课叫密码学，最后也没怎么学懂，所以这里我们只是使用java代码实现加密解密的功能，而不是讨论他的原理。 DES简单介绍 DES(Data Encryption Standard)即数据加密标准，使用56bit密钥，将64bit的明文数据块加密为64bit密文。 DES使用56bit密钥加密，秘钥要求8个字节64bit，每个字节有一位是奇偶校验位。 DES加密强度小，容易被破解 DES加密代码实现123456789101112131415161718192021222324252627282930313233343536373839404142/** * DES加密解密 * @param data 需要加密的数据 * @param key 秘钥，必须是8个字节 * @param mode 加密或者解密模式 * Cipher.ENCRYPT_MODE * Cipher.DECRYPT_MODE * @return */ public static byte[] DESCrypt(byte[] data, byte[] key, int mode) &#123; byte[] result = null; if (data == null || key == null || data.length &lt;= 0 || key.length &lt;= 0) return null; //DES密码必须是8个字节，64bit长度 try &#123; //创建加密引擎 Cipher cipher = Cipher.getInstance("DES"); //指定8个字节密码 DESKeySpec desKeySpec = new DESKeySpec(key); //生成密码工厂 SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance("DES"); //生成密码 SecretKey secretKey = secretKeyFactory.generateSecret(desKeySpec); //设置模式，加密解密 cipher.init(mode, secretKey); //加密。设置字节数组作为待加密内容,返回值是最终加密结果 result = cipher.doFinal(data); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (NoSuchPaddingException e) &#123; e.printStackTrace(); &#125; catch (InvalidKeyException e) &#123; e.printStackTrace(); &#125; catch (InvalidKeySpecException e) &#123; e.printStackTrace(); &#125; catch (BadPaddingException e) &#123; e.printStackTrace(); &#125; catch (IllegalBlockSizeException e) &#123; e.printStackTrace(); &#125; return result; &#125; AES简单介绍 AES(Advanced Encryption Standard)，即为高级加密标准。在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。AES的区块长度固定为128 比特，密钥长度则可以是128，192或256比特； 低强度加密代码实现12345678910111213141516171819202122232425262728293031/** * AES低强度加密解密 * @param data * @param key * @param mode Cipher.ENCRYPT_MODE * Cipher.DECRYPT_MODE * @return */ public static byte[] AESCrypt(byte[] data,byte[] key,int mode)&#123; byte[] result = null; if (data == null || key == null || data.length &lt;= 0 || key.length &lt;= 0) return null; try &#123; Cipher cipher = Cipher.getInstance("AES"); SecretKeySpec secretKeySpec = new SecretKeySpec(key,"AES"); cipher.init(mode,secretKeySpec); result = cipher.doFinal(data); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (NoSuchPaddingException e) &#123; e.printStackTrace(); &#125; catch (InvalidKeyException e) &#123; e.printStackTrace(); &#125; catch (BadPaddingException e) &#123; e.printStackTrace(); &#125; catch (IllegalBlockSizeException e) &#123; e.printStackTrace(); &#125; return result; &#125; 高强度加密，使用iv参数1234567891011121314151617181920212223242526272829303132333435/** * AES高强度加密 * * @param data * @param key * @param iv 用于AES/CBC、PKCS5Padding这个带有加密模式的算法 * @param mode * @return */ public static byte[] AESCrypt(byte[] data, byte[] key, byte[] iv, int mode) &#123; byte[] result = null; if (data == null || key == null || data.length &lt;= 0 || key.length &lt;= 0) return null; try &#123; Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding"); SecretKeySpec secretKeySpec = new SecretKeySpec(key, "AES"); //准备iv参数，用于支持CBC或者ECB模式 IvParameterSpec ivParameterSpec = new IvParameterSpec(iv); cipher.init(mode, secretKeySpec, ivParameterSpec); result = cipher.doFinal(data); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (NoSuchPaddingException e) &#123; e.printStackTrace(); &#125; catch (InvalidKeyException e) &#123; e.printStackTrace(); &#125; catch (BadPaddingException e) &#123; e.printStackTrace(); &#125; catch (IllegalBlockSizeException e) &#123; e.printStackTrace(); &#125; catch (InvalidAlgorithmParameterException e) &#123; e.printStackTrace(); &#125; return result; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RSA加密解密]]></title>
    <url>%2Farticle%2F1309915903%2F</url>
    <content type="text"><![CDATA[什么是对称加密，什么是非对称加密？ 加密解密使用同样的密钥，则是对称加密，使用不一样的密钥就是非对称加密，RSA属于非对称加密。 RSA中有公钥和私钥的概念，公钥加密私钥解密，私钥加密公钥解密，也可以使用RSA对消息进行签名 一些常量1234567891011121314151617181920212223242526272829/** * 加密算法RSA */ public static final String KEY_ALGORITHM = "RSA"; /** * 签名算法 */ public static final String SIGNATURE_ALGORITHM = "MD5withRSA"; /** * 获取公钥的key */ public static final String PUBLIC_KEY = "RSAPublicKey"; /** * 获取私钥的key */ public static final String PRIVATE_KEY = "RSAPrivateKey"; /** * RSA最大加密明文大小 */ private static final int MAX_ENCRYPT_BLOCK = 117; /** * RSA最大解密密文大小 */ private static final int MAX_DECRYPT_BLOCK = 128; 2.获取密钥对 这里使用了内置的方法获取生成的公钥私钥，返回的密钥已经经过了Base64编码的处理，是可见的字符串。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 /** * &lt;p&gt; * 生成密钥对(公钥和私钥) * &lt;/p&gt; * * @return * @throws Exception */ public static Map&lt;String, Object&gt; getKeyPair(int size) throws Exception &#123; KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(KEY_ALGORITHM); keyPairGen.initialize(size); KeyPair keyPair = keyPairGen.generateKeyPair(); RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic(); RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate(); Map&lt;String, Object&gt; keyMap = new HashMap&lt;String, Object&gt;(2); keyMap.put(PUBLIC_KEY, publicKey); keyMap.put(PRIVATE_KEY, privateKey); return keyMap; &#125;/** * &lt;p&gt; * 获取私钥 * &lt;/p&gt; * * @param keyMap 密钥对 * @return 获取的key已经经过base64编码 * @throws Exception */ public static String getPrivateKey(Map&lt;String, Object&gt; keyMap) throws Exception &#123; Key key = (Key) keyMap.get(PRIVATE_KEY); // return Base64Utils.encode(key.getEncoded()); return Base64.encodeToString(key.getEncoded(), Base64.NO_WRAP); &#125; /** * &lt;p&gt; * 获取公钥 * &lt;/p&gt; * * @param keyMap 密钥对 * @return 获取的key已经经过base64编码 * @throws Exception */ public static String getPublicKey(Map&lt;String, Object&gt; keyMap) throws Exception &#123; Key key = (Key) keyMap.get(PUBLIC_KEY); // return Base64Utils.encode(key.getEncoded()); return Base64.encodeToString(key.getEncoded(), Base64.NO_WRAP); &#125;` 私钥加密123456789101112131415161718192021222324252627282930313233343536373839 /** * &lt;p&gt; * 私钥加密 * &lt;/p&gt; * * @param data 源数据 * @param privateKey 私钥(BASE64编码) * @return * @throws Exception */ public static byte[] encryptByPrivateKey(byte[] data, String privateKey) throws Exception &#123;// byte[] keyBytes = Base64Utils.decode(privateKey); byte[] keyBytes = Base64.decode(privateKey, Base64.NO_WRAP); PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key privateK = keyFactory.generatePrivate(pkcs8KeySpec); Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.ENCRYPT_MODE, privateK); int inputLen = data.length; ByteArrayOutputStream out = new ByteArrayOutputStream(); int offSet = 0; byte[] cache; int i = 0; // 对数据分段加密 while (inputLen - offSet &gt; 0) &#123; if (inputLen - offSet &gt; MAX_ENCRYPT_BLOCK) &#123; cache = cipher.doFinal(data, offSet, MAX_ENCRYPT_BLOCK); &#125; else &#123; cache = cipher.doFinal(data, offSet, inputLen - offSet); &#125; out.write(cache, 0, cache.length); i++; offSet = i * MAX_ENCRYPT_BLOCK; &#125; byte[] encryptedData = out.toByteArray(); out.close(); return encryptedData; &#125; 公钥加密123456789101112131415161718192021222324252627282930313233343536373839/** * &lt;p&gt; * 公钥加密 * &lt;/p&gt; * * @param data 源数据 * @param publicKey 公钥(BASE64编码) * @return * @throws Exception */ public static byte[] encryptByPublicKey(byte[] data, String publicKey) throws Exception &#123; byte[] keyBytes = Base64.decode(publicKey, Base64.NO_WRAP); X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key publicK = keyFactory.generatePublic(x509KeySpec); // 对数据加密 Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.ENCRYPT_MODE, publicK); int inputLen = data.length; ByteArrayOutputStream out = new ByteArrayOutputStream(); int offSet = 0; byte[] cache; int i = 0; // 对数据分段加密 while (inputLen - offSet &gt; 0) &#123; if (inputLen - offSet &gt; MAX_ENCRYPT_BLOCK) &#123; cache = cipher.doFinal(data, offSet, MAX_ENCRYPT_BLOCK); &#125; else &#123; cache = cipher.doFinal(data, offSet, inputLen - offSet); &#125; out.write(cache, 0, cache.length); i++; offSet = i * MAX_ENCRYPT_BLOCK; &#125; byte[] encryptedData = out.toByteArray(); out.close(); return encryptedData; &#125; 公钥解密123456789101112131415161718192021222324252627282930313233343536373839/** * &lt;p&gt; * 公钥解密 * &lt;/p&gt; * * @param encryptedData 已加密数据 * @param publicKey 公钥(BASE64编码) * @return * @throws Exception */public static byte[] decryptByPublicKey(byte[] encryptedData, String publicKey) throws Exception &#123; byte[] keyBytes = Base64.decode(publicKey, Base64.NO_WRAP); X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key publicK = keyFactory.generatePublic(x509KeySpec); Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.DECRYPT_MODE, publicK); int inputLen = encryptedData.length; ByteArrayOutputStream out = new ByteArrayOutputStream(); int offSet = 0; byte[] cache; int i = 0; // 对数据分段解密 while (inputLen - offSet &gt; 0) &#123; if (inputLen - offSet &gt; MAX_DECRYPT_BLOCK) &#123; cache = cipher.doFinal(encryptedData, offSet, MAX_DECRYPT_BLOCK); &#125; else &#123; cache = cipher.doFinal(encryptedData, offSet, inputLen - offSet); &#125; out.write(cache, 0, cache.length); i++; offSet = i * MAX_DECRYPT_BLOCK; &#125; byte[] decryptedData = out.toByteArray(); out.close(); return decryptedData;&#125; 私钥解密1234567891011121314151617181920212223242526272829303132333435363738/** * &lt;P&gt; * 私钥解密 * &lt;/p&gt; * * @param encryptedData 已加密数据 * @param privateKey 私钥(BASE64编码) * @return * @throws Exception */ public static byte[] decryptByPrivateKey(byte[] encryptedData, String privateKey) throws Exception &#123; byte[] keyBytes = Base64.decode(privateKey, Base64.NO_WRAP); PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key privateK = keyFactory.generatePrivate(pkcs8KeySpec); Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.DECRYPT_MODE, privateK); int inputLen = encryptedData.length; ByteArrayOutputStream out = new ByteArrayOutputStream(); int offSet = 0; byte[] cache; int i = 0; // 对数据分段解密 while (inputLen - offSet &gt; 0) &#123; if (inputLen - offSet &gt; MAX_DECRYPT_BLOCK) &#123; cache = cipher.doFinal(encryptedData, offSet, MAX_DECRYPT_BLOCK); &#125; else &#123; cache = cipher.doFinal(encryptedData, offSet, inputLen - offSet); &#125; out.write(cache, 0, cache.length); i++; offSet = i * MAX_DECRYPT_BLOCK; &#125; byte[] decryptedData = out.toByteArray(); out.close(); return decryptedData; &#125; 消息签名123456789101112131415161718192021/** * &lt;p&gt; * 用私钥对信息生成数字签名 * &lt;/p&gt; * * @param data 已加密数据 * @param privateKey 私钥(BASE64编码) * @return * @throws Exception */public static String sign(byte[] data, String privateKey) throws Exception &#123; byte[] keyBytes = Base64.decode(privateKey, Base64.NO_WRAP); PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); PrivateKey privateK = keyFactory.generatePrivate(pkcs8KeySpec); Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM); signature.initSign(privateK); signature.update(data); return Base64.encodeToString(signature.sign(), Base64.NO_WRAP);&#125; 验证签名12345678910111213141516171819202122/** * &lt;p&gt; * 使用公钥校验数字签名 * &lt;/p&gt; * * @param data 已加密数据 * @param publicKey 公钥(BASE64编码) * @param sign 数字签名 * @return * @throws Exception */ public static boolean verifySign(byte[] data, String publicKey, String sign) throws Exception &#123; byte[] keyBytes = Base64.decode(publicKey, Base64.NO_WRAP); X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); PublicKey publicK = keyFactory.generatePublic(keySpec); Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM); signature.initVerify(publicK); signature.update(data); return signature.verify(Base64.decode(sign, Base64.NO_WRAP)); &#125; 抽取公共代码 可以发现有很多重复代码，这样写是为了更加清晰，代码抽取一下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * * 使用私钥操作时 * @param data * @param key * @param mode * @return * @throws Exception */ public static byte[] UsePrivate(byte[] data, String key,int mode) throws Exception &#123; byte[] keyBytes = Base64.decode(key, Base64.NO_WRAP); PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key privateK = keyFactory.generatePrivate(pkcs8KeySpec); Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(mode, privateK); int inputLen = data.length; ByteArrayOutputStream out = new ByteArrayOutputStream(); int offSet = 0; byte[] cache; int i = 0; // 对数据分段解密 while (inputLen - offSet &gt; 0) &#123; if (inputLen - offSet &gt; MAX_DECRYPT_BLOCK) &#123; cache = cipher.doFinal(data, offSet, MAX_DECRYPT_BLOCK); &#125; else &#123; cache = cipher.doFinal(data, offSet, inputLen - offSet); &#125; out.write(cache, 0, cache.length); i++; offSet = i * MAX_DECRYPT_BLOCK; &#125; byte[] decryptedData = out.toByteArray(); out.close(); return decryptedData; &#125; /** * 使用公钥操作 * @param data * @param key * @param mode * @return * @throws Exception */ public static byte[] UsePublic(byte[] data, String key,int mode) throws Exception &#123; byte[] keyBytes = Base64.decode(key, Base64.NO_WRAP); X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key publicK = keyFactory.generatePublic(x509KeySpec); Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(mode, publicK); int inputLen = data.length; ByteArrayOutputStream out = new ByteArrayOutputStream(); int offSet = 0; byte[] cache; int i = 0; // 对数据分段解密 while (inputLen - offSet &gt; 0) &#123; if (inputLen - offSet &gt; MAX_DECRYPT_BLOCK) &#123; cache = cipher.doFinal(data, offSet, MAX_DECRYPT_BLOCK); &#125; else &#123; cache = cipher.doFinal(data, offSet, inputLen - offSet); &#125; out.write(cache, 0, cache.length); i++; offSet = i * MAX_DECRYPT_BLOCK; &#125; byte[] decryptedData = out.toByteArray(); out.close(); return decryptedData; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python发送get/post/put/delete请求]]></title>
    <url>%2Farticle%2F3174426477%2F</url>
    <content type="text"><![CDATA[Get请求12345# 如果没有header可以不传request = urllib2.Request(reqUrl, reqHeader)# reqTimeOut为超时时间，不设置可以不传response = urllib2.urlopen(request, reqTimeOut)print respone.read() Post请求12345# 如果没有header可以不传request = urllib2.Request(reqUrl,reqHeader,postData)# reqTimeOut为超时时间，不设置可以不传response = urllib2.urlopen(request, reqTimeOut)print respone.read() Put请求123456# 如果没有header可以不传request = urllib2.Request(reqUrl,reqHeader,postData)# reqTimeOut为超时时间，不设置可以不传response = urllib2.urlopen(request, reqTimeOut)request.get_method = lambda: 'PUT'print respone.read() Delete请求123456# 如果没有header可以不传request = urllib2.Request(reqUrl,reqHeader,postData)# reqTimeOut为超时时间，不设置可以不传response = urllib2.urlopen(request, reqTimeOut)request.get_method = lambda: 'DELETE'print respone.read() debug12345//使用Handler打印日志httpHandler = urllib2.HTTPHandler(debuglevel=1)httpsHandler = urllib2.HTTPSHandler(debuglevel=1)opener = urllib2.build_opener(httpHandler, httpsHandler)urllib2.install_opener(opener) 总结 一个集合了几种请求的工具类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192# -*-coding:utf-8 -*-import urllib2from httptst.Singleton import singleton__metaclass = type@singletonclass HttpHelper: def __init__(self): pass name = 'http helper' # header __reqHeader = &#123;&#125; # url __reqUrl = '' # time __reqTimeOut = 0 # 构建Get请求 def __buildGetRequest(self): if len(self.__reqHeader) == 0: request = urllib2.Request(self.__reqUrl) else: request = urllib2.Request(self.__reqUrl, headers=self.__reqHeader) return request # 构建post,put,delete请求 def __buildPostPutDeleteRequest(self, postData): if len(self.__reqHeader) == 0: request = urllib2.Request(self.__reqUrl, data=postData) else: request = urllib2.Request(self.__reqUrl, headers=self.__reqHeader, data=postData) return request # 添加header def headers(self, headers): self.__reqHeader = headers return self # 添加url def url(self, url): print url self.__reqUrl = url return self # 添加超时 def timeOut(self, time): self.__reqTimeOut = time return self # 是否debug def debug(self): httpHandler = urllib2.HTTPHandler(debuglevel=1) httpsHandler = urllib2.HTTPSHandler(debuglevel=1) opener = urllib2.build_opener(httpHandler, httpsHandler) urllib2.install_opener(opener) return self # 处理response def __handleResponse(self, request, func): try: if self.__reqTimeOut == 0: res = urllib2.urlopen(request) else: res = urllib2.urlopen(request, self.__reqTimeOut) func(res.read()) except urllib2.HTTPError, e: print e.code # get请求 def get(self, func): request = self.__buildGetRequest() self.__handleResponse(request, func) # post请求 def post(self, postData, func): request = self.__buildPostPutDeleteRequest(postData=postData) self.__handleResponse(request, func) # put请求 def put(self, putData, func): request = self.__buildPostPutDeleteRequest(postData=putData) request.get_method = lambda: 'PUT' self.__handleResponse(request, func) # delete请求 def delete(self, putData, func): request = self.__buildPostPutDeleteRequest(postData=putData) request.get_method = lambda: 'DELETE' self.__handleResponse(request, func) 测试1234567891011121314def getData(data): print datahttpHelper = HttpHelper()url_baidu = 'http://www.baidu.com'#简单的get请求httpHelper.url(url=url_baidu).get(func=getData)# post请求httpHelper.debug() \ .url(url=url_post_pics) \ .headers(headers=getHeader()) \ .post(postData=post_data_pics, func=getData)# post请求httpHelper.debug().url(url_post_invite_one).headers(getHeader()).post(post_data_invite_one,getData)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac + AndroidStudio 快捷操作]]></title>
    <url>%2Farticle%2F8d16bcb4%2F</url>
    <content type="text"><![CDATA[快捷键常用123456789101112131415161718- 快速提示alt + Enter- 跳转到某一行command + L- 整理代码alt + command + L- 重命名变量shift + F6- 代码大小写转换shift + command + u- 列选中alt + 鼠标 提取12345- 提取代码块为方法alt + command + M (method)- 提取局部变量为全局变量alt + command + F (field) 搜索／替换12345678910111213141516- 搜索 java 文件command + O- 搜索所有文件shift + command + O - 文件内查找文本command + F- 项目内查找文本shift + command + F- 文件内文本替换command + R- 项目内文本替换shift + command + R- search everywhere 双击 shift project 操作12345678910- 打开 ProjectStructurecommand + ;(分号)- 打开 settingscommand + ,(逗号)- 运行项目control + R- 运行 freelineshift + command + F10 代码快捷用法通用12345678910111213141516171819202122232425User user = new User();// 判断不为空; user.nnif (user != null) &#123;&#125;// 判断为空; user.nullif (user == null) &#123;&#125;// 返回; user.returnreturn user;// instanceof 判断; user.instList temp = user instanceof List ? ((List) list) : null;// 生成条件表达式; 条件表达式.if 如输入 100&gt;10.ifif (100 &gt; 10) &#123; &#125;// 生成while循环; 条件表达式.while 如输入 100&gt;10.whilewhile (100 &gt; 10) &#123; &#125; 快速遍历12345678910111213141516List&lt;String&gt; list = new ArrayList&lt;&gt;();// list.forfor (String s : list) &#123; &#125;// list.forifor (int i = 0; i &lt; list.size(); i++) &#123; &#125;// list.forrfor (int i = list.size() - 1; i &gt;= 0; i--) &#123; &#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>DevEnvironment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TabLayout]]></title>
    <url>%2Farticle%2F1315779230%2F</url>
    <content type="text"><![CDATA[本文主要介绍 TabLayout 的详细使用，持续完善中… TabLayout 的基本属性及效果 TabLayout 与 ViewPager 联动 自定义 TabLayout 的 tab 显示 基本属性介绍12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;android.support.design.widget.TabLayout android:id="@+id/fragment_discover_tably" android:layout_width="match_parent" android:layout_height="wrap_content"/&gt; 1. tabModeapp:tabMode="fixed|scrollable" tabMode属性有两个取值:fixed时，所有的tab会居中显示，是不可滑动的，scrollable时，所有的tab会靠左显示，当tab数量很多时，就会呈现滑动的效果，这对适配小屏幕手机至关重要。2. 导航条的高度和颜色app:tabIndicatorHeight="3dp"app:tabIndicatorColor="#af00"3. tab的宽度限制当文字很少时仍旧不会小于tabMinWidth当文字过多时，也不会将tab撑的超过tabMaxWidthapp:tabMaxWidth="150dp"app:tabMinWidth="60dp"4. tab被选中或没有被选中时的颜色app:tabTextColor="@color/black"app:tabSelectedTextColor="@color/colorPrimary"5. 更改Tab上面的TextView的详细显示app:tabTextAppearance="@style/TabLayoutStyle"&lt;style name="TabLayoutStyle" parent="TextAppearance.Design.Tab"&gt; &lt;item name="android:textSize"&gt;16sp&lt;/item&gt; &lt;item name="android:textStyle"&gt;normal&lt;/item&gt;&lt;/style&gt;6. 背景app:tabBackground="@color/transparent"设置tab的背景颜色，默认TabLayout点击时是有光晕效果的，使用该属性可以去掉光晕效果。7. tab间隔默认tab左右两边是有padding的，使用以下属性可以去掉padding，只使用tabPadding是没有效果的，要具体到设置到哪个padding app:tabPadding="0dp"app:tabPaddingBottom="0dp"app:tabPaddingEnd="0dp"app:tabPaddingStart="0dp"app:tabPaddingTop="0dp" 与 ViewPager 联动使用 TabLayout 的 setupWithViewPager() 方法，可以实现与 ViewPager 的联动，但是需要注意的是写 ViewPager 时需要实现 getTitle() 方法，用来设置 tab 的标题。原先给 Tab 设置的标题将会被覆盖掉。 1tabLy.setupWithViewPager(viewPager); 自定义 Tab 显示默认的 TabLayout 是可以显示文字和 Icon 的，但是定制度不是很高，往往不能实现预期效果，不过好在 TabLayout 开放了 setCustomView(childView) 这个 API 来支持我们自定义 TabLayout 的UI，当然自定义显示之后也损失了切换时颜色切换等效果，需要我们自己来处理，下面是我定义了一个辅助类，使用类似 adapter 的形式来加载 TabLayout 的每个 tab 的显示，实现自定义效果，也对选中事件等作了简化操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194/** * CreateAt : 2017/3/29 * Describe : TabLayout适配器,快速实现TabLayout自定义View数据加载 * * @author chendong */public abstract class BaseTabAdapter&lt;T&gt; &#123; public static final String TAG = BaseTabAdapter.class.getSimpleName(); private Context mContext; // 自定义布局layout文件 private int mResId; // 数据源 private List&lt;T&gt; mDatas; // 全部的控件，用来切换时改变显示 private List&lt;TabLayoutViewHolder&gt; mTabLayoutViewHolders; // tabLayout private TabLayout mTabLayout; // 简化的tab点击事件 private OnTabSelectListener&lt;T&gt; mOnTabSelectListener; private boolean mIsReady; /** * Tab选中的接口 * * @param &lt;T&gt; */ public interface OnTabSelectListener&lt;T&gt; &#123; void onSelect(int pos, T data); &#125; protected BaseTabAdapter(Context context, List&lt;T&gt; datas, int resId) &#123; mDatas = datas; mContext = context; mResId = resId; mTabLayoutViewHolders = new ArrayList&lt;&gt;(); &#125; public void attachTabLayout(TabLayout tabLayout) &#123; tabLayout.clearOnTabSelectedListeners(); attachTabLayout(tabLayout, 0); &#125; public void attachTabLayout(TabLayout tabLayout, int posSelect) &#123; mIsReady = false; mTabLayout = tabLayout; // 设置导航条高度=0 tabLayout.setSelectedTabIndicatorHeight(0); tabLayout.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener() &#123; @Override public void onTabSelected(TabLayout.Tab tab) &#123; L.e(TAG, "onTabSelected " + tab.getPosition()); int position = tab.getPosition(); if (mIsReady &amp;&amp; mOnTabSelectListener != null) &#123; mOnTabSelectListener.onSelect(position, mDatas.get(position)); &#125; updateStatus(mTabLayoutViewHolders.get(position), mDatas.get(position), true); &#125; @Override public void onTabUnselected(TabLayout.Tab tab) &#123; L.e(TAG, "onTabUnselected " + tab.getPosition()); updateStatus(mTabLayoutViewHolders.get(tab.getPosition()), mDatas.get(tab.getPosition()), false); &#125; @Override public void onTabReselected(TabLayout.Tab tab) &#123; L.e(TAG, "onTabReselected " + tab.getPosition()); updateStatus(mTabLayoutViewHolders.get(tab.getPosition()), mDatas.get(tab.getPosition()), true); &#125; &#125;); // 初始化view,默认初始化为全部不选中 View childView; TabLayoutViewHolder holder; TabLayout.Tab tab; for (int i = 0; i &lt; mDatas.size(); i++) &#123; childView = LayoutInflater.from(mContext).inflate(mResId, tabLayout, false); holder = new TabLayoutViewHolder(childView); mTabLayoutViewHolders.add(holder); updateStatus(mTabLayoutViewHolders.get(i), mDatas.get(i), false); tab = tabLayout.newTab().setCustomView(childView); tabLayout.addTab(tab); &#125; // 选中初始化选中的那个 TabLayout.Tab tabAt = tabLayout.getTabAt(posSelect); if (tabAt != null) &#123; tabAt.select(); if (mOnTabSelectListener != null) &#123; mOnTabSelectListener.onSelect(posSelect, mDatas.get(posSelect)); &#125; &#125; mIsReady = true; &#125; public void notifyItemChanged(int pos) &#123; if (pos &gt;= 0 &amp;&amp; pos &lt; mDatas.size()) &#123; TabLayout.Tab tabAt; tabAt = mTabLayout.getTabAt(pos); updateStatus(mTabLayoutViewHolders.get(pos), mDatas.get(pos), tabAt != null &amp;&amp; tabAt.isSelected()); &#125; &#125; public void notityDataSetChanged() &#123; TabLayout.Tab tabAt; for (int i = 0; i &lt; mDatas.size(); i++) &#123; tabAt = mTabLayout.getTabAt(i); updateStatus(mTabLayoutViewHolders.get(i), mDatas.get(i), tabAt != null &amp;&amp; tabAt.isSelected()); &#125; &#125; /** * 抽象方法，更新控件状态显示 * * @param holder view holder * @param data 数据 * @param isSelect 是否选中 */ public abstract void updateStatus(TabLayoutViewHolder holder, T data, boolean isSelect); public void setOnTabSelectListener(OnTabSelectListener&lt;T&gt; onTabSelectListener) &#123; mOnTabSelectListener = onTabSelectListener; &#125; public interface OnBuildTabListener&lt;D&gt; &#123; TabLayout.Tab onBuild(TabLayout.Tab tab, D data); &#125; public static &lt;D&gt; void buildTabLayout(TabLayout tabLayout, List&lt;D&gt; datas, OnBuildTabListener&lt;D&gt; listener) &#123; TabLayout.Tab tab; for (D data : datas) &#123; tab = tabLayout.newTab(); tabLayout.addTab(listener.onBuild(tab, data)); &#125; &#125; /** * 公共holder，用来存储和快速获取控件 */ public static class TabLayoutViewHolder &#123; private View parentView; private SparseArray&lt;View&gt; mCacheViews; public View getItemView() &#123; return parentView; &#125; TabLayoutViewHolder(View parentView) &#123; this.parentView = parentView; mCacheViews = new SparseArray&lt;&gt;(); &#125; public &lt;V extends View&gt; V getView(int resId) &#123; V v = (V) mCacheViews.get(resId); if (v == null) &#123; v = (V) parentView.findViewById(resId); if (v != null) &#123; mCacheViews.put(resId, v); &#125; &#125; return v; &#125; &#125; public void setUpViewPager(final ViewPager viewPager) &#123; if (mTabLayout == null) &#123; Log.e("chendong", "TabLayout is null ,invoke attachTabLayout first"); return; &#125; mTabLayout.addOnTabSelectedListener(new MyOnTabSelectedListener() &#123; @Override public void onTabSelected(TabLayout.Tab tab) &#123; if (viewPager != null) viewPager.setCurrentItem(tab.getPosition()); &#125; &#125;); if (viewPager != null) viewPager.addOnPageChangeListener(new MyOnPageChangeListener() &#123; @Override public void onPageSelected(int position) &#123; if (mTabLayout != null) &#123; TabLayout.Tab tabAt = mTabLayout.getTabAt(position); if (tabAt != null) tabAt.select(); &#125; &#125; &#125;); &#125;&#125; how to usage? 123456789101112131415161718BaseTabAdapter&lt;Baby&gt; adapter = new BaseTabAdapter&lt;Baby&gt;(mActivty, babies, R.layout.vip_select_family_baby_item) @Override public void updateStatus(TabLayoutViewHolder holder, Baby data, boolean isSelect) &#123; holder.getView(R.id.parent).getLayoutParams().width = (int) (BaoBaoApplication.DISPLAY_WIDTH / 3f); TextView nameTv = holder.getView(R.id.tv_name); nameTv.setText(data.getBabyName()); holder.getView(R.id.view_line).setBackgroundColor(isSelect ? ContextCompat.getColor(mBaseFragmentActivity, R.color.colorPrimary) : ContextCompat.getColor(mBaseFragmentActivity, R.color.color_EFEFEF)); &#125;&#125;;adapter.setOnTabSelectListener(new BaseTabAdapter.OnTabSelectListener&lt;Baby&gt;() &#123; @Override public void onSelect(int pos, Baby data) &#123; // 请求数据，展示数据 &#125;&#125;);adapter.attachTabLayout(mTabLayout, 1);]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用传统Android组件实现高效数据加载]]></title>
    <url>%2Farticle%2F3092091804%2F</url>
    <content type="text"><![CDATA[前言 本文主要介绍使用ContentProvider + Sqlite + Loader等Android的基本组件实现高内聚低耦合的数据加载的数据设计模式，这是一种传统而高效的数据加载，熟悉这种模式同时也是对ContentProvider的更好掌握。 优势 ContentProvider可以非常简单的调整数据源而不影响其他程序。外部程序不关心数据，只关心返回的Cursor.举个例子，ContentProvider指向的数据库可以随时改变不会影响使用者，同时ContentProvider也可以返回网络数据，使用者只要求结果是Cursor,但是对于数据来自哪里并不关心，这样就实现了数据读取和使用的分离。 提供数据安全保护与权限管理，ContentProvider使用授权机制，对数据在方便访问的同时进行了很好地保护。 强大的API支持，Google官方提供了强大的API. ##Loader特点： 与Activity管理同步，与Activity/Fragment生命周期同步，创建与销毁都会受到Activity/Fragment生命周期的管理。这就意味着我们不需要再去考虑何时去加载数据，使用Loader之后会结合Activity或者Fragment的生命周期自行进行加载和更新。 内部线程异步加载，我们也就不需要再去开启线程获取数据解析数据，大大减少了代码量。 数据源发生改变时实时更新，貌似我们自己的数据数据是无法自动更新的，不过不要紧，只需要一行简单的reStartLoader就可以手动重新加载一下。 数据分层 Loader 写操作 ContentProvider SQLite 定义关系类 定义一个关系类，声明表结构,Uri,授权 1234567891011121314151617181920212223242526public class WebContract &#123; public static final String Tb_History = &quot;tb_history&quot;; public static final String Tb_BookMark = &quot;tb_bookmark&quot;; public static final String Authority = &quot;com.march.db_browser&quot;; public static class History implements BaseColumns &#123; //content://com.march.db_browser/tb_history public static final Uri ContentUri = Uri.parse( &quot;content://&quot; + Authority).buildUpon().appendPath(Tb_History).build(); public static final String Link = &quot;link&quot;; public static final String Icon = &quot;icon&quot;; public static final String Title = &quot;title&quot;; public static final String Time = &quot;time&quot;; &#125; public static class BookMark implements BaseColumns &#123; //content://com.march.db_browser/tb_history public static final Uri ContentUri = Uri.parse( &quot;content://&quot; + Authority).buildUpon().appendPath(Tb_BookMark).build(); public static final String Link = &quot;link&quot;; public static final String Icon = &quot;icon&quot;; public static final String Title = &quot;title&quot;; public static final String Time = &quot;time&quot;; &#125;&#125; 继承ContentProvider 实现数据提供者，设定好Code作为表资源的唯一标示，使用UriMacher匹配 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class WebContentProvider extends ContentProvider &#123;/*为可以访问的数据库表资源定义代号，区分哪个表可以被访问*/private static final int CODE_BOOKMARK = 0x1;private static final int CODE_HISTORY = 0x2;/*使用UriMacher生成访问的Uri*/private static UriMatcher uriMatcher;/*使用静态代码块初始化UriMacher,添加*/static &#123;uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);uriMatcher.addURI(WebContract.Authority, WebContract.Tb_BookMark, CODE_BOOKMARK);uriMatcher.addURI(WebContract.Authority, WebContract.Tb_History, CODE_HISTORY);&#125;private MySqliteOpenHelper mySqliteOpenHelper;private SQLiteDatabase db;@Overridepublic boolean onCreate() &#123;mySqliteOpenHelper = new MySqliteOpenHelper(getContext(), "db_browser", 1);return false;&#125;@Overridepublic Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123;Cursor cursor = null;if (uri != null) &#123;int code = uriMatcher.match(uri);db = mySqliteOpenHelper.getWritableDatabase();switch (code) &#123;case CODE_BOOKMARK:cursor = db.query(WebContract.Tb_BookMark, null, null, null, null, null, null);break;case CODE_HISTORY:cursor = db.query(WebContract.Tb_History, null, null, null, null, null, null);break;&#125;&#125;if (cursor == null) &#123;Log.i("chendong", "cursor is null");&#125; // db.close();//读操作不能关闭连接，写操作需要关闭连接return cursor;&#125;@Overridepublic String getType(Uri uri) &#123;return null;&#125;@Overridepublic Uri insert(Uri uri, ContentValues values) &#123;Uri uri_return = null;if (uri != null) &#123;int code = uriMatcher.match(uri);db = mySqliteOpenHelper.getWritableDatabase();long id = -1;switch (code) &#123;case CODE_BOOKMARK:id = db.insert(WebContract.Tb_BookMark, null, values);break;case CODE_HISTORY:id = db.insert(WebContract.Tb_History, null, values);break;&#125;if (id != -1) &#123;uri_return = ContentUris.withAppendedId(uri, id);&#125;db.close();&#125;return uri_return;&#125;@Overridepublic int delete(Uri uri, String selection, String[] selectionArgs) &#123;// Implement this to handle requests to delete one or more rows.throw new UnsupportedOperationException("Not yet implemented");&#125;@Overridepublic int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123;// TODO: Implement this to handle requests to update one or more rows.throw new UnsupportedOperationException("Not yet implemented");&#125;&#125; 使用Loader加载数据``` adapter = new SimpleCursorAdapter(this, R.layout.item_listview, null, new String[]{WebContract.History.Title, WebContract.History.Link}, new int[]{R.id.item_listview_title, R.id.item_listview_url}, SimpleCursorAdapter.FLAG_REGISTER_CONTENT_OBSERVER); listView.setAdapter(adapter); getLoaderManager().initLoader(0x123, bundle, this); //这是实现的 implements LoaderManager.LoaderCallbacks&lt;Cursor&gt; 的方法 @Override public Loader&lt;Cursor&gt; onCreateLoader(int id, Bundle args) { int action = args.getInt(&quot;action&quot;); CursorLoader cursorLoader = null; Log.i(&quot;chendong&quot;, &quot;action is &quot; + action); if (action == 0) { //history cursorLoader = new CursorLoader(this, WebContract.History.ContentUri, null, null, null, null); } else { cursorLoader = new CursorLoader(this, WebContract.BookMark.ContentUri, null, null, null, null); } return cursorLoader; } @Override public void onLoadFinished(Loader&lt;Cursor&gt; loader, Cursor data) { Log.i(&quot;chendong&quot;, &quot;get data &quot;); adapter.changeCursor(data); } @Override public void onLoaderReset(Loader&lt;Cursor&gt; loader) { } 使用 getLoaderManager().restartLoader(0x123, bundle, this); 重新加载数据]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AndroidTips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android编码解码及其原理]]></title>
    <url>%2Farticle%2F438600076%2F</url>
    <content type="text"><![CDATA[前言 本文用到ASCII表，Base64对照表请自行百度。 概念：编码解码就是使用特定的算法，将数据进行处理，形成数据的另外一种表现形式，编码后的数据可以使用解码算法还原出原始数据。 Base64简介 Base64算法可以将任意的字节数组数据通过算法生成只有（英文大小写，数字，+，/）共64种字符的字符串数据；相当于将任意内容转换为可见字符串表示。 也就是将不可见的数据转换为ASCII码数据，便于在Json和Xml中传递。 Base64Api1234567891011121314//将字节数组编码，返回为StringBase64.encodeToString(byte[] bs,int flag);//将字节数组编码，返回字节数组Base64.encode(byte[] bs,int flag);//将字节数组按指定位置部分编码，返回字符串Base64.encodeToString(byte[] bs,int offset,int lenth);//将字节数组按指定位置部分编码，返回字节数组Base64.encode(byte[] bs,int offset,int lenth);//将编码后的字符串解码返回字节数组Base64.decode(String str,int flag);//将编码后的字节数组解码返回字节数组Base64.decode(byte[],int flag);//将编码后的字节数组按指定位置部分解码，返回字节数组Base64.decode(byte[] bs,int offset,int len); flag常量1234567891011Base64.CRLF 这个参数意思是Win风格的换行符，意思就是使用CR LF这一对作为一行的结尾而不是Unix风格的LFBase64.DEFAULT 这个参数是默认，使用默认的方法来加密Base64.NO_PADDING 这个参数是略去加密字符串最后的”=”Base64.NO_WRAP 这个参数意思是略去所有的换行符（设置后CRLF就没用了）Base64.URL_SAFE 这个参数意思是加密时不使用对URL和文件名有特殊意义的字符来作为加密字符，具体就是以-和_取代+和///习惯上使用Base64.NO_WRAP，使用什么方式编码就需要使用什么方式解码。 Base64原理 Base64在编码时按照三个字节一组分组， 进行处理，每三个字节在编码之后被转换为4个字符。 每个字节有8个bit(也必须是要求有8bit，所以中文是不可以的),三个字节就有24个bit. 但是我们只有64 种字符选择，也就是Base64的字符最多只能用6bit来表示，再大就会超出64的范围，所以编码以后显示的字符开始两位是0. 那么原先24bit的数据要显示在现在每个字符只有6bit的表示方法上，很明显需要4个字符（3*8 == 4*6） 当数据长度在无法满足3的倍数的时候会在末尾添加“=“具体的转换方法直接说可能有点抽象， 字符串Base64编码过程 字符串String str = &quot;0Aa&quot;;首先，原先每个字符是2个字节16bit,对于英文来说前8个bit是0，也就是只有8个bit,现在是3个字符，3*8=24个bit需要显示。 转换 get 0 A a ASCII 48 65 97 二进制表示 00110000 01000001 01100001 现在拼凑成是这样的二进制串( 001100 000100 000101 100001)，将其转化为Base64可以显示的模式，需要每次取6位作为一个Base64字符,前两位补0 get 1 2 3 4 开始 001100 000100 000101 100001 转化 00001100 00000100 00000101 00100001 转为10进制 12 4 5 33 Base64字符 M E F h 二进制数组编码过程 这个例子已经很清晰的解释了Base64的编码过程，网上有人自己实现了Base64编码的类，android源码也不难，这是编码字符串看起来还是比较清晰的，我们也可以更本质一点 byte[] bs = new byte[]{1,10,20};这是一个byte数组，复习一下，1个byte是8个bit,可以表示的范围0-127之间，我们在调用Base64的函数时，本质也是在操作字节数组，同样的原理 byte 1 10 20 二进制表示 00000001 00001010 00010100 6位一组，二进制串000000 010000 101000 010100 get 1 2 3 4 开始 000000 010000 101000 010100 转化 00000000 00010000 00101000 00010100 转为10进制 0 16 40 20 Base64字符 A Q o U Hex编码简介 Hex就是16进制，本质上是将字节数组转化为16进制，然后用字符串的形式表现出来，我们知道16进制的取值范围就是在0-f之间，这样就可以将无法显示的字节数组数据显示出来。 原理方面比起Base64就简单很多了，一个8bit的数据，也就是（xxxx xxxx）,每4个bit可以转化为一个16进制表示，也就是8个bit会转化为（00-ff）之间的16进制数字。 Hex编码实现12345678910111213141516171819202122232425262728293031323334/** * 字节数组转换为字符串 * 一个字节形成两个字符，是原来数据长度的两倍 * * @param data * @return */ public static String toHex(byte[] data) &#123; String ret = null; //todo 将字节数组转换为字符串 if (data != null &amp;&amp; data.length &gt; 0) &#123; StringBuilder sb = new StringBuilder(); for (byte b : data) &#123; //分别获取高四位和低四位转换为字符 int h = (b &gt;&gt; 4) &amp; 0x0f; int l = b &amp; 0x0f; char ch, cl; if (h &gt; 9) &#123;//0x0a~0x0f ch = (char) ('A' + (h - 10)); &#125; else &#123;//0~9 ch = (char) ('0' + h); &#125; if (l &gt; 9) &#123;//0x0a~0x0f cl = (char) ('A' + (l - 10)); &#125; else &#123;//0~9 cl = (char) ('0' + l); &#125; sb.append(ch).append(cl); &#125; ret = sb.toString(); &#125; return ret; &#125; Hex编码原理分析 简单说一下，&amp;运算，两者都为1结果才是1，b&gt;&gt;4&amp;0xf取出高四位，b&amp;0x0f取出低四位，举个例子： 字节是 b = 1010 1111 b&gt;&gt;4 b = 00001010 b&gt;&gt;4&amp;0x0f 也就是 00001010&amp;00001111 —-&gt; 1010高四位取出来了，取得低四位原理一样。后面的操作就是根据数据的大小转换一下格式，因为拿到的数据是十进制的那么范围会在0-15之间，需要转换为16进制的0-f. Hex解码实现12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 将编码字符串解码为字节数组 * * @param data * @return */ public static byte[] fromHex(String data) &#123; byte[] ret = null; //todo 将字符串转换为字节数组 if (data != null) &#123; int len = data.length(); char[] chs = data.toCharArray(); ret = new byte[len/2]; int ih = 0,il=0,v=0,j=0; if (len &gt; 0 &amp;&amp; len % 2 == 0) &#123; for (int i = 0; i &lt; len - 1; i += 2,j++) &#123; char ch = chs[i]; char cl = chs[i+1]; if(ch&gt;=&apos;A&apos;&amp;&amp;ch&lt;=&apos;F&apos;)&#123; ih = 10 + (ch - &apos;A&apos;); &#125;else if(ch &gt;=&apos;a&apos;&amp;&amp;ch&lt;=&apos;f&apos;)&#123; ih = 10 + (ch - &apos;a&apos;); &#125;else if(ch&gt;&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123; ih = ch - &apos;0&apos;; &#125; if(cl&gt;=&apos;A&apos;)&#123; il = 10 + (cl - &apos;A&apos;); &#125;else if(cl &gt;=&apos;a&apos;)&#123; il = 10 + (cl - &apos;a&apos;); &#125;else if(cl&gt;&apos;0&apos;)&#123; il = cl - &apos;0&apos;; &#125; v = ((ih&amp;0x0f)&lt;&lt;4)|(il&amp;0x0f); ret[j] = (byte)v; &#125; &#125; &#125; return ret; &#125; Hex解码原理分析 相当于编码的逆运算，根据字符串每次取两位，转换成int，在进行移位将其拼成一个字节，怎么拼的？v = ((ih&amp;0x0f)&lt;&lt;4)|(il&amp;0x0f); 这一句，假设我们获得的字符串最后转化结果是10和5，也就是1010，0101。10&lt;&lt;4,结果是10100000，然后10100000 | 0101，|运算只要有1则为1，结果是10100101就完成了拼接工作。 总结 Base64和Hex是比较常见的编码方式，对比一下，Base64每3个字节转化为4个字节，每个字节浪费2bit,Hex编码，每个字节转化为两个字节，每个字节浪费4bit,所以说Base64更加节省空间，而且用起来简单得多。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AndroidTips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndridStudio 使用 Freeline 加速编译]]></title>
    <url>%2Farticle%2F3239800061%2F</url>
    <content type="text"><![CDATA[buildscript { repositories { jcenter() maven { url “https://jitpack.io“ } maven { url “https://dl.bintray.com/chendongmarch/maven“ } } dependencies { classpath ‘com.android.tools.build:gradle:2.2.2’ classpath ‘com.antfortune.freeline:gradle:0.8.1’ // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files }} apply plugin: ‘com.antfortune.freeline’//阿里增量编译 freeline { hack true productFlavor ‘babyphoto’ applicationProxy false }]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>DevEnvironment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MetrailDesign]]></title>
    <url>%2Farticle%2F3353371585%2F</url>
    <content type="text"><![CDATA[Theme123456789101112131415161718&lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt;&lt;!--导航栏底色--&gt;&lt;item name="colorPrimary"&gt;@color/accent_material_dark&lt;/item&gt;&lt;!--状态栏底色--&gt;&lt;item name="colorPrimaryDark"&gt;@color/accent_material_light&lt;/item&gt;&lt;!--导航栏上的标题颜色--&gt;&lt;item name="android:textColorPrimary"&gt;@android:color/black&lt;/item&gt;&lt;!--Activity窗口的颜色--&gt;&lt;item name="android:windowBackground"&gt;@color/white&lt;/item&gt;&lt;!--按钮选中或者点击获得焦点后的颜色--&gt;&lt;item name="colorAccent"&gt;@color/accent_material_light&lt;/item&gt;&lt;!--和 colorAccent相反，正常状态下按钮的颜色,所有控价在没有获得焦点时的颜色--&gt;&lt;item name="colorControlNormal"&gt;#ff0000&lt;/item&gt;&lt;!--Button按钮正常状态颜色--&gt;&lt;item name="colorButtonNormal"&gt;@color/accent_material_light&lt;/item&gt;&lt;!--EditText 输入框中字体的颜色--&gt;&lt;item name="editTextColor"&gt;@android:color/white&lt;/item&gt;&lt;/style&gt; ##TextInputLayout XML文件123456789101112&lt;android.support.design.widget.TextInputLayout android:id="@+id/md_textinputlayout" android:layout_width="match_parent" android:layout_height="wrap_content" &gt; &lt;EditText android:id="@+id/md_edittext" android:layout_width="match_parent" android:layout_height="wrap_content" android:hint="请输入文本" /&gt; &lt;/android.support.design.widget.TextInputLayout&gt; 代码显示错误信息,文本颜色的需要使用Theme修改1234567891011TextInputLayout tily1=(TextInputLayout) findViewById(R.id.tily1);tily1.setHint("新的Hint");tily1.getEditText().addTextChangedListener(new TextWatcher()); //在监听之中进行如下设置可以显示错误信息int num = 0;if (((num = s.toString().length()) &lt; 6) &amp;&amp; num != 0) &#123; textInputLayout.setErrorEnabled(true); textInputLayout.setError("长度不能小于6");&#125; else &#123; textInputLayout.setErrorEnabled(false);&#125; SnackBar代码1234567891011121314Snackbar snackbar = Snackbar.make(view, "SnackBar测试", Snackbar.LENGTH_SHORT) //点击事件中按钮的颜色 .setActionTextColor(Color.WHITE) //设置点击事件 .setAction("SnackBar", new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.i("chendong", "点击了action"); &#125; &#125;);//修改背景颜色snackbar.getView().setBackgroundColor(Color.GRAY);snackbar.show();&#125; FloatingActionButton123456789101112&lt;android.support.design.widget.FloatingActionButton android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@mipmap/ic_launcher" android:layout_alignParentRight="true" android:layout_alignParentBottom="true" android:layout_margin="10dp" android:onClick="ClickFloatButton" app:fabSize="normal" app:backgroundTint="#f00" app:elevation="5dp" /&gt; 属性 //上面的文件使用相对布局，可以使用相对锚点的设置定位fab app:layout_anchor=”@id/md_recyclerview”//锚点，基于哪个控件定位 app:layout_anchorGravity=”bottom|right|end”//相对锚点的位置 app:fabSize=”normal”//控件大小，只支持两种大小，mini,normal app:backgroundTint=”#f00”//改变背景颜色，不设置好像是黑的还是跟随主题 app:elevation=”5dp”//阴影12345678910111213141516171819202122232425## AppBarLayout - AppBarLayout本身是一个垂直的LinearLayout，被他包裹的控件将作为ActionBar展示```xml&lt;android.support.design.widget.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt;&lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/md_toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:minHeight=&quot;?attr/actionBarSize&quot; android:background=&quot;?attr/colorPrimary&quot; android:layout_marginBottom=&quot;20dp&quot;&gt;&lt;/android.support.v7.widget.Toolbar&gt;&lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:padding=&quot;10dp&quot; android:text=&quot;这是appbarlayout测试&quot; android:gravity=&quot;center_horizontal&quot; android:textSize=&quot;20sp&quot;/&gt;&lt;/android.support.design.widget.AppBarLayout&gt; CoordinatorLayout 这个（Coordinator）单词的意思是协调器，它是协调控件之间动画效果的一个布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;android.support.design.widget.CoordinatorLayoutxmlns:android="http://schemas.android.com/apk/res/android"xmlns:tools="http://schemas.android.com/tools"xmlns:app="http://schemas.android.com/apk/res-auto"android:layout_width="match_parent"android:layout_height="match_parent"tools:context="com.awesome.newfeatures.SecondActivity"&gt;&lt;android.support.design.widget.AppBarLayoutandroid:layout_width="match_parent"android:layout_height="wrap_content"&gt;&lt;android.support.v7.widget.Toolbarandroid:id="@+id/md_toolbar"android:layout_width="match_parent"android:layout_height="?attr/actionBarSize"android:minHeight="50dp"android:background="?attr/colorPrimary"android:layout_marginBottom="20dp" app:layout_scrollFlags="scroll|enterAlways"/&gt;&lt;android.support.design.widget.TabLayoutandroid:id="@+id/md_tablayout"android:layout_width="match_parent"android:layout_height="wrap_content"app:tabGravity="fill"app:tabTextColor="#f00"app:tabIndicatorColor="#00f"app:tabMode="fixed"app:tabIndicatorHeight="2dp"/&gt;&lt;/android.support.design.widget.AppBarLayout&gt;&lt;android.support.v7.widget.RecyclerViewandroid:id="@+id/md_recyclerview"android:layout_width="match_parent"android:layout_height="match_parent" app:layout_behavior="@string/appbar_scrolling_view_behavior"/&gt;&lt;android.support.design.widget.FloatingActionButtonandroid:layout_width="wrap_content"android:layout_height="wrap_content"android:src="@mipmap/ic_launcher"app:backgroundTint="#00f"app:elevation="5dp"android:layout_margin="16dp"app:layout_anchor="@id/md_recyclerview"app:layout_anchorGravity="bottom|right|end"android:onClick="Click"/&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; app:layout_behavior=”@string/appbar_scrolling_view_behavior”//在视图中可滑动的组件使用该属性标示，必须是RecyclerView或NestedScrollView 试验表明，开始使用后面两个属性并没起作用，后来发现需要固定toolbar高度才会起作用。 FloatingActionButton被包裹在CoordinatorLayout中时可以防止SnackBar跳出时遮挡Fab app:layout_scrollFlags=”scroll|enterAlways”//三种取值 属性选择 描述 scroll 所有需要滑动的视图需要定义该属性，不使用该属性的视图将会固定在屏幕顶端this flag should be set for all views that want to scroll off the screen - for views that do not use this flag, they’ll remain pinned to the top of the screen enterAlways 任意向下的操作会导致隐藏视图显示出来this flag ensures that any downward scroll will cause this view to become visible, enabling the ‘quick return’ pattern enterAlwaysCollapsed 这个flag定义的是何时进入（已经消失之后何时再次显示）。假设你定义了一个最小高度（minHeight）同时enterAlways也定义了，那么view将在到达这个最小高度的时候开始显示，并且从这个时候开始慢慢展开，当滚动到顶部的时候展开完。When your view has declared a minHeight and you use this flag, your View will only enter at its minimum height (i.e., ‘collapsed’), only re-expanding to its full height when the scrolling view has reached it’s top. exitUntilCollapsed 这个flag时定义何时退出，当你定义了一个minHeight，这个view将在滚动到达这个最小高度的时候消失。 this flag causes the view to scroll off until it is ‘collapsed’ (its minHeight) before exiting CollapsingToolbarLayout 使用CollapsingToolbarLayout结合CoordinatorLayout实现可缩放的ActionBar,在使用CoordinatorLayout一直实现不了列表滑动到顶端才显示的效果，使用CollapsingToolbarLayout可以实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;android.support.design.widget.CoordinatorLayoutxmlns:android="http://schemas.android.com/apk/res/android"xmlns:tools="http://schemas.android.com/tools"xmlns:app="http://schemas.android.com/apk/res-auto"android:layout_width="match_parent"android:layout_height="match_parent"tools:context="com.awesome.newfeatures.SecondActivity"&gt; //需要固定高度&lt;android.support.design.widget.AppBarLayoutandroid:id="@+id/appbar"android:layout_width="match_parent"android:layout_height="160dp"&gt;&lt;android.support.design.widget.CollapsingToolbarLayoutandroid:layout_width="match_parent"android:layout_height="match_parent"app:contentScrim="?attr/colorPrimary"app:layout_scrollFlags="scroll|exitUntilCollapsed"&gt;&lt;ImageViewandroid:id="@+id/backdrop"android:layout_width="match_parent"android:layout_height="match_parent"android:scaleType="centerCrop"android:src="@mipmap/ic_launcher"app:layout_collapseMode="parallax"/&gt;&lt;android.support.v7.widget.Toolbarandroid:id="@+id/md_toolbar"android:layout_width="match_parent"android:layout_height="?attr/actionBarSize"app:layout_collapseMode="pin"/&gt;&lt;/android.support.design.widget.CollapsingToolbarLayout&gt;&lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v7.widget.RecyclerViewandroid:id="@+id/md_recyclerview"android:layout_width="match_parent"android:layout_height="wrap_content"app:layout_behavior="@string/appbar_scrolling_view_behavior"/&gt; &lt;android.support.design.widget.FloatingActionButtonandroid:layout_width="wrap_content"android:layout_height="wrap_content"android:src="@mipmap/ic_launcher"app:backgroundTint="#00f"app:elevation="5dp"android:layout_margin="16dp"app:layout_anchor="@id/md_recyclerview"app:layout_anchorGravity="bottom|right|end"android:onClick="Click"/&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; AppBarLayout高度需要固定 CollapsingToolbarLayout设置app:layout_scrollFlags 1234567- 23.1.0以后新增一个snap可以在拉动到底部时产生缩放效果- app:layout_scrollFlags=&quot;scroll|enterAlways&quot;- app:layout_scrollFlags=&quot;scroll|enterAlwaysCollapsed&quot;- 不论ToolBar是否设置pin模式，将会全部滚出屏幕，任意下拉动画会使隐藏的视图显示出来- app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;- //设置为pin模式的固定在顶端，下拉到顶部才显示出隐藏视图- app:layout_collapseMode=&quot;parallax&quot;//需要固定的视图使用pin模式，需要滑动的视图使用parallax模式 一些属性setTitle(CharSequence)//设置固定在顶端时显示的titlesetContentScrim(Drawable)app:contentScrim=”?attr/colorPrimary”//修改固定在顶端的背景颜色setStatusBarScrim(Drawable)//状态栏背景，5.0以上有效app:layout_collapseParallaxMultiplier=”0.6”//滑动的视觉差，产生的效果是提前将折叠的视图隐藏掉了app:layout_collapseMode=”parallax|pin”//滑动模式，缩放或者固定collapsingToolbarLayout.setTitle(&quot;title&quot;);//设置标题，将会自动进行缩放//设置颜色后将会自动进行颜色过渡collapsingToolbarLayout.setExpandedTitleColor(Color.WHITE);collapsingToolbarLayout.setCollapsedTitleTextColor(Color.GREEN); DrawerLayout+NavigationView 结合之前学的总结在一个布局中，首先DrawerLayout需要有两个子view，上面的一个代表content,下面的NavigationView代表菜单导航，当然你可以替换成自己的布局，用来做其他的事情。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 &lt;android.support.v4.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/md_DrawerLayout" android:layout_width="match_parent" android:layout_height="match_parent" android:fitsSystemWindows="true" tools:context=".MainActivity" &gt; &lt;android.support.design.widget.CoordinatorLayout android:layout_width="match_parent" android:layout_height="wrap_content" &gt; &lt;android.support.design.widget.AppBarLayout android:id="@+id/appbar" android:layout_width="match_parent" android:layout_height="160dp" &gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:id="@+id/md_CollapsingToolbarLayout" android:layout_width="match_parent" android:layout_height="match_parent" app:contentScrim="?attr/colorPrimary" app:layout_scrollFlags="scroll|exitUntilCollapsed" &gt; &lt;ImageView android:id="@+id/backdrop" android:layout_width="match_parent" android:layout_height="match_parent" android:scaleType="centerCrop" android:src="@mipmap/ic_launcher" app:layout_collapseMode="parallax" app:layout_collapseParallaxMultiplier="0.3" /&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/md_toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" app:layout_collapseMode="pin" /&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/md_recyclerview" android:layout_width="match_parent" android:layout_height="wrap_content"app:layout_behavior="@string/appbar_scrolling_view_behavior" /&gt; &lt;android.support.design.widget.FloatingActionButton android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@mipmap/ic_launcher" app:backgroundTint="#00f" app:elevation="5dp" android:layout_margin="16dp" app:layout_anchor="@id/md_recyclerview" app:layout_anchorGravity="bottom|right|end" android:onClick="Click" /&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; &lt;android.support.design.widget.NavigationView android:id="@+id/md_NavigationView" android:layout_width="wrap_content" android:layout_height="match_parent" android:layout_gravity="start" app:headerLayout="@layout/header" app:menu="@menu/drawer" /&gt; &lt;/android.support.v4.widget.DrawerLayout&gt; 几个属性1234567891011121314关于NavigationView中item的字体颜色和icon选中状态颜色是去当前主题theme中的&lt;--正常状态下字体颜色和icon颜色--&gt;&lt;item name=&quot;android:textColorPrimary&quot;&gt;@android:color/darker_gray&lt;/item&gt;&lt;--选中状态icon的颜色和字体颜色--&gt;&lt;item name=&quot;colorPrimary&quot;&gt;@color/accent_material_light&lt;/item&gt;当然你可以通过如下方法或者属性来改变这一状态：setItemBackgroundResource(int)app:itemBackground`//给menu设置背景资源setItemIconTintList(ColorStateList)app:itemIconTint`//给menu的icon设置颜色，对应的属性setItemTextColor(ColorStateList)app:itemTextColor`//给menu的item设置字体颜色，对应的属性app:headerLayout=&quot;@layout/header&quot;//NavigationView的头部布局app:menu=&quot;@menu/drawer&quot;`//NavigationView的菜单文件 代码12345678910111213141516171819mDrawerLayout = (DrawerLayout) findViewById(R.id.md_DrawerLayout);//这个组件将会展示一个图标在左上角，它是一个DrawerListener的子类，使用它可以简单地创建一个抽屉的控制图标，v4包下的该组件可以设置导航图标，但是已经过时，这里使用v7包下的组件，但是没有了设置图标的参数，如果想自定义可以使用自定义的图标，在实现DrawerListener时做处理ActionBarDrawerToggle mDrawerToggle = new ActionBarDrawerToggle(this, mDrawerLayout, toolbar, R.string.close, R.string.open);//没有找到合适的方法修改图标，这个方法没有效果 mDrawerToggle.setHomeAsUpIndicator(R.mipmap.ic_launcher); //初始化状态 mDrawerToggle.syncState(); mDrawerLayout.setDrawerListener(mDrawerToggle); //设置导航栏NavigationView的点击事件 final NavigationView mNavigationView = (NavigationView) findViewById(R.id.md_NavigationView); mNavigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() &#123; @Override public boolean onNavigationItemSelected(MenuItem menuItem) &#123; //使用该方法可以选中Item，但是出现了一个问题，点击时有时会造成选中无法取消，试过一个解决办法是获得Menu的所有Item设置不选中可以解决这个问题。 menuItem.setChecked(true); mDrawerLayout.closeDrawers();//关闭抽屉 return true; &#125; &#125;);]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[v4v7 新控件]]></title>
    <url>%2Farticle%2F1947623271%2F</url>
    <content type="text"><![CDATA[AlertDialogv7风格的Dialog相对原来的版本去掉了跳跃弹出的动画，下方按钮去掉了边框，聚集在了右侧，显示时去掉了分隔线。 ToolBar取代原先的ActionBar实现相对完美的定制 xml文件12345678&lt;android.support.v7.widget.Toolbarandroid:id="@+id/md_toolbar"android:layout_width="match_parent"android:layout_height="?attr/actionBarSize"android:minHeight="50dp"android:background="?attr/colorPrimary"android:layout_marginBottom="20dp" &gt; 代码123456789101112131415161718192021 //隐藏系统默认title,我当时修改了theme用的noactionbar的Theme所以这行代码并没用getSupportActionBar().setDisplayShowTitleEnabled(false);Toolbar toolbar = (Toolbar) findViewById(R.id.md_toolbar);//标题toolbar.setTitle("测试");//副标题，显示在标题下方toolbar.setSubtitle("副标题");//logo,显示在标题左侧toolbar.setLogo(R.mipmap.ic_launcher); //导航图标，显示在最左侧，可以使用该图标调出菜单toolbar.setNavigationIcon(android.R.drawable.ic_input_delete);//这个并没有用，设置菜单时重写onCreateOptionMenu即可//toolbar.inflateMenu(R.menu.menu_main);setSupportActionBar(toolbar);toolbar.setOnMenuItemClickListener(new OnMenuItemClickListener() &#123; @Override public boolean onMenuItemClick(MenuItem item) &#123;Toast.makeText(MainActivity.this, "点击了" + item.getItemId(), Toast.LENGTH_SHORT).show(); return false; &#125;&#125;); 题外话,如何创建菜单项12345678910111213141516171819202122232425262728293031323334//重写该方法，菜单将会显示在toobar上@Overridepublic boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.menu_main, menu); //获取toolbar上的菜单view,也可以在上面的setOnMenuItemClickListener实现更加简单，这里只是一个演示。 MenuItem item = menu.findItem(R.id.action_share); //强转为你需要的view View actionView = item.getActionView(); return super.onCreateOptionsMenu(menu);&#125;//菜单文件，为没有接触过的小伙伴准备的额,相关属性请自行查文档//res/menu/menu_main.xml&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;xmlns:tools=&quot;http://schemas.android.com/tools&quot;tools:context=&quot;.MainActivity&quot;&gt;&lt;itemandroid:id=&quot;@+id/ab_search&quot;android:orderInCategory=&quot;80&quot;android:title=&quot;action_search&quot; app:actionViewClass=&quot;android.support.v7.widget.SearchView&quot;/&gt;&lt;itemandroid:id=&quot;@+id/action_share&quot;android:orderInCategory=&quot;90&quot;android:title=&quot;action_share&quot; app:actionProviderClass=&quot;android.support.v7.widget.ShareActionProvider&quot;app:showAsAction=&quot;ifRoom&quot;/&gt;&lt;itemandroid:id=&quot;@+id/action_settings&quot;android:orderInCategory=&quot;100&quot;android:title=&quot;action_settings&quot;app:showAsAction=&quot;never&quot;/&gt;&lt;/menu&gt; LinearLayoutCompat 在控件中间添加分隔线 1234567891011&lt;android.support.v7.widget.LinearLayoutCompatandroid:layout_width="match_parent"android:layout_height="wrap_content"android:layout_gravity="center|center_horizontal"android:orientation="vertical"app:divider="@drawable/line"app:dividerPadding="4dp"app:showDividers="middle"&gt;.....&lt;/android.support.v7.widget.LinearLayoutCompat&gt; app:divider=”@drawable/line” 给分隔线设置颜色，这里你需要在drawable在定义shape资源，否则将没有效果。 app:dividerPadding=”25dp” 给分隔线设置距离左右边距的距离。 app:showDividers=”middle|beginning|end” 分隔线显示的位置，有四种参数值：middle 每个item之间，beginning最顶端显示分隔线，end 最底端显示分隔线，none不显示间隔线。 ListPopupWindow123456789101112131415161718192021222324public void showListPopup(View view) &#123; String items[] = &#123;"item1", "item2", "item3", "item4", "item5"&#125;; final ListPopupWindow listPopupWindow = new ListPopupWindow(this); //设置ListView类型的适配器 listPopupWindow.setAdapter(new ArrayAdapter&lt;String&gt;(SwipeRefreshActivity.this, android.R.layout.simple_list_item_1, items)); //给每个item设置监听事件 listPopupWindow.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; Toast.makeText(SwipeRefreshActivity.this, "the position is" + position, Toast.LENGTH_SHORT).show(); //listPopupWindow.dismiss(); &#125; &#125;); //设置ListPopupWindow的锚点,也就是弹出框的位置是相对当前参数View的位置来显示， listPopupWindow.setAnchorView(view); //ListPopupWindow 距锚点的距离，也就是相对锚点View的位置 listPopupWindow.setHorizontalOffset(100); listPopupWindow.setVerticalOffset(100); //设置对话框的宽高 listPopupWindow.setWidth(300); listPopupWindow.setHeight(600); listPopupWindow.setModal(false); listPopupWindow.show(); &#125; PopupMenu12345678910111213141516public void showPopupMenu(View view) &#123;//参数View 是设置当前菜单显示的相对于View组件位置，具体位置系统会处理PopupMenu popupMenu = new PopupMenu(this, view);//加载menu布局popupMenu.getMenuInflater().inflate(R.menu.menu_main, popupMenu.getMenu());//设置menu中的item点击事件popupMenu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() &#123;@Overridepublic boolean onMenuItemClick(MenuItem item) &#123;return false;&#125;&#125;);//设置popupWindow消失的点击事件popupMenu.setOnDismissListener(this);popupMenu.show();&#125; 新风格Spinner12345&lt;Spinner android:id="@+id/spinner" style="@android:style/Widget.Holo.Light.Spinner" android:layout_width="wrap_content" android:layout_height="wrap_content"&gt;&lt;/Spinner&gt; v4 SwipeRefreshLayout SwipeRefreshLayout继承自ViewGroup,理论上可以完成任何View的刷新 代码12345678final SwipeRefreshLayout swipeRefreshLayout = (SwipeRefreshLayout) findViewById(R.id.md_SwipeRefreshLayout);//设置进度条的颜色swipeRefreshLayout.setColorSchemeColors(Color.RED, Color.BLUE, Color.GREEN);//设置圆形进度条大小swipeRefreshLayout.setSize(SwipeRefreshLayout.LARGE);//设置进度条背景颜色 swipeRefreshLayout.setProgressBackgroundColorSchemeColor(Color.WHITE);//设置下拉多少距离之后开始刷新数据，不要设置的太大，不然怎么拉都不刷新swipeRefreshLayout.setDistanceToTriggerSync(5);]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件设计原则]]></title>
    <url>%2Farticle%2F1361585574%2F</url>
    <content type="text"><![CDATA[本文主要介绍设计模式的设计和使用。 类是不稳定的，但是抽象相对稳定，依赖于抽象将获得更加稳定的类结构。 设计原则单一指责 每个类只负责单一的功能，避免修改一个功能完成另一个功能的错误出现。 里氏替换/抽象类原则 子类实现父类的抽象方法 子类不要修改父类的非抽象方法 子类实现抽象方法时前置条件（参数）应该更加宽松 子类重写父类的方法后置条件（返回值）应该更加严格 依赖倒置 高层模块不应该依赖于底层模块，二者都应该依赖于抽象 抽象不能依赖于细节，细节要依赖抽象 多用抽象的接口描述动作。抽象难以扩展或者扩展复杂的的动作，降低动作执行者和动作承受者之间的关联 迪米特法则/最少知道原则 每个类对自己依赖的类知道的越少越好，被依赖的类开放公开的方法却封装内部复杂的逻辑 开闭原则 对扩展是开放的对修改是封闭的 使用增加软件实体的方法来扩展功能而不要使用修改代码的方式 接口隔离原则 一个类对另一个类的依赖应该建立在最小的接口上，也就是不要强迫子类实现他不需要的功能，如果需要这么做那么说明这个接口最小接口需要拆分]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发问题常见问题]]></title>
    <url>%2Farticle%2F1817351074%2F</url>
    <content type="text"><![CDATA[方法数量超出限制 使用分包策略 出现exit value 3之类的错误通常是方法数目超出限制了，建议使用分包机制，但这不是解决问题的方法,最重要的还是准确选择类库，精简方法数。 1234567891011121314//引入分包compile 'com.android.support:multidex:1.0.1'／／添加允许多方法defaultConfig &#123; multiDexEnabled true &#125;／／在Application添加分包初始化@Overrideprotected void attachBaseContext(Context base) &#123; super.attachBaseContext(base); MultiDex.install(this); ｝ 方法数统计 推荐一个插件，可以计算每个包下面的方法数目 在app.gradle文件头添加以下插件，会在app/build/outputs/dexcount/debug.txt文件里生成每个包下面的方法数，如下：apply plugin: ‘com.getkeepsafe.dexcount’ 123456789101112methods fields package/class name8 0 &lt;unnamed&gt;21186 8027 android6 0 android.accessibilityservice34 0 android.animation556 33 android.app3 0 android.app.usage2 0 android.appwidget488 50 android.content42 43 android.content.pm106 6 android.content.res79 0 android.database 签名问题12345678910111213141516171819202122//正式签名相关信息signingConfigs &#123; myConfig &#123; storeFile file("相对或者绝对路径") storePassword "sangular123" keyAlias "sangular" keyPassword "sangular123" &#125;&#125;buildTypes &#123; //release版本的正式签名 release &#123; //minifyEnabled true 打包发布时会使用该代码 //proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' signingConfig signingConfigs.myConfig &#125; //debug版本也用正式签名调试，这样可以在debug版本下使用第三方登陆等功能 debug &#123; signingConfig signingConfigs.myConfig ｝&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AndroidTips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见排序及搜索算法总结]]></title>
    <url>%2Farticle%2F395850883%2F</url>
    <content type="text"><![CDATA[Arrays.sort()Arrays.sort()使用了两种排序方法，快速排序和优化的合并排序。 快速排序主要是对哪些基本类型数据（int,short,long等）排序。 而合并排序用于对对象类型进行排序。 原因：使用不同类型的排序算法主要是由于快速排序是不稳定的，而合并排序是稳定的。这里的稳定是指比较相等的数据在排序之后仍然按照排序之前的前后顺序排列。对于基本数据类型，稳定性没有意义，而对于对象类型，稳定性是比较重要的，因为对象相等的判断可能只是判断关键属性，最好保持相等对象的非关键属性的顺序与排序前一致。 另外一个原因是由于合并排序相对而言 比较次数 比快速排序少， 移动(对象引用的移动)次数 比快速排序多，而对于对象来说，移动是简单的，只是引用的转换，但是比较相对更加耗时。 合并排序的时间复杂度是n*logn, 快速排序的平均时间复杂度也是n*logn，但是合并排序的需要额外的n个引用的空间。 排序算法实现冒泡排序12345678910111213//冒泡:0 ~ n-1 0 ~ n-1-i//冒泡排序:两两比较,比较n-1趟,每一趟比较n-i-1次public static void BubbleSort(int a[])&#123; int n = a.length; for(int i = 0; i &lt; n - 1; i++) //比较n-1趟 for(int j = 0; j &lt; n - 1 - i; j++)&#123;//比较n-i-1次! if(a[j+1] &lt; a[j])&#123; a[j+1] = a[j+1] ^ a[j]; a[j] = a[j] ^ a[j+1]; a[j+1] = a[j] ^ a[j+1]; &#125; &#125;&#125; 选择排序123456789101112131415161718//选择排序:遍历前n-1个元素,与 i+1 直到 n 个元素比较,记录小数下标public static void SelectSort(int a[])&#123; int n = a.length; for(int i = 0; i &lt; n - 1; i++)&#123; int min = i; for(int j = i + 1; j &lt; n; j++)&#123; if(a[min] &gt; a[j])&#123; min = j; &#125; &#125; if(min != i)&#123; a[i] = a[i] ^ a[min]; a[min] = a[min] ^ a[i]; a[i] = a[min] ^ a[i]; &#125; &#125;&#125; 插入排序1234567891011121314//插入排序:左边为有序区域,遍历第一个直到第n个,与前i个比较 public static void InsertSort(int a[])&#123; int n = a.length; for(int i = 1;i &lt; n; i++) for(int j = i; j &gt; 0; j--)&#123; if(a[j] &lt; a[j-1])&#123; a[j] = a[j] ^ a[j-1]; a[j-1] = a[j-1] ^ a[j]; a[j] = a[j-1] ^ a[j]; &#125; else break; &#125; &#125; 快速排序1234567891011121314151617181920212223public static void quicksort(int n[], int left, int right) &#123; int dp; if (left &lt; right) &#123; dp = partition(n, left, right); quicksort(n, left, dp - 1); quicksort(n, dp + 1, right); &#125; &#125;public static int partition(int n[], int left, int right) &#123; int pivot = n[left]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; n[right] &gt;= pivot) right--; if (left &lt; right) n[left++] = n[right]; while (left &lt; right &amp;&amp; n[left] &lt;= pivot) left++; if (left &lt; right) n[right--] = n[left]; &#125; n[left] = pivot; return left;&#125; 搜索算法实现二分法搜索123456789101112131415161718public static int HalfSearch(int a[],int target)&#123; int bottom = 0; int top = a.length - 1; int middle = (top + bottom) / 2; while(bottom &lt;= top)&#123; if(a[middle] &gt; target)&#123; top = middle - 1; &#125; else if(a[middle] &lt; target)&#123; bottom = middle + 1; &#125; else &#123; return middle; &#125; middle = (top + bottom) / 2; &#125; return -1; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>